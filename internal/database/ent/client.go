// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/denkhaus/agentforge/internal/database/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/denkhaus/agentforge/internal/database/ent/agent"
	"github.com/denkhaus/agentforge/internal/database/ent/agentdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/component"
	"github.com/denkhaus/agentforge/internal/database/ent/componentdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/fork"
	"github.com/denkhaus/agentforge/internal/database/ent/localconfig"
	"github.com/denkhaus/agentforge/internal/database/ent/prompt"
	"github.com/denkhaus/agentforge/internal/database/ent/promptdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/repository"
	"github.com/denkhaus/agentforge/internal/database/ent/syncoperation"
	"github.com/denkhaus/agentforge/internal/database/ent/tool"
	"github.com/denkhaus/agentforge/internal/database/ent/tooldependency"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Agent is the client for interacting with the Agent builders.
	Agent *AgentClient
	// AgentDependency is the client for interacting with the AgentDependency builders.
	AgentDependency *AgentDependencyClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// ComponentDependency is the client for interacting with the ComponentDependency builders.
	ComponentDependency *ComponentDependencyClient
	// Fork is the client for interacting with the Fork builders.
	Fork *ForkClient
	// LocalConfig is the client for interacting with the LocalConfig builders.
	LocalConfig *LocalConfigClient
	// Prompt is the client for interacting with the Prompt builders.
	Prompt *PromptClient
	// PromptDependency is the client for interacting with the PromptDependency builders.
	PromptDependency *PromptDependencyClient
	// Repository is the client for interacting with the Repository builders.
	Repository *RepositoryClient
	// SyncOperation is the client for interacting with the SyncOperation builders.
	SyncOperation *SyncOperationClient
	// Tool is the client for interacting with the Tool builders.
	Tool *ToolClient
	// ToolDependency is the client for interacting with the ToolDependency builders.
	ToolDependency *ToolDependencyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Agent = NewAgentClient(c.config)
	c.AgentDependency = NewAgentDependencyClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.ComponentDependency = NewComponentDependencyClient(c.config)
	c.Fork = NewForkClient(c.config)
	c.LocalConfig = NewLocalConfigClient(c.config)
	c.Prompt = NewPromptClient(c.config)
	c.PromptDependency = NewPromptDependencyClient(c.config)
	c.Repository = NewRepositoryClient(c.config)
	c.SyncOperation = NewSyncOperationClient(c.config)
	c.Tool = NewToolClient(c.config)
	c.ToolDependency = NewToolDependencyClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Agent:               NewAgentClient(cfg),
		AgentDependency:     NewAgentDependencyClient(cfg),
		Component:           NewComponentClient(cfg),
		ComponentDependency: NewComponentDependencyClient(cfg),
		Fork:                NewForkClient(cfg),
		LocalConfig:         NewLocalConfigClient(cfg),
		Prompt:              NewPromptClient(cfg),
		PromptDependency:    NewPromptDependencyClient(cfg),
		Repository:          NewRepositoryClient(cfg),
		SyncOperation:       NewSyncOperationClient(cfg),
		Tool:                NewToolClient(cfg),
		ToolDependency:      NewToolDependencyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Agent:               NewAgentClient(cfg),
		AgentDependency:     NewAgentDependencyClient(cfg),
		Component:           NewComponentClient(cfg),
		ComponentDependency: NewComponentDependencyClient(cfg),
		Fork:                NewForkClient(cfg),
		LocalConfig:         NewLocalConfigClient(cfg),
		Prompt:              NewPromptClient(cfg),
		PromptDependency:    NewPromptDependencyClient(cfg),
		Repository:          NewRepositoryClient(cfg),
		SyncOperation:       NewSyncOperationClient(cfg),
		Tool:                NewToolClient(cfg),
		ToolDependency:      NewToolDependencyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Agent.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Agent, c.AgentDependency, c.Component, c.ComponentDependency, c.Fork,
		c.LocalConfig, c.Prompt, c.PromptDependency, c.Repository, c.SyncOperation,
		c.Tool, c.ToolDependency,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Agent, c.AgentDependency, c.Component, c.ComponentDependency, c.Fork,
		c.LocalConfig, c.Prompt, c.PromptDependency, c.Repository, c.SyncOperation,
		c.Tool, c.ToolDependency,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgentMutation:
		return c.Agent.mutate(ctx, m)
	case *AgentDependencyMutation:
		return c.AgentDependency.mutate(ctx, m)
	case *ComponentMutation:
		return c.Component.mutate(ctx, m)
	case *ComponentDependencyMutation:
		return c.ComponentDependency.mutate(ctx, m)
	case *ForkMutation:
		return c.Fork.mutate(ctx, m)
	case *LocalConfigMutation:
		return c.LocalConfig.mutate(ctx, m)
	case *PromptMutation:
		return c.Prompt.mutate(ctx, m)
	case *PromptDependencyMutation:
		return c.PromptDependency.mutate(ctx, m)
	case *RepositoryMutation:
		return c.Repository.mutate(ctx, m)
	case *SyncOperationMutation:
		return c.SyncOperation.mutate(ctx, m)
	case *ToolMutation:
		return c.Tool.mutate(ctx, m)
	case *ToolDependencyMutation:
		return c.ToolDependency.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgentClient is a client for the Agent schema.
type AgentClient struct {
	config
}

// NewAgentClient returns a client for the Agent from the given config.
func NewAgentClient(c config) *AgentClient {
	return &AgentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agent.Hooks(f(g(h())))`.
func (c *AgentClient) Use(hooks ...Hook) {
	c.hooks.Agent = append(c.hooks.Agent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agent.Intercept(f(g(h())))`.
func (c *AgentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agent = append(c.inters.Agent, interceptors...)
}

// Create returns a builder for creating a Agent entity.
func (c *AgentClient) Create() *AgentCreate {
	mutation := newAgentMutation(c.config, OpCreate)
	return &AgentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agent entities.
func (c *AgentClient) CreateBulk(builders ...*AgentCreate) *AgentCreateBulk {
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentClient) MapCreateBulk(slice any, setFunc func(*AgentCreate, int)) *AgentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentCreateBulk{err: fmt.Errorf("calling to AgentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agent.
func (c *AgentClient) Update() *AgentUpdate {
	mutation := newAgentMutation(c.config, OpUpdate)
	return &AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentClient) UpdateOne(a *Agent) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgent(a))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentClient) UpdateOneID(id string) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgentID(id))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agent.
func (c *AgentClient) Delete() *AgentDelete {
	mutation := newAgentMutation(c.config, OpDelete)
	return &AgentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentClient) DeleteOne(a *Agent) *AgentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentClient) DeleteOneID(id string) *AgentDeleteOne {
	builder := c.Delete().Where(agent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentDeleteOne{builder}
}

// Query returns a query builder for Agent.
func (c *AgentClient) Query() *AgentQuery {
	return &AgentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgent},
		inters: c.Interceptors(),
	}
}

// Get returns a Agent entity by its id.
func (c *AgentClient) Get(ctx context.Context, id string) (*Agent, error) {
	return c.Query().Where(agent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentClient) GetX(ctx context.Context, id string) *Agent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a Agent.
func (c *AgentClient) QueryRepository(a *Agent) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agent.RepositoryTable, agent.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Agent.
func (c *AgentClient) QueryDependencies(a *Agent) *AgentDependencyQuery {
	query := (&AgentDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(agentdependency.Table, agentdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.DependenciesTable, agent.DependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentClient) Hooks() []Hook {
	return c.hooks.Agent
}

// Interceptors returns the client interceptors.
func (c *AgentClient) Interceptors() []Interceptor {
	return c.inters.Agent
}

func (c *AgentClient) mutate(ctx context.Context, m *AgentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agent mutation op: %q", m.Op())
	}
}

// AgentDependencyClient is a client for the AgentDependency schema.
type AgentDependencyClient struct {
	config
}

// NewAgentDependencyClient returns a client for the AgentDependency from the given config.
func NewAgentDependencyClient(c config) *AgentDependencyClient {
	return &AgentDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentdependency.Hooks(f(g(h())))`.
func (c *AgentDependencyClient) Use(hooks ...Hook) {
	c.hooks.AgentDependency = append(c.hooks.AgentDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentdependency.Intercept(f(g(h())))`.
func (c *AgentDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentDependency = append(c.inters.AgentDependency, interceptors...)
}

// Create returns a builder for creating a AgentDependency entity.
func (c *AgentDependencyClient) Create() *AgentDependencyCreate {
	mutation := newAgentDependencyMutation(c.config, OpCreate)
	return &AgentDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentDependency entities.
func (c *AgentDependencyClient) CreateBulk(builders ...*AgentDependencyCreate) *AgentDependencyCreateBulk {
	return &AgentDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentDependencyClient) MapCreateBulk(slice any, setFunc func(*AgentDependencyCreate, int)) *AgentDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentDependencyCreateBulk{err: fmt.Errorf("calling to AgentDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentDependency.
func (c *AgentDependencyClient) Update() *AgentDependencyUpdate {
	mutation := newAgentDependencyMutation(c.config, OpUpdate)
	return &AgentDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentDependencyClient) UpdateOne(ad *AgentDependency) *AgentDependencyUpdateOne {
	mutation := newAgentDependencyMutation(c.config, OpUpdateOne, withAgentDependency(ad))
	return &AgentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentDependencyClient) UpdateOneID(id string) *AgentDependencyUpdateOne {
	mutation := newAgentDependencyMutation(c.config, OpUpdateOne, withAgentDependencyID(id))
	return &AgentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentDependency.
func (c *AgentDependencyClient) Delete() *AgentDependencyDelete {
	mutation := newAgentDependencyMutation(c.config, OpDelete)
	return &AgentDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentDependencyClient) DeleteOne(ad *AgentDependency) *AgentDependencyDeleteOne {
	return c.DeleteOneID(ad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentDependencyClient) DeleteOneID(id string) *AgentDependencyDeleteOne {
	builder := c.Delete().Where(agentdependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentDependencyDeleteOne{builder}
}

// Query returns a query builder for AgentDependency.
func (c *AgentDependencyClient) Query() *AgentDependencyQuery {
	return &AgentDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentDependency entity by its id.
func (c *AgentDependencyClient) Get(ctx context.Context, id string) (*AgentDependency, error) {
	return c.Query().Where(agentdependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentDependencyClient) GetX(ctx context.Context, id string) *AgentDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgent queries the agent edge of a AgentDependency.
func (c *AgentDependencyClient) QueryAgent(ad *AgentDependency) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ad.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentdependency.Table, agentdependency.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agentdependency.AgentTable, agentdependency.AgentColumn),
		)
		fromV = sqlgraph.Neighbors(ad.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentDependencyClient) Hooks() []Hook {
	return c.hooks.AgentDependency
}

// Interceptors returns the client interceptors.
func (c *AgentDependencyClient) Interceptors() []Interceptor {
	return c.inters.AgentDependency
}

func (c *AgentDependencyClient) mutate(ctx context.Context, m *AgentDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentDependency mutation op: %q", m.Op())
	}
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `component.Intercept(f(g(h())))`.
func (c *ComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Component = append(c.inters.Component, interceptors...)
}

// Create returns a builder for creating a Component entity.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComponentClient) MapCreateBulk(slice any, setFunc func(*ComponentCreate, int)) *ComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComponentCreateBulk{err: fmt.Errorf("calling to ComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(co *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(co))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id string) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComponentClient) DeleteOne(co *Component) *ComponentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComponentClient) DeleteOneID(id string) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id string) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id string) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a Component.
func (c *ComponentClient) QueryRepository(co *Component) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, component.RepositoryTable, component.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Component.
func (c *ComponentClient) QueryDependencies(co *Component) *ComponentDependencyQuery {
	query := (&ComponentDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(componentdependency.Table, componentdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, component.DependenciesTable, component.DependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// Interceptors returns the client interceptors.
func (c *ComponentClient) Interceptors() []Interceptor {
	return c.inters.Component
}

func (c *ComponentClient) mutate(ctx context.Context, m *ComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Component mutation op: %q", m.Op())
	}
}

// ComponentDependencyClient is a client for the ComponentDependency schema.
type ComponentDependencyClient struct {
	config
}

// NewComponentDependencyClient returns a client for the ComponentDependency from the given config.
func NewComponentDependencyClient(c config) *ComponentDependencyClient {
	return &ComponentDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `componentdependency.Hooks(f(g(h())))`.
func (c *ComponentDependencyClient) Use(hooks ...Hook) {
	c.hooks.ComponentDependency = append(c.hooks.ComponentDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `componentdependency.Intercept(f(g(h())))`.
func (c *ComponentDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ComponentDependency = append(c.inters.ComponentDependency, interceptors...)
}

// Create returns a builder for creating a ComponentDependency entity.
func (c *ComponentDependencyClient) Create() *ComponentDependencyCreate {
	mutation := newComponentDependencyMutation(c.config, OpCreate)
	return &ComponentDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ComponentDependency entities.
func (c *ComponentDependencyClient) CreateBulk(builders ...*ComponentDependencyCreate) *ComponentDependencyCreateBulk {
	return &ComponentDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComponentDependencyClient) MapCreateBulk(slice any, setFunc func(*ComponentDependencyCreate, int)) *ComponentDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComponentDependencyCreateBulk{err: fmt.Errorf("calling to ComponentDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComponentDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComponentDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ComponentDependency.
func (c *ComponentDependencyClient) Update() *ComponentDependencyUpdate {
	mutation := newComponentDependencyMutation(c.config, OpUpdate)
	return &ComponentDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentDependencyClient) UpdateOne(cd *ComponentDependency) *ComponentDependencyUpdateOne {
	mutation := newComponentDependencyMutation(c.config, OpUpdateOne, withComponentDependency(cd))
	return &ComponentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentDependencyClient) UpdateOneID(id string) *ComponentDependencyUpdateOne {
	mutation := newComponentDependencyMutation(c.config, OpUpdateOne, withComponentDependencyID(id))
	return &ComponentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ComponentDependency.
func (c *ComponentDependencyClient) Delete() *ComponentDependencyDelete {
	mutation := newComponentDependencyMutation(c.config, OpDelete)
	return &ComponentDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComponentDependencyClient) DeleteOne(cd *ComponentDependency) *ComponentDependencyDeleteOne {
	return c.DeleteOneID(cd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComponentDependencyClient) DeleteOneID(id string) *ComponentDependencyDeleteOne {
	builder := c.Delete().Where(componentdependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDependencyDeleteOne{builder}
}

// Query returns a query builder for ComponentDependency.
func (c *ComponentDependencyClient) Query() *ComponentDependencyQuery {
	return &ComponentDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComponentDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a ComponentDependency entity by its id.
func (c *ComponentDependencyClient) Get(ctx context.Context, id string) (*ComponentDependency, error) {
	return c.Query().Where(componentdependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentDependencyClient) GetX(ctx context.Context, id string) *ComponentDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponent queries the component edge of a ComponentDependency.
func (c *ComponentDependencyClient) QueryComponent(cd *ComponentDependency) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(componentdependency.Table, componentdependency.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, componentdependency.ComponentTable, componentdependency.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(cd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentDependencyClient) Hooks() []Hook {
	return c.hooks.ComponentDependency
}

// Interceptors returns the client interceptors.
func (c *ComponentDependencyClient) Interceptors() []Interceptor {
	return c.inters.ComponentDependency
}

func (c *ComponentDependencyClient) mutate(ctx context.Context, m *ComponentDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComponentDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComponentDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComponentDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComponentDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ComponentDependency mutation op: %q", m.Op())
	}
}

// ForkClient is a client for the Fork schema.
type ForkClient struct {
	config
}

// NewForkClient returns a client for the Fork from the given config.
func NewForkClient(c config) *ForkClient {
	return &ForkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fork.Hooks(f(g(h())))`.
func (c *ForkClient) Use(hooks ...Hook) {
	c.hooks.Fork = append(c.hooks.Fork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fork.Intercept(f(g(h())))`.
func (c *ForkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fork = append(c.inters.Fork, interceptors...)
}

// Create returns a builder for creating a Fork entity.
func (c *ForkClient) Create() *ForkCreate {
	mutation := newForkMutation(c.config, OpCreate)
	return &ForkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fork entities.
func (c *ForkClient) CreateBulk(builders ...*ForkCreate) *ForkCreateBulk {
	return &ForkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ForkClient) MapCreateBulk(slice any, setFunc func(*ForkCreate, int)) *ForkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ForkCreateBulk{err: fmt.Errorf("calling to ForkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ForkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ForkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fork.
func (c *ForkClient) Update() *ForkUpdate {
	mutation := newForkMutation(c.config, OpUpdate)
	return &ForkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ForkClient) UpdateOne(f *Fork) *ForkUpdateOne {
	mutation := newForkMutation(c.config, OpUpdateOne, withFork(f))
	return &ForkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ForkClient) UpdateOneID(id string) *ForkUpdateOne {
	mutation := newForkMutation(c.config, OpUpdateOne, withForkID(id))
	return &ForkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fork.
func (c *ForkClient) Delete() *ForkDelete {
	mutation := newForkMutation(c.config, OpDelete)
	return &ForkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ForkClient) DeleteOne(f *Fork) *ForkDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ForkClient) DeleteOneID(id string) *ForkDeleteOne {
	builder := c.Delete().Where(fork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ForkDeleteOne{builder}
}

// Query returns a query builder for Fork.
func (c *ForkClient) Query() *ForkQuery {
	return &ForkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFork},
		inters: c.Interceptors(),
	}
}

// Get returns a Fork entity by its id.
func (c *ForkClient) Get(ctx context.Context, id string) (*Fork, error) {
	return c.Query().Where(fork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ForkClient) GetX(ctx context.Context, id string) *Fork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOriginalRepo queries the original_repo edge of a Fork.
func (c *ForkClient) QueryOriginalRepo(f *Fork) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fork.Table, fork.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fork.OriginalRepoTable, fork.OriginalRepoColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ForkClient) Hooks() []Hook {
	return c.hooks.Fork
}

// Interceptors returns the client interceptors.
func (c *ForkClient) Interceptors() []Interceptor {
	return c.inters.Fork
}

func (c *ForkClient) mutate(ctx context.Context, m *ForkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ForkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ForkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ForkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ForkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fork mutation op: %q", m.Op())
	}
}

// LocalConfigClient is a client for the LocalConfig schema.
type LocalConfigClient struct {
	config
}

// NewLocalConfigClient returns a client for the LocalConfig from the given config.
func NewLocalConfigClient(c config) *LocalConfigClient {
	return &LocalConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `localconfig.Hooks(f(g(h())))`.
func (c *LocalConfigClient) Use(hooks ...Hook) {
	c.hooks.LocalConfig = append(c.hooks.LocalConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `localconfig.Intercept(f(g(h())))`.
func (c *LocalConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.LocalConfig = append(c.inters.LocalConfig, interceptors...)
}

// Create returns a builder for creating a LocalConfig entity.
func (c *LocalConfigClient) Create() *LocalConfigCreate {
	mutation := newLocalConfigMutation(c.config, OpCreate)
	return &LocalConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LocalConfig entities.
func (c *LocalConfigClient) CreateBulk(builders ...*LocalConfigCreate) *LocalConfigCreateBulk {
	return &LocalConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LocalConfigClient) MapCreateBulk(slice any, setFunc func(*LocalConfigCreate, int)) *LocalConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LocalConfigCreateBulk{err: fmt.Errorf("calling to LocalConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LocalConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LocalConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LocalConfig.
func (c *LocalConfigClient) Update() *LocalConfigUpdate {
	mutation := newLocalConfigMutation(c.config, OpUpdate)
	return &LocalConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocalConfigClient) UpdateOne(lc *LocalConfig) *LocalConfigUpdateOne {
	mutation := newLocalConfigMutation(c.config, OpUpdateOne, withLocalConfig(lc))
	return &LocalConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocalConfigClient) UpdateOneID(id string) *LocalConfigUpdateOne {
	mutation := newLocalConfigMutation(c.config, OpUpdateOne, withLocalConfigID(id))
	return &LocalConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LocalConfig.
func (c *LocalConfigClient) Delete() *LocalConfigDelete {
	mutation := newLocalConfigMutation(c.config, OpDelete)
	return &LocalConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocalConfigClient) DeleteOne(lc *LocalConfig) *LocalConfigDeleteOne {
	return c.DeleteOneID(lc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocalConfigClient) DeleteOneID(id string) *LocalConfigDeleteOne {
	builder := c.Delete().Where(localconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocalConfigDeleteOne{builder}
}

// Query returns a query builder for LocalConfig.
func (c *LocalConfigClient) Query() *LocalConfigQuery {
	return &LocalConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocalConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a LocalConfig entity by its id.
func (c *LocalConfigClient) Get(ctx context.Context, id string) (*LocalConfig, error) {
	return c.Query().Where(localconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocalConfigClient) GetX(ctx context.Context, id string) *LocalConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LocalConfigClient) Hooks() []Hook {
	return c.hooks.LocalConfig
}

// Interceptors returns the client interceptors.
func (c *LocalConfigClient) Interceptors() []Interceptor {
	return c.inters.LocalConfig
}

func (c *LocalConfigClient) mutate(ctx context.Context, m *LocalConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocalConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocalConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocalConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocalConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LocalConfig mutation op: %q", m.Op())
	}
}

// PromptClient is a client for the Prompt schema.
type PromptClient struct {
	config
}

// NewPromptClient returns a client for the Prompt from the given config.
func NewPromptClient(c config) *PromptClient {
	return &PromptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prompt.Hooks(f(g(h())))`.
func (c *PromptClient) Use(hooks ...Hook) {
	c.hooks.Prompt = append(c.hooks.Prompt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prompt.Intercept(f(g(h())))`.
func (c *PromptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Prompt = append(c.inters.Prompt, interceptors...)
}

// Create returns a builder for creating a Prompt entity.
func (c *PromptClient) Create() *PromptCreate {
	mutation := newPromptMutation(c.config, OpCreate)
	return &PromptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Prompt entities.
func (c *PromptClient) CreateBulk(builders ...*PromptCreate) *PromptCreateBulk {
	return &PromptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromptClient) MapCreateBulk(slice any, setFunc func(*PromptCreate, int)) *PromptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromptCreateBulk{err: fmt.Errorf("calling to PromptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Prompt.
func (c *PromptClient) Update() *PromptUpdate {
	mutation := newPromptMutation(c.config, OpUpdate)
	return &PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromptClient) UpdateOne(pr *Prompt) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPrompt(pr))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromptClient) UpdateOneID(id string) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPromptID(id))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prompt.
func (c *PromptClient) Delete() *PromptDelete {
	mutation := newPromptMutation(c.config, OpDelete)
	return &PromptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromptClient) DeleteOne(pr *Prompt) *PromptDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromptClient) DeleteOneID(id string) *PromptDeleteOne {
	builder := c.Delete().Where(prompt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromptDeleteOne{builder}
}

// Query returns a query builder for Prompt.
func (c *PromptClient) Query() *PromptQuery {
	return &PromptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrompt},
		inters: c.Interceptors(),
	}
}

// Get returns a Prompt entity by its id.
func (c *PromptClient) Get(ctx context.Context, id string) (*Prompt, error) {
	return c.Query().Where(prompt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromptClient) GetX(ctx context.Context, id string) *Prompt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a Prompt.
func (c *PromptClient) QueryRepository(pr *Prompt) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prompt.Table, prompt.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, prompt.RepositoryTable, prompt.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Prompt.
func (c *PromptClient) QueryDependencies(pr *Prompt) *PromptDependencyQuery {
	query := (&PromptDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prompt.Table, prompt.FieldID, id),
			sqlgraph.To(promptdependency.Table, promptdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prompt.DependenciesTable, prompt.DependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromptClient) Hooks() []Hook {
	return c.hooks.Prompt
}

// Interceptors returns the client interceptors.
func (c *PromptClient) Interceptors() []Interceptor {
	return c.inters.Prompt
}

func (c *PromptClient) mutate(ctx context.Context, m *PromptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Prompt mutation op: %q", m.Op())
	}
}

// PromptDependencyClient is a client for the PromptDependency schema.
type PromptDependencyClient struct {
	config
}

// NewPromptDependencyClient returns a client for the PromptDependency from the given config.
func NewPromptDependencyClient(c config) *PromptDependencyClient {
	return &PromptDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promptdependency.Hooks(f(g(h())))`.
func (c *PromptDependencyClient) Use(hooks ...Hook) {
	c.hooks.PromptDependency = append(c.hooks.PromptDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promptdependency.Intercept(f(g(h())))`.
func (c *PromptDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.PromptDependency = append(c.inters.PromptDependency, interceptors...)
}

// Create returns a builder for creating a PromptDependency entity.
func (c *PromptDependencyClient) Create() *PromptDependencyCreate {
	mutation := newPromptDependencyMutation(c.config, OpCreate)
	return &PromptDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PromptDependency entities.
func (c *PromptDependencyClient) CreateBulk(builders ...*PromptDependencyCreate) *PromptDependencyCreateBulk {
	return &PromptDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromptDependencyClient) MapCreateBulk(slice any, setFunc func(*PromptDependencyCreate, int)) *PromptDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromptDependencyCreateBulk{err: fmt.Errorf("calling to PromptDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromptDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromptDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PromptDependency.
func (c *PromptDependencyClient) Update() *PromptDependencyUpdate {
	mutation := newPromptDependencyMutation(c.config, OpUpdate)
	return &PromptDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromptDependencyClient) UpdateOne(pd *PromptDependency) *PromptDependencyUpdateOne {
	mutation := newPromptDependencyMutation(c.config, OpUpdateOne, withPromptDependency(pd))
	return &PromptDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromptDependencyClient) UpdateOneID(id string) *PromptDependencyUpdateOne {
	mutation := newPromptDependencyMutation(c.config, OpUpdateOne, withPromptDependencyID(id))
	return &PromptDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PromptDependency.
func (c *PromptDependencyClient) Delete() *PromptDependencyDelete {
	mutation := newPromptDependencyMutation(c.config, OpDelete)
	return &PromptDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromptDependencyClient) DeleteOne(pd *PromptDependency) *PromptDependencyDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromptDependencyClient) DeleteOneID(id string) *PromptDependencyDeleteOne {
	builder := c.Delete().Where(promptdependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromptDependencyDeleteOne{builder}
}

// Query returns a query builder for PromptDependency.
func (c *PromptDependencyClient) Query() *PromptDependencyQuery {
	return &PromptDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromptDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a PromptDependency entity by its id.
func (c *PromptDependencyClient) Get(ctx context.Context, id string) (*PromptDependency, error) {
	return c.Query().Where(promptdependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromptDependencyClient) GetX(ctx context.Context, id string) *PromptDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrompt queries the prompt edge of a PromptDependency.
func (c *PromptDependencyClient) QueryPrompt(pd *PromptDependency) *PromptQuery {
	query := (&PromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promptdependency.Table, promptdependency.FieldID, id),
			sqlgraph.To(prompt.Table, prompt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, promptdependency.PromptTable, promptdependency.PromptColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromptDependencyClient) Hooks() []Hook {
	return c.hooks.PromptDependency
}

// Interceptors returns the client interceptors.
func (c *PromptDependencyClient) Interceptors() []Interceptor {
	return c.inters.PromptDependency
}

func (c *PromptDependencyClient) mutate(ctx context.Context, m *PromptDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromptDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromptDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromptDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromptDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PromptDependency mutation op: %q", m.Op())
	}
}

// RepositoryClient is a client for the Repository schema.
type RepositoryClient struct {
	config
}

// NewRepositoryClient returns a client for the Repository from the given config.
func NewRepositoryClient(c config) *RepositoryClient {
	return &RepositoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repository.Hooks(f(g(h())))`.
func (c *RepositoryClient) Use(hooks ...Hook) {
	c.hooks.Repository = append(c.hooks.Repository, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repository.Intercept(f(g(h())))`.
func (c *RepositoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Repository = append(c.inters.Repository, interceptors...)
}

// Create returns a builder for creating a Repository entity.
func (c *RepositoryClient) Create() *RepositoryCreate {
	mutation := newRepositoryMutation(c.config, OpCreate)
	return &RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repository entities.
func (c *RepositoryClient) CreateBulk(builders ...*RepositoryCreate) *RepositoryCreateBulk {
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepositoryClient) MapCreateBulk(slice any, setFunc func(*RepositoryCreate, int)) *RepositoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepositoryCreateBulk{err: fmt.Errorf("calling to RepositoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepositoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repository.
func (c *RepositoryClient) Update() *RepositoryUpdate {
	mutation := newRepositoryMutation(c.config, OpUpdate)
	return &RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepositoryClient) UpdateOne(r *Repository) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepository(r))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepositoryClient) UpdateOneID(id string) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepositoryID(id))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repository.
func (c *RepositoryClient) Delete() *RepositoryDelete {
	mutation := newRepositoryMutation(c.config, OpDelete)
	return &RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepositoryClient) DeleteOne(r *Repository) *RepositoryDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepositoryClient) DeleteOneID(id string) *RepositoryDeleteOne {
	builder := c.Delete().Where(repository.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepositoryDeleteOne{builder}
}

// Query returns a query builder for Repository.
func (c *RepositoryClient) Query() *RepositoryQuery {
	return &RepositoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepository},
		inters: c.Interceptors(),
	}
}

// Get returns a Repository entity by its id.
func (c *RepositoryClient) Get(ctx context.Context, id string) (*Repository, error) {
	return c.Query().Where(repository.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepositoryClient) GetX(ctx context.Context, id string) *Repository {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a Repository.
func (c *RepositoryClient) QueryComponents(r *Repository) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.ComponentsTable, repository.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTools queries the tools edge of a Repository.
func (c *RepositoryClient) QueryTools(r *Repository) *ToolQuery {
	query := (&ToolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(tool.Table, tool.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.ToolsTable, repository.ToolsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrompts queries the prompts edge of a Repository.
func (c *RepositoryClient) QueryPrompts(r *Repository) *PromptQuery {
	query := (&PromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(prompt.Table, prompt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.PromptsTable, repository.PromptsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgents queries the agents edge of a Repository.
func (c *RepositoryClient) QueryAgents(r *Repository) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.AgentsTable, repository.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryForks queries the forks edge of a Repository.
func (c *RepositoryClient) QueryForks(r *Repository) *ForkQuery {
	query := (&ForkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(fork.Table, fork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.ForksTable, repository.ForksColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepositoryClient) Hooks() []Hook {
	return c.hooks.Repository
}

// Interceptors returns the client interceptors.
func (c *RepositoryClient) Interceptors() []Interceptor {
	return c.inters.Repository
}

func (c *RepositoryClient) mutate(ctx context.Context, m *RepositoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Repository mutation op: %q", m.Op())
	}
}

// SyncOperationClient is a client for the SyncOperation schema.
type SyncOperationClient struct {
	config
}

// NewSyncOperationClient returns a client for the SyncOperation from the given config.
func NewSyncOperationClient(c config) *SyncOperationClient {
	return &SyncOperationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `syncoperation.Hooks(f(g(h())))`.
func (c *SyncOperationClient) Use(hooks ...Hook) {
	c.hooks.SyncOperation = append(c.hooks.SyncOperation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `syncoperation.Intercept(f(g(h())))`.
func (c *SyncOperationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SyncOperation = append(c.inters.SyncOperation, interceptors...)
}

// Create returns a builder for creating a SyncOperation entity.
func (c *SyncOperationClient) Create() *SyncOperationCreate {
	mutation := newSyncOperationMutation(c.config, OpCreate)
	return &SyncOperationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SyncOperation entities.
func (c *SyncOperationClient) CreateBulk(builders ...*SyncOperationCreate) *SyncOperationCreateBulk {
	return &SyncOperationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SyncOperationClient) MapCreateBulk(slice any, setFunc func(*SyncOperationCreate, int)) *SyncOperationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SyncOperationCreateBulk{err: fmt.Errorf("calling to SyncOperationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SyncOperationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SyncOperationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SyncOperation.
func (c *SyncOperationClient) Update() *SyncOperationUpdate {
	mutation := newSyncOperationMutation(c.config, OpUpdate)
	return &SyncOperationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SyncOperationClient) UpdateOne(so *SyncOperation) *SyncOperationUpdateOne {
	mutation := newSyncOperationMutation(c.config, OpUpdateOne, withSyncOperation(so))
	return &SyncOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SyncOperationClient) UpdateOneID(id string) *SyncOperationUpdateOne {
	mutation := newSyncOperationMutation(c.config, OpUpdateOne, withSyncOperationID(id))
	return &SyncOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SyncOperation.
func (c *SyncOperationClient) Delete() *SyncOperationDelete {
	mutation := newSyncOperationMutation(c.config, OpDelete)
	return &SyncOperationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SyncOperationClient) DeleteOne(so *SyncOperation) *SyncOperationDeleteOne {
	return c.DeleteOneID(so.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SyncOperationClient) DeleteOneID(id string) *SyncOperationDeleteOne {
	builder := c.Delete().Where(syncoperation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SyncOperationDeleteOne{builder}
}

// Query returns a query builder for SyncOperation.
func (c *SyncOperationClient) Query() *SyncOperationQuery {
	return &SyncOperationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSyncOperation},
		inters: c.Interceptors(),
	}
}

// Get returns a SyncOperation entity by its id.
func (c *SyncOperationClient) Get(ctx context.Context, id string) (*SyncOperation, error) {
	return c.Query().Where(syncoperation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SyncOperationClient) GetX(ctx context.Context, id string) *SyncOperation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SyncOperationClient) Hooks() []Hook {
	return c.hooks.SyncOperation
}

// Interceptors returns the client interceptors.
func (c *SyncOperationClient) Interceptors() []Interceptor {
	return c.inters.SyncOperation
}

func (c *SyncOperationClient) mutate(ctx context.Context, m *SyncOperationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SyncOperationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SyncOperationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SyncOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SyncOperationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SyncOperation mutation op: %q", m.Op())
	}
}

// ToolClient is a client for the Tool schema.
type ToolClient struct {
	config
}

// NewToolClient returns a client for the Tool from the given config.
func NewToolClient(c config) *ToolClient {
	return &ToolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tool.Hooks(f(g(h())))`.
func (c *ToolClient) Use(hooks ...Hook) {
	c.hooks.Tool = append(c.hooks.Tool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tool.Intercept(f(g(h())))`.
func (c *ToolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tool = append(c.inters.Tool, interceptors...)
}

// Create returns a builder for creating a Tool entity.
func (c *ToolClient) Create() *ToolCreate {
	mutation := newToolMutation(c.config, OpCreate)
	return &ToolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tool entities.
func (c *ToolClient) CreateBulk(builders ...*ToolCreate) *ToolCreateBulk {
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolClient) MapCreateBulk(slice any, setFunc func(*ToolCreate, int)) *ToolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolCreateBulk{err: fmt.Errorf("calling to ToolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tool.
func (c *ToolClient) Update() *ToolUpdate {
	mutation := newToolMutation(c.config, OpUpdate)
	return &ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolClient) UpdateOne(t *Tool) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withTool(t))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolClient) UpdateOneID(id string) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withToolID(id))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tool.
func (c *ToolClient) Delete() *ToolDelete {
	mutation := newToolMutation(c.config, OpDelete)
	return &ToolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolClient) DeleteOne(t *Tool) *ToolDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolClient) DeleteOneID(id string) *ToolDeleteOne {
	builder := c.Delete().Where(tool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolDeleteOne{builder}
}

// Query returns a query builder for Tool.
func (c *ToolClient) Query() *ToolQuery {
	return &ToolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTool},
		inters: c.Interceptors(),
	}
}

// Get returns a Tool entity by its id.
func (c *ToolClient) Get(ctx context.Context, id string) (*Tool, error) {
	return c.Query().Where(tool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolClient) GetX(ctx context.Context, id string) *Tool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a Tool.
func (c *ToolClient) QueryRepository(t *Tool) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tool.Table, tool.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tool.RepositoryTable, tool.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Tool.
func (c *ToolClient) QueryDependencies(t *Tool) *ToolDependencyQuery {
	query := (&ToolDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tool.Table, tool.FieldID, id),
			sqlgraph.To(tooldependency.Table, tooldependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tool.DependenciesTable, tool.DependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolClient) Hooks() []Hook {
	return c.hooks.Tool
}

// Interceptors returns the client interceptors.
func (c *ToolClient) Interceptors() []Interceptor {
	return c.inters.Tool
}

func (c *ToolClient) mutate(ctx context.Context, m *ToolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tool mutation op: %q", m.Op())
	}
}

// ToolDependencyClient is a client for the ToolDependency schema.
type ToolDependencyClient struct {
	config
}

// NewToolDependencyClient returns a client for the ToolDependency from the given config.
func NewToolDependencyClient(c config) *ToolDependencyClient {
	return &ToolDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tooldependency.Hooks(f(g(h())))`.
func (c *ToolDependencyClient) Use(hooks ...Hook) {
	c.hooks.ToolDependency = append(c.hooks.ToolDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tooldependency.Intercept(f(g(h())))`.
func (c *ToolDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ToolDependency = append(c.inters.ToolDependency, interceptors...)
}

// Create returns a builder for creating a ToolDependency entity.
func (c *ToolDependencyClient) Create() *ToolDependencyCreate {
	mutation := newToolDependencyMutation(c.config, OpCreate)
	return &ToolDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ToolDependency entities.
func (c *ToolDependencyClient) CreateBulk(builders ...*ToolDependencyCreate) *ToolDependencyCreateBulk {
	return &ToolDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolDependencyClient) MapCreateBulk(slice any, setFunc func(*ToolDependencyCreate, int)) *ToolDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolDependencyCreateBulk{err: fmt.Errorf("calling to ToolDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ToolDependency.
func (c *ToolDependencyClient) Update() *ToolDependencyUpdate {
	mutation := newToolDependencyMutation(c.config, OpUpdate)
	return &ToolDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolDependencyClient) UpdateOne(td *ToolDependency) *ToolDependencyUpdateOne {
	mutation := newToolDependencyMutation(c.config, OpUpdateOne, withToolDependency(td))
	return &ToolDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolDependencyClient) UpdateOneID(id string) *ToolDependencyUpdateOne {
	mutation := newToolDependencyMutation(c.config, OpUpdateOne, withToolDependencyID(id))
	return &ToolDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ToolDependency.
func (c *ToolDependencyClient) Delete() *ToolDependencyDelete {
	mutation := newToolDependencyMutation(c.config, OpDelete)
	return &ToolDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolDependencyClient) DeleteOne(td *ToolDependency) *ToolDependencyDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolDependencyClient) DeleteOneID(id string) *ToolDependencyDeleteOne {
	builder := c.Delete().Where(tooldependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolDependencyDeleteOne{builder}
}

// Query returns a query builder for ToolDependency.
func (c *ToolDependencyClient) Query() *ToolDependencyQuery {
	return &ToolDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToolDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a ToolDependency entity by its id.
func (c *ToolDependencyClient) Get(ctx context.Context, id string) (*ToolDependency, error) {
	return c.Query().Where(tooldependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolDependencyClient) GetX(ctx context.Context, id string) *ToolDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTool queries the tool edge of a ToolDependency.
func (c *ToolDependencyClient) QueryTool(td *ToolDependency) *ToolQuery {
	query := (&ToolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tooldependency.Table, tooldependency.FieldID, id),
			sqlgraph.To(tool.Table, tool.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tooldependency.ToolTable, tooldependency.ToolColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolDependencyClient) Hooks() []Hook {
	return c.hooks.ToolDependency
}

// Interceptors returns the client interceptors.
func (c *ToolDependencyClient) Interceptors() []Interceptor {
	return c.inters.ToolDependency
}

func (c *ToolDependencyClient) mutate(ctx context.Context, m *ToolDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ToolDependency mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Agent, AgentDependency, Component, ComponentDependency, Fork, LocalConfig,
		Prompt, PromptDependency, Repository, SyncOperation, Tool,
		ToolDependency []ent.Hook
	}
	inters struct {
		Agent, AgentDependency, Component, ComponentDependency, Fork, LocalConfig,
		Prompt, PromptDependency, Repository, SyncOperation, Tool,
		ToolDependency []ent.Interceptor
	}
)
