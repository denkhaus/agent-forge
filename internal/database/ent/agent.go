// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/denkhaus/agentforge/internal/database/ent/agent"
	"github.com/denkhaus/agentforge/internal/database/ent/repository"
)

// Agent is the model entity for the Agent schema.
type Agent struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Namespace holds the value of the "namespace" field.
	Namespace string `json:"namespace,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Author holds the value of the "author" field.
	Author string `json:"author,omitempty"`
	// License holds the value of the "license" field.
	License string `json:"license,omitempty"`
	// Homepage holds the value of the "homepage" field.
	Homepage *string `json:"homepage,omitempty"`
	// Documentation holds the value of the "documentation" field.
	Documentation *string `json:"documentation,omitempty"`
	// Tags holds the value of the "tags" field.
	Tags []string `json:"tags,omitempty"`
	// Categories holds the value of the "categories" field.
	Categories []string `json:"categories,omitempty"`
	// Keywords holds the value of the "keywords" field.
	Keywords []string `json:"keywords,omitempty"`
	// Stability holds the value of the "stability" field.
	Stability agent.Stability `json:"stability,omitempty"`
	// Maturity holds the value of the "maturity" field.
	Maturity agent.Maturity `json:"maturity,omitempty"`
	// ForgeVersion holds the value of the "forge_version" field.
	ForgeVersion string `json:"forge_version,omitempty"`
	// Platforms holds the value of the "platforms" field.
	Platforms []string `json:"platforms,omitempty"`
	// Spec holds the value of the "spec" field.
	Spec string `json:"spec,omitempty"`
	// SpecHash holds the value of the "spec_hash" field.
	SpecHash string `json:"spec_hash,omitempty"`
	// IsInstalled holds the value of the "is_installed" field.
	IsInstalled bool `json:"is_installed,omitempty"`
	// InstallPath holds the value of the "install_path" field.
	InstallPath *string `json:"install_path,omitempty"`
	// InstalledAt holds the value of the "installed_at" field.
	InstalledAt *time.Time `json:"installed_at,omitempty"`
	// CommitHash holds the value of the "commit_hash" field.
	CommitHash string `json:"commit_hash,omitempty"`
	// Branch holds the value of the "branch" field.
	Branch string `json:"branch,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// ConfigPath holds the value of the "config_path" field.
	ConfigPath *string `json:"config_path,omitempty"`
	// AgentConfig holds the value of the "agent_config" field.
	AgentConfig map[string]interface{} `json:"agent_config,omitempty"`
	// LlmProvider holds the value of the "llm_provider" field.
	LlmProvider *string `json:"llm_provider,omitempty"`
	// SystemPromptID holds the value of the "system_prompt_id" field.
	SystemPromptID *string `json:"system_prompt_id,omitempty"`
	// ToolDependencies holds the value of the "tool_dependencies" field.
	ToolDependencies []string `json:"tool_dependencies,omitempty"`
	// PromptDependencies holds the value of the "prompt_dependencies" field.
	PromptDependencies []string `json:"prompt_dependencies,omitempty"`
	// AgentDependencies holds the value of the "agent_dependencies" field.
	AgentDependencies []string `json:"agent_dependencies,omitempty"`
	// AgentType holds the value of the "agent_type" field.
	AgentType agent.AgentType `json:"agent_type,omitempty"`
	// Capabilities holds the value of the "capabilities" field.
	Capabilities []string `json:"capabilities,omitempty"`
	// SupportedLanguages holds the value of the "supported_languages" field.
	SupportedLanguages []string `json:"supported_languages,omitempty"`
	// SupportsMemory holds the value of the "supports_memory" field.
	SupportsMemory bool `json:"supports_memory,omitempty"`
	// SupportsTools holds the value of the "supports_tools" field.
	SupportsTools bool `json:"supports_tools,omitempty"`
	// SupportsMultimodal holds the value of the "supports_multimodal" field.
	SupportsMultimodal bool `json:"supports_multimodal,omitempty"`
	// ModelPreferences holds the value of the "model_preferences" field.
	ModelPreferences []string `json:"model_preferences,omitempty"`
	// DefaultTemperature holds the value of the "default_temperature" field.
	DefaultTemperature *float64 `json:"default_temperature,omitempty"`
	// DefaultMaxTokens holds the value of the "default_max_tokens" field.
	DefaultMaxTokens *int `json:"default_max_tokens,omitempty"`
	// SessionTimeoutMinutes holds the value of the "session_timeout_minutes" field.
	SessionTimeoutMinutes int `json:"session_timeout_minutes,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AgentQuery when eager-loading is set.
	Edges             AgentEdges `json:"edges"`
	repository_agents *string
	selectValues      sql.SelectValues
}

// AgentEdges holds the relations/edges for other nodes in the graph.
type AgentEdges struct {
	// Repository holds the value of the repository edge.
	Repository *Repository `json:"repository,omitempty"`
	// Dependencies holds the value of the dependencies edge.
	Dependencies []*AgentDependency `json:"dependencies,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// RepositoryOrErr returns the Repository value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AgentEdges) RepositoryOrErr() (*Repository, error) {
	if e.Repository != nil {
		return e.Repository, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: repository.Label}
	}
	return nil, &NotLoadedError{edge: "repository"}
}

// DependenciesOrErr returns the Dependencies value or an error if the edge
// was not loaded in eager-loading.
func (e AgentEdges) DependenciesOrErr() ([]*AgentDependency, error) {
	if e.loadedTypes[1] {
		return e.Dependencies, nil
	}
	return nil, &NotLoadedError{edge: "dependencies"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Agent) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case agent.FieldTags, agent.FieldCategories, agent.FieldKeywords, agent.FieldPlatforms, agent.FieldAgentConfig, agent.FieldToolDependencies, agent.FieldPromptDependencies, agent.FieldAgentDependencies, agent.FieldCapabilities, agent.FieldSupportedLanguages, agent.FieldModelPreferences:
			values[i] = new([]byte)
		case agent.FieldIsInstalled, agent.FieldSupportsMemory, agent.FieldSupportsTools, agent.FieldSupportsMultimodal:
			values[i] = new(sql.NullBool)
		case agent.FieldDefaultTemperature:
			values[i] = new(sql.NullFloat64)
		case agent.FieldDefaultMaxTokens, agent.FieldSessionTimeoutMinutes:
			values[i] = new(sql.NullInt64)
		case agent.FieldID, agent.FieldName, agent.FieldNamespace, agent.FieldVersion, agent.FieldDescription, agent.FieldAuthor, agent.FieldLicense, agent.FieldHomepage, agent.FieldDocumentation, agent.FieldStability, agent.FieldMaturity, agent.FieldForgeVersion, agent.FieldSpec, agent.FieldSpecHash, agent.FieldInstallPath, agent.FieldCommitHash, agent.FieldBranch, agent.FieldConfigPath, agent.FieldLlmProvider, agent.FieldSystemPromptID, agent.FieldAgentType:
			values[i] = new(sql.NullString)
		case agent.FieldInstalledAt, agent.FieldCreatedAt, agent.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case agent.ForeignKeys[0]: // repository_agents
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Agent fields.
func (a *Agent) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case agent.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				a.ID = value.String
			}
		case agent.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				a.Name = value.String
			}
		case agent.FieldNamespace:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field namespace", values[i])
			} else if value.Valid {
				a.Namespace = value.String
			}
		case agent.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				a.Version = value.String
			}
		case agent.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				a.Description = value.String
			}
		case agent.FieldAuthor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field author", values[i])
			} else if value.Valid {
				a.Author = value.String
			}
		case agent.FieldLicense:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field license", values[i])
			} else if value.Valid {
				a.License = value.String
			}
		case agent.FieldHomepage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field homepage", values[i])
			} else if value.Valid {
				a.Homepage = new(string)
				*a.Homepage = value.String
			}
		case agent.FieldDocumentation:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field documentation", values[i])
			} else if value.Valid {
				a.Documentation = new(string)
				*a.Documentation = value.String
			}
		case agent.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case agent.FieldCategories:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field categories", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.Categories); err != nil {
					return fmt.Errorf("unmarshal field categories: %w", err)
				}
			}
		case agent.FieldKeywords:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field keywords", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.Keywords); err != nil {
					return fmt.Errorf("unmarshal field keywords: %w", err)
				}
			}
		case agent.FieldStability:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field stability", values[i])
			} else if value.Valid {
				a.Stability = agent.Stability(value.String)
			}
		case agent.FieldMaturity:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field maturity", values[i])
			} else if value.Valid {
				a.Maturity = agent.Maturity(value.String)
			}
		case agent.FieldForgeVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field forge_version", values[i])
			} else if value.Valid {
				a.ForgeVersion = value.String
			}
		case agent.FieldPlatforms:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field platforms", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.Platforms); err != nil {
					return fmt.Errorf("unmarshal field platforms: %w", err)
				}
			}
		case agent.FieldSpec:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec", values[i])
			} else if value.Valid {
				a.Spec = value.String
			}
		case agent.FieldSpecHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec_hash", values[i])
			} else if value.Valid {
				a.SpecHash = value.String
			}
		case agent.FieldIsInstalled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_installed", values[i])
			} else if value.Valid {
				a.IsInstalled = value.Bool
			}
		case agent.FieldInstallPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field install_path", values[i])
			} else if value.Valid {
				a.InstallPath = new(string)
				*a.InstallPath = value.String
			}
		case agent.FieldInstalledAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field installed_at", values[i])
			} else if value.Valid {
				a.InstalledAt = new(time.Time)
				*a.InstalledAt = value.Time
			}
		case agent.FieldCommitHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field commit_hash", values[i])
			} else if value.Valid {
				a.CommitHash = value.String
			}
		case agent.FieldBranch:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field branch", values[i])
			} else if value.Valid {
				a.Branch = value.String
			}
		case agent.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				a.CreatedAt = value.Time
			}
		case agent.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				a.UpdatedAt = value.Time
			}
		case agent.FieldConfigPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field config_path", values[i])
			} else if value.Valid {
				a.ConfigPath = new(string)
				*a.ConfigPath = value.String
			}
		case agent.FieldAgentConfig:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field agent_config", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.AgentConfig); err != nil {
					return fmt.Errorf("unmarshal field agent_config: %w", err)
				}
			}
		case agent.FieldLlmProvider:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field llm_provider", values[i])
			} else if value.Valid {
				a.LlmProvider = new(string)
				*a.LlmProvider = value.String
			}
		case agent.FieldSystemPromptID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field system_prompt_id", values[i])
			} else if value.Valid {
				a.SystemPromptID = new(string)
				*a.SystemPromptID = value.String
			}
		case agent.FieldToolDependencies:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tool_dependencies", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.ToolDependencies); err != nil {
					return fmt.Errorf("unmarshal field tool_dependencies: %w", err)
				}
			}
		case agent.FieldPromptDependencies:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field prompt_dependencies", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.PromptDependencies); err != nil {
					return fmt.Errorf("unmarshal field prompt_dependencies: %w", err)
				}
			}
		case agent.FieldAgentDependencies:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field agent_dependencies", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.AgentDependencies); err != nil {
					return fmt.Errorf("unmarshal field agent_dependencies: %w", err)
				}
			}
		case agent.FieldAgentType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field agent_type", values[i])
			} else if value.Valid {
				a.AgentType = agent.AgentType(value.String)
			}
		case agent.FieldCapabilities:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field capabilities", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.Capabilities); err != nil {
					return fmt.Errorf("unmarshal field capabilities: %w", err)
				}
			}
		case agent.FieldSupportedLanguages:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field supported_languages", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.SupportedLanguages); err != nil {
					return fmt.Errorf("unmarshal field supported_languages: %w", err)
				}
			}
		case agent.FieldSupportsMemory:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field supports_memory", values[i])
			} else if value.Valid {
				a.SupportsMemory = value.Bool
			}
		case agent.FieldSupportsTools:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field supports_tools", values[i])
			} else if value.Valid {
				a.SupportsTools = value.Bool
			}
		case agent.FieldSupportsMultimodal:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field supports_multimodal", values[i])
			} else if value.Valid {
				a.SupportsMultimodal = value.Bool
			}
		case agent.FieldModelPreferences:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field model_preferences", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &a.ModelPreferences); err != nil {
					return fmt.Errorf("unmarshal field model_preferences: %w", err)
				}
			}
		case agent.FieldDefaultTemperature:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field default_temperature", values[i])
			} else if value.Valid {
				a.DefaultTemperature = new(float64)
				*a.DefaultTemperature = value.Float64
			}
		case agent.FieldDefaultMaxTokens:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field default_max_tokens", values[i])
			} else if value.Valid {
				a.DefaultMaxTokens = new(int)
				*a.DefaultMaxTokens = int(value.Int64)
			}
		case agent.FieldSessionTimeoutMinutes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field session_timeout_minutes", values[i])
			} else if value.Valid {
				a.SessionTimeoutMinutes = int(value.Int64)
			}
		case agent.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field repository_agents", values[i])
			} else if value.Valid {
				a.repository_agents = new(string)
				*a.repository_agents = value.String
			}
		default:
			a.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Agent.
// This includes values selected through modifiers, order, etc.
func (a *Agent) Value(name string) (ent.Value, error) {
	return a.selectValues.Get(name)
}

// QueryRepository queries the "repository" edge of the Agent entity.
func (a *Agent) QueryRepository() *RepositoryQuery {
	return NewAgentClient(a.config).QueryRepository(a)
}

// QueryDependencies queries the "dependencies" edge of the Agent entity.
func (a *Agent) QueryDependencies() *AgentDependencyQuery {
	return NewAgentClient(a.config).QueryDependencies(a)
}

// Update returns a builder for updating this Agent.
// Note that you need to call Agent.Unwrap() before calling this method if this Agent
// was returned from a transaction, and the transaction was committed or rolled back.
func (a *Agent) Update() *AgentUpdateOne {
	return NewAgentClient(a.config).UpdateOne(a)
}

// Unwrap unwraps the Agent entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (a *Agent) Unwrap() *Agent {
	_tx, ok := a.config.driver.(*txDriver)
	if !ok {
		panic("ent: Agent is not a transactional entity")
	}
	a.config.driver = _tx.drv
	return a
}

// String implements the fmt.Stringer.
func (a *Agent) String() string {
	var builder strings.Builder
	builder.WriteString("Agent(")
	builder.WriteString(fmt.Sprintf("id=%v, ", a.ID))
	builder.WriteString("name=")
	builder.WriteString(a.Name)
	builder.WriteString(", ")
	builder.WriteString("namespace=")
	builder.WriteString(a.Namespace)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(a.Version)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(a.Description)
	builder.WriteString(", ")
	builder.WriteString("author=")
	builder.WriteString(a.Author)
	builder.WriteString(", ")
	builder.WriteString("license=")
	builder.WriteString(a.License)
	builder.WriteString(", ")
	if v := a.Homepage; v != nil {
		builder.WriteString("homepage=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := a.Documentation; v != nil {
		builder.WriteString("documentation=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", a.Tags))
	builder.WriteString(", ")
	builder.WriteString("categories=")
	builder.WriteString(fmt.Sprintf("%v", a.Categories))
	builder.WriteString(", ")
	builder.WriteString("keywords=")
	builder.WriteString(fmt.Sprintf("%v", a.Keywords))
	builder.WriteString(", ")
	builder.WriteString("stability=")
	builder.WriteString(fmt.Sprintf("%v", a.Stability))
	builder.WriteString(", ")
	builder.WriteString("maturity=")
	builder.WriteString(fmt.Sprintf("%v", a.Maturity))
	builder.WriteString(", ")
	builder.WriteString("forge_version=")
	builder.WriteString(a.ForgeVersion)
	builder.WriteString(", ")
	builder.WriteString("platforms=")
	builder.WriteString(fmt.Sprintf("%v", a.Platforms))
	builder.WriteString(", ")
	builder.WriteString("spec=")
	builder.WriteString(a.Spec)
	builder.WriteString(", ")
	builder.WriteString("spec_hash=")
	builder.WriteString(a.SpecHash)
	builder.WriteString(", ")
	builder.WriteString("is_installed=")
	builder.WriteString(fmt.Sprintf("%v", a.IsInstalled))
	builder.WriteString(", ")
	if v := a.InstallPath; v != nil {
		builder.WriteString("install_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := a.InstalledAt; v != nil {
		builder.WriteString("installed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("commit_hash=")
	builder.WriteString(a.CommitHash)
	builder.WriteString(", ")
	builder.WriteString("branch=")
	builder.WriteString(a.Branch)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(a.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(a.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := a.ConfigPath; v != nil {
		builder.WriteString("config_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("agent_config=")
	builder.WriteString(fmt.Sprintf("%v", a.AgentConfig))
	builder.WriteString(", ")
	if v := a.LlmProvider; v != nil {
		builder.WriteString("llm_provider=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := a.SystemPromptID; v != nil {
		builder.WriteString("system_prompt_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("tool_dependencies=")
	builder.WriteString(fmt.Sprintf("%v", a.ToolDependencies))
	builder.WriteString(", ")
	builder.WriteString("prompt_dependencies=")
	builder.WriteString(fmt.Sprintf("%v", a.PromptDependencies))
	builder.WriteString(", ")
	builder.WriteString("agent_dependencies=")
	builder.WriteString(fmt.Sprintf("%v", a.AgentDependencies))
	builder.WriteString(", ")
	builder.WriteString("agent_type=")
	builder.WriteString(fmt.Sprintf("%v", a.AgentType))
	builder.WriteString(", ")
	builder.WriteString("capabilities=")
	builder.WriteString(fmt.Sprintf("%v", a.Capabilities))
	builder.WriteString(", ")
	builder.WriteString("supported_languages=")
	builder.WriteString(fmt.Sprintf("%v", a.SupportedLanguages))
	builder.WriteString(", ")
	builder.WriteString("supports_memory=")
	builder.WriteString(fmt.Sprintf("%v", a.SupportsMemory))
	builder.WriteString(", ")
	builder.WriteString("supports_tools=")
	builder.WriteString(fmt.Sprintf("%v", a.SupportsTools))
	builder.WriteString(", ")
	builder.WriteString("supports_multimodal=")
	builder.WriteString(fmt.Sprintf("%v", a.SupportsMultimodal))
	builder.WriteString(", ")
	builder.WriteString("model_preferences=")
	builder.WriteString(fmt.Sprintf("%v", a.ModelPreferences))
	builder.WriteString(", ")
	if v := a.DefaultTemperature; v != nil {
		builder.WriteString("default_temperature=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := a.DefaultMaxTokens; v != nil {
		builder.WriteString("default_max_tokens=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("session_timeout_minutes=")
	builder.WriteString(fmt.Sprintf("%v", a.SessionTimeoutMinutes))
	builder.WriteByte(')')
	return builder.String()
}

// Agents is a parsable slice of Agent.
type Agents []*Agent
