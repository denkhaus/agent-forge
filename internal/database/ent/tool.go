// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/denkhaus/agentforge/internal/database/ent/repository"
	"github.com/denkhaus/agentforge/internal/database/ent/tool"
)

// Tool is the model entity for the Tool schema.
type Tool struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Namespace holds the value of the "namespace" field.
	Namespace string `json:"namespace,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Author holds the value of the "author" field.
	Author string `json:"author,omitempty"`
	// License holds the value of the "license" field.
	License string `json:"license,omitempty"`
	// Homepage holds the value of the "homepage" field.
	Homepage *string `json:"homepage,omitempty"`
	// Documentation holds the value of the "documentation" field.
	Documentation *string `json:"documentation,omitempty"`
	// Tags holds the value of the "tags" field.
	Tags []string `json:"tags,omitempty"`
	// Categories holds the value of the "categories" field.
	Categories []string `json:"categories,omitempty"`
	// Keywords holds the value of the "keywords" field.
	Keywords []string `json:"keywords,omitempty"`
	// Stability holds the value of the "stability" field.
	Stability tool.Stability `json:"stability,omitempty"`
	// Maturity holds the value of the "maturity" field.
	Maturity tool.Maturity `json:"maturity,omitempty"`
	// ForgeVersion holds the value of the "forge_version" field.
	ForgeVersion string `json:"forge_version,omitempty"`
	// Platforms holds the value of the "platforms" field.
	Platforms []string `json:"platforms,omitempty"`
	// Spec holds the value of the "spec" field.
	Spec string `json:"spec,omitempty"`
	// SpecHash holds the value of the "spec_hash" field.
	SpecHash string `json:"spec_hash,omitempty"`
	// IsInstalled holds the value of the "is_installed" field.
	IsInstalled bool `json:"is_installed,omitempty"`
	// InstallPath holds the value of the "install_path" field.
	InstallPath *string `json:"install_path,omitempty"`
	// InstalledAt holds the value of the "installed_at" field.
	InstalledAt *time.Time `json:"installed_at,omitempty"`
	// CommitHash holds the value of the "commit_hash" field.
	CommitHash string `json:"commit_hash,omitempty"`
	// Branch holds the value of the "branch" field.
	Branch string `json:"branch,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// ExecutionType holds the value of the "execution_type" field.
	ExecutionType tool.ExecutionType `json:"execution_type,omitempty"`
	// SchemaPath holds the value of the "schema_path" field.
	SchemaPath *string `json:"schema_path,omitempty"`
	// ServerConfig holds the value of the "server_config" field.
	ServerConfig map[string]interface{} `json:"server_config,omitempty"`
	// Capabilities holds the value of the "capabilities" field.
	Capabilities []string `json:"capabilities,omitempty"`
	// EntryPoint holds the value of the "entry_point" field.
	EntryPoint *string `json:"entry_point,omitempty"`
	// EnvironmentVariables holds the value of the "environment_variables" field.
	EnvironmentVariables map[string]string `json:"environment_variables,omitempty"`
	// RequiredPermissions holds the value of the "required_permissions" field.
	RequiredPermissions []string `json:"required_permissions,omitempty"`
	// TimeoutSeconds holds the value of the "timeout_seconds" field.
	TimeoutSeconds int `json:"timeout_seconds,omitempty"`
	// SupportsStreaming holds the value of the "supports_streaming" field.
	SupportsStreaming bool `json:"supports_streaming,omitempty"`
	// InputSchema holds the value of the "input_schema" field.
	InputSchema map[string]interface{} `json:"input_schema,omitempty"`
	// OutputSchema holds the value of the "output_schema" field.
	OutputSchema map[string]interface{} `json:"output_schema,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ToolQuery when eager-loading is set.
	Edges            ToolEdges `json:"edges"`
	repository_tools *string
	selectValues     sql.SelectValues
}

// ToolEdges holds the relations/edges for other nodes in the graph.
type ToolEdges struct {
	// Repository holds the value of the repository edge.
	Repository *Repository `json:"repository,omitempty"`
	// Dependencies holds the value of the dependencies edge.
	Dependencies []*ToolDependency `json:"dependencies,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// RepositoryOrErr returns the Repository value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ToolEdges) RepositoryOrErr() (*Repository, error) {
	if e.Repository != nil {
		return e.Repository, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: repository.Label}
	}
	return nil, &NotLoadedError{edge: "repository"}
}

// DependenciesOrErr returns the Dependencies value or an error if the edge
// was not loaded in eager-loading.
func (e ToolEdges) DependenciesOrErr() ([]*ToolDependency, error) {
	if e.loadedTypes[1] {
		return e.Dependencies, nil
	}
	return nil, &NotLoadedError{edge: "dependencies"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Tool) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case tool.FieldTags, tool.FieldCategories, tool.FieldKeywords, tool.FieldPlatforms, tool.FieldServerConfig, tool.FieldCapabilities, tool.FieldEnvironmentVariables, tool.FieldRequiredPermissions, tool.FieldInputSchema, tool.FieldOutputSchema:
			values[i] = new([]byte)
		case tool.FieldIsInstalled, tool.FieldSupportsStreaming:
			values[i] = new(sql.NullBool)
		case tool.FieldTimeoutSeconds:
			values[i] = new(sql.NullInt64)
		case tool.FieldID, tool.FieldName, tool.FieldNamespace, tool.FieldVersion, tool.FieldDescription, tool.FieldAuthor, tool.FieldLicense, tool.FieldHomepage, tool.FieldDocumentation, tool.FieldStability, tool.FieldMaturity, tool.FieldForgeVersion, tool.FieldSpec, tool.FieldSpecHash, tool.FieldInstallPath, tool.FieldCommitHash, tool.FieldBranch, tool.FieldExecutionType, tool.FieldSchemaPath, tool.FieldEntryPoint:
			values[i] = new(sql.NullString)
		case tool.FieldInstalledAt, tool.FieldCreatedAt, tool.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case tool.ForeignKeys[0]: // repository_tools
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Tool fields.
func (t *Tool) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case tool.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				t.ID = value.String
			}
		case tool.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				t.Name = value.String
			}
		case tool.FieldNamespace:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field namespace", values[i])
			} else if value.Valid {
				t.Namespace = value.String
			}
		case tool.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				t.Version = value.String
			}
		case tool.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				t.Description = value.String
			}
		case tool.FieldAuthor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field author", values[i])
			} else if value.Valid {
				t.Author = value.String
			}
		case tool.FieldLicense:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field license", values[i])
			} else if value.Valid {
				t.License = value.String
			}
		case tool.FieldHomepage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field homepage", values[i])
			} else if value.Valid {
				t.Homepage = new(string)
				*t.Homepage = value.String
			}
		case tool.FieldDocumentation:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field documentation", values[i])
			} else if value.Valid {
				t.Documentation = new(string)
				*t.Documentation = value.String
			}
		case tool.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case tool.FieldCategories:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field categories", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.Categories); err != nil {
					return fmt.Errorf("unmarshal field categories: %w", err)
				}
			}
		case tool.FieldKeywords:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field keywords", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.Keywords); err != nil {
					return fmt.Errorf("unmarshal field keywords: %w", err)
				}
			}
		case tool.FieldStability:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field stability", values[i])
			} else if value.Valid {
				t.Stability = tool.Stability(value.String)
			}
		case tool.FieldMaturity:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field maturity", values[i])
			} else if value.Valid {
				t.Maturity = tool.Maturity(value.String)
			}
		case tool.FieldForgeVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field forge_version", values[i])
			} else if value.Valid {
				t.ForgeVersion = value.String
			}
		case tool.FieldPlatforms:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field platforms", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.Platforms); err != nil {
					return fmt.Errorf("unmarshal field platforms: %w", err)
				}
			}
		case tool.FieldSpec:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec", values[i])
			} else if value.Valid {
				t.Spec = value.String
			}
		case tool.FieldSpecHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec_hash", values[i])
			} else if value.Valid {
				t.SpecHash = value.String
			}
		case tool.FieldIsInstalled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_installed", values[i])
			} else if value.Valid {
				t.IsInstalled = value.Bool
			}
		case tool.FieldInstallPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field install_path", values[i])
			} else if value.Valid {
				t.InstallPath = new(string)
				*t.InstallPath = value.String
			}
		case tool.FieldInstalledAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field installed_at", values[i])
			} else if value.Valid {
				t.InstalledAt = new(time.Time)
				*t.InstalledAt = value.Time
			}
		case tool.FieldCommitHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field commit_hash", values[i])
			} else if value.Valid {
				t.CommitHash = value.String
			}
		case tool.FieldBranch:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field branch", values[i])
			} else if value.Valid {
				t.Branch = value.String
			}
		case tool.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				t.CreatedAt = value.Time
			}
		case tool.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				t.UpdatedAt = value.Time
			}
		case tool.FieldExecutionType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field execution_type", values[i])
			} else if value.Valid {
				t.ExecutionType = tool.ExecutionType(value.String)
			}
		case tool.FieldSchemaPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field schema_path", values[i])
			} else if value.Valid {
				t.SchemaPath = new(string)
				*t.SchemaPath = value.String
			}
		case tool.FieldServerConfig:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field server_config", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.ServerConfig); err != nil {
					return fmt.Errorf("unmarshal field server_config: %w", err)
				}
			}
		case tool.FieldCapabilities:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field capabilities", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.Capabilities); err != nil {
					return fmt.Errorf("unmarshal field capabilities: %w", err)
				}
			}
		case tool.FieldEntryPoint:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field entry_point", values[i])
			} else if value.Valid {
				t.EntryPoint = new(string)
				*t.EntryPoint = value.String
			}
		case tool.FieldEnvironmentVariables:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field environment_variables", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.EnvironmentVariables); err != nil {
					return fmt.Errorf("unmarshal field environment_variables: %w", err)
				}
			}
		case tool.FieldRequiredPermissions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field required_permissions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.RequiredPermissions); err != nil {
					return fmt.Errorf("unmarshal field required_permissions: %w", err)
				}
			}
		case tool.FieldTimeoutSeconds:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field timeout_seconds", values[i])
			} else if value.Valid {
				t.TimeoutSeconds = int(value.Int64)
			}
		case tool.FieldSupportsStreaming:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field supports_streaming", values[i])
			} else if value.Valid {
				t.SupportsStreaming = value.Bool
			}
		case tool.FieldInputSchema:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field input_schema", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.InputSchema); err != nil {
					return fmt.Errorf("unmarshal field input_schema: %w", err)
				}
			}
		case tool.FieldOutputSchema:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field output_schema", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &t.OutputSchema); err != nil {
					return fmt.Errorf("unmarshal field output_schema: %w", err)
				}
			}
		case tool.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field repository_tools", values[i])
			} else if value.Valid {
				t.repository_tools = new(string)
				*t.repository_tools = value.String
			}
		default:
			t.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Tool.
// This includes values selected through modifiers, order, etc.
func (t *Tool) Value(name string) (ent.Value, error) {
	return t.selectValues.Get(name)
}

// QueryRepository queries the "repository" edge of the Tool entity.
func (t *Tool) QueryRepository() *RepositoryQuery {
	return NewToolClient(t.config).QueryRepository(t)
}

// QueryDependencies queries the "dependencies" edge of the Tool entity.
func (t *Tool) QueryDependencies() *ToolDependencyQuery {
	return NewToolClient(t.config).QueryDependencies(t)
}

// Update returns a builder for updating this Tool.
// Note that you need to call Tool.Unwrap() before calling this method if this Tool
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Tool) Update() *ToolUpdateOne {
	return NewToolClient(t.config).UpdateOne(t)
}

// Unwrap unwraps the Tool entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (t *Tool) Unwrap() *Tool {
	_tx, ok := t.config.driver.(*txDriver)
	if !ok {
		panic("ent: Tool is not a transactional entity")
	}
	t.config.driver = _tx.drv
	return t
}

// String implements the fmt.Stringer.
func (t *Tool) String() string {
	var builder strings.Builder
	builder.WriteString("Tool(")
	builder.WriteString(fmt.Sprintf("id=%v, ", t.ID))
	builder.WriteString("name=")
	builder.WriteString(t.Name)
	builder.WriteString(", ")
	builder.WriteString("namespace=")
	builder.WriteString(t.Namespace)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(t.Version)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(t.Description)
	builder.WriteString(", ")
	builder.WriteString("author=")
	builder.WriteString(t.Author)
	builder.WriteString(", ")
	builder.WriteString("license=")
	builder.WriteString(t.License)
	builder.WriteString(", ")
	if v := t.Homepage; v != nil {
		builder.WriteString("homepage=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := t.Documentation; v != nil {
		builder.WriteString("documentation=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", t.Tags))
	builder.WriteString(", ")
	builder.WriteString("categories=")
	builder.WriteString(fmt.Sprintf("%v", t.Categories))
	builder.WriteString(", ")
	builder.WriteString("keywords=")
	builder.WriteString(fmt.Sprintf("%v", t.Keywords))
	builder.WriteString(", ")
	builder.WriteString("stability=")
	builder.WriteString(fmt.Sprintf("%v", t.Stability))
	builder.WriteString(", ")
	builder.WriteString("maturity=")
	builder.WriteString(fmt.Sprintf("%v", t.Maturity))
	builder.WriteString(", ")
	builder.WriteString("forge_version=")
	builder.WriteString(t.ForgeVersion)
	builder.WriteString(", ")
	builder.WriteString("platforms=")
	builder.WriteString(fmt.Sprintf("%v", t.Platforms))
	builder.WriteString(", ")
	builder.WriteString("spec=")
	builder.WriteString(t.Spec)
	builder.WriteString(", ")
	builder.WriteString("spec_hash=")
	builder.WriteString(t.SpecHash)
	builder.WriteString(", ")
	builder.WriteString("is_installed=")
	builder.WriteString(fmt.Sprintf("%v", t.IsInstalled))
	builder.WriteString(", ")
	if v := t.InstallPath; v != nil {
		builder.WriteString("install_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := t.InstalledAt; v != nil {
		builder.WriteString("installed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("commit_hash=")
	builder.WriteString(t.CommitHash)
	builder.WriteString(", ")
	builder.WriteString("branch=")
	builder.WriteString(t.Branch)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(t.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(t.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("execution_type=")
	builder.WriteString(fmt.Sprintf("%v", t.ExecutionType))
	builder.WriteString(", ")
	if v := t.SchemaPath; v != nil {
		builder.WriteString("schema_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("server_config=")
	builder.WriteString(fmt.Sprintf("%v", t.ServerConfig))
	builder.WriteString(", ")
	builder.WriteString("capabilities=")
	builder.WriteString(fmt.Sprintf("%v", t.Capabilities))
	builder.WriteString(", ")
	if v := t.EntryPoint; v != nil {
		builder.WriteString("entry_point=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("environment_variables=")
	builder.WriteString(fmt.Sprintf("%v", t.EnvironmentVariables))
	builder.WriteString(", ")
	builder.WriteString("required_permissions=")
	builder.WriteString(fmt.Sprintf("%v", t.RequiredPermissions))
	builder.WriteString(", ")
	builder.WriteString("timeout_seconds=")
	builder.WriteString(fmt.Sprintf("%v", t.TimeoutSeconds))
	builder.WriteString(", ")
	builder.WriteString("supports_streaming=")
	builder.WriteString(fmt.Sprintf("%v", t.SupportsStreaming))
	builder.WriteString(", ")
	builder.WriteString("input_schema=")
	builder.WriteString(fmt.Sprintf("%v", t.InputSchema))
	builder.WriteString(", ")
	builder.WriteString("output_schema=")
	builder.WriteString(fmt.Sprintf("%v", t.OutputSchema))
	builder.WriteByte(')')
	return builder.String()
}

// Tools is a parsable slice of Tool.
type Tools []*Tool
