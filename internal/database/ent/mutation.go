// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/denkhaus/agentforge/internal/database/ent/agent"
	"github.com/denkhaus/agentforge/internal/database/ent/agentdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/component"
	"github.com/denkhaus/agentforge/internal/database/ent/componentdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/fork"
	"github.com/denkhaus/agentforge/internal/database/ent/localconfig"
	"github.com/denkhaus/agentforge/internal/database/ent/predicate"
	"github.com/denkhaus/agentforge/internal/database/ent/prompt"
	"github.com/denkhaus/agentforge/internal/database/ent/promptdependency"
	"github.com/denkhaus/agentforge/internal/database/ent/repository"
	"github.com/denkhaus/agentforge/internal/database/ent/syncoperation"
	"github.com/denkhaus/agentforge/internal/database/ent/tool"
	"github.com/denkhaus/agentforge/internal/database/ent/tooldependency"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent               = "Agent"
	TypeAgentDependency     = "AgentDependency"
	TypeComponent           = "Component"
	TypeComponentDependency = "ComponentDependency"
	TypeFork                = "Fork"
	TypeLocalConfig         = "LocalConfig"
	TypePrompt              = "Prompt"
	TypePromptDependency    = "PromptDependency"
	TypeRepository          = "Repository"
	TypeSyncOperation       = "SyncOperation"
	TypeTool                = "Tool"
	TypeToolDependency      = "ToolDependency"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	namespace                  *string
	version                    *string
	description                *string
	author                     *string
	license                    *string
	homepage                   *string
	documentation              *string
	tags                       *[]string
	appendtags                 []string
	categories                 *[]string
	appendcategories           []string
	keywords                   *[]string
	appendkeywords             []string
	stability                  *agent.Stability
	maturity                   *agent.Maturity
	forge_version              *string
	platforms                  *[]string
	appendplatforms            []string
	spec                       *string
	spec_hash                  *string
	is_installed               *bool
	install_path               *string
	installed_at               *time.Time
	commit_hash                *string
	branch                     *string
	created_at                 *time.Time
	updated_at                 *time.Time
	config_path                *string
	agent_config               *map[string]interface{}
	llm_provider               *string
	system_prompt_id           *string
	tool_dependencies          *[]string
	appendtool_dependencies    []string
	prompt_dependencies        *[]string
	appendprompt_dependencies  []string
	agent_dependencies         *[]string
	appendagent_dependencies   []string
	agent_type                 *agent.AgentType
	capabilities               *[]string
	appendcapabilities         []string
	supported_languages        *[]string
	appendsupported_languages  []string
	supports_memory            *bool
	supports_tools             *bool
	supports_multimodal        *bool
	model_preferences          *[]string
	appendmodel_preferences    []string
	default_temperature        *float64
	adddefault_temperature     *float64
	default_max_tokens         *int
	adddefault_max_tokens      *int
	session_timeout_minutes    *int
	addsession_timeout_minutes *int
	clearedFields              map[string]struct{}
	repository                 *string
	clearedrepository          bool
	dependencies               map[string]struct{}
	removeddependencies        map[string]struct{}
	cleareddependencies        bool
	done                       bool
	oldValue                   func(context.Context) (*Agent, error)
	predicates                 []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id string) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AgentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AgentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AgentMutation) ResetName() {
	m.name = nil
}

// SetNamespace sets the "namespace" field.
func (m *AgentMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AgentMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AgentMutation) ResetNamespace() {
	m.namespace = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *AgentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AgentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AgentMutation) ResetDescription() {
	m.description = nil
}

// SetAuthor sets the "author" field.
func (m *AgentMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *AgentMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *AgentMutation) ResetAuthor() {
	m.author = nil
}

// SetLicense sets the "license" field.
func (m *AgentMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *AgentMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ResetLicense resets all changes to the "license" field.
func (m *AgentMutation) ResetLicense() {
	m.license = nil
}

// SetHomepage sets the "homepage" field.
func (m *AgentMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *AgentMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHomepage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *AgentMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[agent.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *AgentMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[agent.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *AgentMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, agent.FieldHomepage)
}

// SetDocumentation sets the "documentation" field.
func (m *AgentMutation) SetDocumentation(s string) {
	m.documentation = &s
}

// Documentation returns the value of the "documentation" field in the mutation.
func (m *AgentMutation) Documentation() (r string, exists bool) {
	v := m.documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentation returns the old "documentation" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDocumentation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentation: %w", err)
	}
	return oldValue.Documentation, nil
}

// ClearDocumentation clears the value of the "documentation" field.
func (m *AgentMutation) ClearDocumentation() {
	m.documentation = nil
	m.clearedFields[agent.FieldDocumentation] = struct{}{}
}

// DocumentationCleared returns if the "documentation" field was cleared in this mutation.
func (m *AgentMutation) DocumentationCleared() bool {
	_, ok := m.clearedFields[agent.FieldDocumentation]
	return ok
}

// ResetDocumentation resets all changes to the "documentation" field.
func (m *AgentMutation) ResetDocumentation() {
	m.documentation = nil
	delete(m.clearedFields, agent.FieldDocumentation)
}

// SetTags sets the "tags" field.
func (m *AgentMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AgentMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AgentMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AgentMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *AgentMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[agent.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AgentMutation) TagsCleared() bool {
	_, ok := m.clearedFields[agent.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AgentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, agent.FieldTags)
}

// SetCategories sets the "categories" field.
func (m *AgentMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *AgentMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *AgentMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *AgentMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *AgentMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[agent.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *AgentMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[agent.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *AgentMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, agent.FieldCategories)
}

// SetKeywords sets the "keywords" field.
func (m *AgentMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *AgentMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *AgentMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *AgentMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *AgentMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[agent.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *AgentMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[agent.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *AgentMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, agent.FieldKeywords)
}

// SetStability sets the "stability" field.
func (m *AgentMutation) SetStability(a agent.Stability) {
	m.stability = &a
}

// Stability returns the value of the "stability" field in the mutation.
func (m *AgentMutation) Stability() (r agent.Stability, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStability(ctx context.Context) (v agent.Stability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *AgentMutation) ResetStability() {
	m.stability = nil
}

// SetMaturity sets the "maturity" field.
func (m *AgentMutation) SetMaturity(a agent.Maturity) {
	m.maturity = &a
}

// Maturity returns the value of the "maturity" field in the mutation.
func (m *AgentMutation) Maturity() (r agent.Maturity, exists bool) {
	v := m.maturity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturity returns the old "maturity" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMaturity(ctx context.Context) (v agent.Maturity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturity: %w", err)
	}
	return oldValue.Maturity, nil
}

// ResetMaturity resets all changes to the "maturity" field.
func (m *AgentMutation) ResetMaturity() {
	m.maturity = nil
}

// SetForgeVersion sets the "forge_version" field.
func (m *AgentMutation) SetForgeVersion(s string) {
	m.forge_version = &s
}

// ForgeVersion returns the value of the "forge_version" field in the mutation.
func (m *AgentMutation) ForgeVersion() (r string, exists bool) {
	v := m.forge_version
	if v == nil {
		return
	}
	return *v, true
}

// OldForgeVersion returns the old "forge_version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldForgeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgeVersion: %w", err)
	}
	return oldValue.ForgeVersion, nil
}

// ResetForgeVersion resets all changes to the "forge_version" field.
func (m *AgentMutation) ResetForgeVersion() {
	m.forge_version = nil
}

// SetPlatforms sets the "platforms" field.
func (m *AgentMutation) SetPlatforms(s []string) {
	m.platforms = &s
	m.appendplatforms = nil
}

// Platforms returns the value of the "platforms" field in the mutation.
func (m *AgentMutation) Platforms() (r []string, exists bool) {
	v := m.platforms
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatforms returns the old "platforms" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPlatforms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatforms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatforms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatforms: %w", err)
	}
	return oldValue.Platforms, nil
}

// AppendPlatforms adds s to the "platforms" field.
func (m *AgentMutation) AppendPlatforms(s []string) {
	m.appendplatforms = append(m.appendplatforms, s...)
}

// AppendedPlatforms returns the list of values that were appended to the "platforms" field in this mutation.
func (m *AgentMutation) AppendedPlatforms() ([]string, bool) {
	if len(m.appendplatforms) == 0 {
		return nil, false
	}
	return m.appendplatforms, true
}

// ClearPlatforms clears the value of the "platforms" field.
func (m *AgentMutation) ClearPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	m.clearedFields[agent.FieldPlatforms] = struct{}{}
}

// PlatformsCleared returns if the "platforms" field was cleared in this mutation.
func (m *AgentMutation) PlatformsCleared() bool {
	_, ok := m.clearedFields[agent.FieldPlatforms]
	return ok
}

// ResetPlatforms resets all changes to the "platforms" field.
func (m *AgentMutation) ResetPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	delete(m.clearedFields, agent.FieldPlatforms)
}

// SetSpec sets the "spec" field.
func (m *AgentMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *AgentMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *AgentMutation) ResetSpec() {
	m.spec = nil
}

// SetSpecHash sets the "spec_hash" field.
func (m *AgentMutation) SetSpecHash(s string) {
	m.spec_hash = &s
}

// SpecHash returns the value of the "spec_hash" field in the mutation.
func (m *AgentMutation) SpecHash() (r string, exists bool) {
	v := m.spec_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecHash returns the old "spec_hash" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSpecHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecHash: %w", err)
	}
	return oldValue.SpecHash, nil
}

// ResetSpecHash resets all changes to the "spec_hash" field.
func (m *AgentMutation) ResetSpecHash() {
	m.spec_hash = nil
}

// SetIsInstalled sets the "is_installed" field.
func (m *AgentMutation) SetIsInstalled(b bool) {
	m.is_installed = &b
}

// IsInstalled returns the value of the "is_installed" field in the mutation.
func (m *AgentMutation) IsInstalled() (r bool, exists bool) {
	v := m.is_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstalled returns the old "is_installed" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIsInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstalled: %w", err)
	}
	return oldValue.IsInstalled, nil
}

// ResetIsInstalled resets all changes to the "is_installed" field.
func (m *AgentMutation) ResetIsInstalled() {
	m.is_installed = nil
}

// SetInstallPath sets the "install_path" field.
func (m *AgentMutation) SetInstallPath(s string) {
	m.install_path = &s
}

// InstallPath returns the value of the "install_path" field in the mutation.
func (m *AgentMutation) InstallPath() (r string, exists bool) {
	v := m.install_path
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallPath returns the old "install_path" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldInstallPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallPath: %w", err)
	}
	return oldValue.InstallPath, nil
}

// ClearInstallPath clears the value of the "install_path" field.
func (m *AgentMutation) ClearInstallPath() {
	m.install_path = nil
	m.clearedFields[agent.FieldInstallPath] = struct{}{}
}

// InstallPathCleared returns if the "install_path" field was cleared in this mutation.
func (m *AgentMutation) InstallPathCleared() bool {
	_, ok := m.clearedFields[agent.FieldInstallPath]
	return ok
}

// ResetInstallPath resets all changes to the "install_path" field.
func (m *AgentMutation) ResetInstallPath() {
	m.install_path = nil
	delete(m.clearedFields, agent.FieldInstallPath)
}

// SetInstalledAt sets the "installed_at" field.
func (m *AgentMutation) SetInstalledAt(t time.Time) {
	m.installed_at = &t
}

// InstalledAt returns the value of the "installed_at" field in the mutation.
func (m *AgentMutation) InstalledAt() (r time.Time, exists bool) {
	v := m.installed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledAt returns the old "installed_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldInstalledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledAt: %w", err)
	}
	return oldValue.InstalledAt, nil
}

// ClearInstalledAt clears the value of the "installed_at" field.
func (m *AgentMutation) ClearInstalledAt() {
	m.installed_at = nil
	m.clearedFields[agent.FieldInstalledAt] = struct{}{}
}

// InstalledAtCleared returns if the "installed_at" field was cleared in this mutation.
func (m *AgentMutation) InstalledAtCleared() bool {
	_, ok := m.clearedFields[agent.FieldInstalledAt]
	return ok
}

// ResetInstalledAt resets all changes to the "installed_at" field.
func (m *AgentMutation) ResetInstalledAt() {
	m.installed_at = nil
	delete(m.clearedFields, agent.FieldInstalledAt)
}

// SetCommitHash sets the "commit_hash" field.
func (m *AgentMutation) SetCommitHash(s string) {
	m.commit_hash = &s
}

// CommitHash returns the value of the "commit_hash" field in the mutation.
func (m *AgentMutation) CommitHash() (r string, exists bool) {
	v := m.commit_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitHash returns the old "commit_hash" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCommitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitHash: %w", err)
	}
	return oldValue.CommitHash, nil
}

// ResetCommitHash resets all changes to the "commit_hash" field.
func (m *AgentMutation) ResetCommitHash() {
	m.commit_hash = nil
}

// SetBranch sets the "branch" field.
func (m *AgentMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *AgentMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *AgentMutation) ResetBranch() {
	m.branch = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConfigPath sets the "config_path" field.
func (m *AgentMutation) SetConfigPath(s string) {
	m.config_path = &s
}

// ConfigPath returns the value of the "config_path" field in the mutation.
func (m *AgentMutation) ConfigPath() (r string, exists bool) {
	v := m.config_path
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigPath returns the old "config_path" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldConfigPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigPath: %w", err)
	}
	return oldValue.ConfigPath, nil
}

// ClearConfigPath clears the value of the "config_path" field.
func (m *AgentMutation) ClearConfigPath() {
	m.config_path = nil
	m.clearedFields[agent.FieldConfigPath] = struct{}{}
}

// ConfigPathCleared returns if the "config_path" field was cleared in this mutation.
func (m *AgentMutation) ConfigPathCleared() bool {
	_, ok := m.clearedFields[agent.FieldConfigPath]
	return ok
}

// ResetConfigPath resets all changes to the "config_path" field.
func (m *AgentMutation) ResetConfigPath() {
	m.config_path = nil
	delete(m.clearedFields, agent.FieldConfigPath)
}

// SetAgentConfig sets the "agent_config" field.
func (m *AgentMutation) SetAgentConfig(value map[string]interface{}) {
	m.agent_config = &value
}

// AgentConfig returns the value of the "agent_config" field in the mutation.
func (m *AgentMutation) AgentConfig() (r map[string]interface{}, exists bool) {
	v := m.agent_config
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentConfig returns the old "agent_config" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAgentConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentConfig: %w", err)
	}
	return oldValue.AgentConfig, nil
}

// ClearAgentConfig clears the value of the "agent_config" field.
func (m *AgentMutation) ClearAgentConfig() {
	m.agent_config = nil
	m.clearedFields[agent.FieldAgentConfig] = struct{}{}
}

// AgentConfigCleared returns if the "agent_config" field was cleared in this mutation.
func (m *AgentMutation) AgentConfigCleared() bool {
	_, ok := m.clearedFields[agent.FieldAgentConfig]
	return ok
}

// ResetAgentConfig resets all changes to the "agent_config" field.
func (m *AgentMutation) ResetAgentConfig() {
	m.agent_config = nil
	delete(m.clearedFields, agent.FieldAgentConfig)
}

// SetLlmProvider sets the "llm_provider" field.
func (m *AgentMutation) SetLlmProvider(s string) {
	m.llm_provider = &s
}

// LlmProvider returns the value of the "llm_provider" field in the mutation.
func (m *AgentMutation) LlmProvider() (r string, exists bool) {
	v := m.llm_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmProvider returns the old "llm_provider" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLlmProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmProvider: %w", err)
	}
	return oldValue.LlmProvider, nil
}

// ClearLlmProvider clears the value of the "llm_provider" field.
func (m *AgentMutation) ClearLlmProvider() {
	m.llm_provider = nil
	m.clearedFields[agent.FieldLlmProvider] = struct{}{}
}

// LlmProviderCleared returns if the "llm_provider" field was cleared in this mutation.
func (m *AgentMutation) LlmProviderCleared() bool {
	_, ok := m.clearedFields[agent.FieldLlmProvider]
	return ok
}

// ResetLlmProvider resets all changes to the "llm_provider" field.
func (m *AgentMutation) ResetLlmProvider() {
	m.llm_provider = nil
	delete(m.clearedFields, agent.FieldLlmProvider)
}

// SetSystemPromptID sets the "system_prompt_id" field.
func (m *AgentMutation) SetSystemPromptID(s string) {
	m.system_prompt_id = &s
}

// SystemPromptID returns the value of the "system_prompt_id" field in the mutation.
func (m *AgentMutation) SystemPromptID() (r string, exists bool) {
	v := m.system_prompt_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemPromptID returns the old "system_prompt_id" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSystemPromptID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemPromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemPromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemPromptID: %w", err)
	}
	return oldValue.SystemPromptID, nil
}

// ClearSystemPromptID clears the value of the "system_prompt_id" field.
func (m *AgentMutation) ClearSystemPromptID() {
	m.system_prompt_id = nil
	m.clearedFields[agent.FieldSystemPromptID] = struct{}{}
}

// SystemPromptIDCleared returns if the "system_prompt_id" field was cleared in this mutation.
func (m *AgentMutation) SystemPromptIDCleared() bool {
	_, ok := m.clearedFields[agent.FieldSystemPromptID]
	return ok
}

// ResetSystemPromptID resets all changes to the "system_prompt_id" field.
func (m *AgentMutation) ResetSystemPromptID() {
	m.system_prompt_id = nil
	delete(m.clearedFields, agent.FieldSystemPromptID)
}

// SetToolDependencies sets the "tool_dependencies" field.
func (m *AgentMutation) SetToolDependencies(s []string) {
	m.tool_dependencies = &s
	m.appendtool_dependencies = nil
}

// ToolDependencies returns the value of the "tool_dependencies" field in the mutation.
func (m *AgentMutation) ToolDependencies() (r []string, exists bool) {
	v := m.tool_dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldToolDependencies returns the old "tool_dependencies" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldToolDependencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolDependencies: %w", err)
	}
	return oldValue.ToolDependencies, nil
}

// AppendToolDependencies adds s to the "tool_dependencies" field.
func (m *AgentMutation) AppendToolDependencies(s []string) {
	m.appendtool_dependencies = append(m.appendtool_dependencies, s...)
}

// AppendedToolDependencies returns the list of values that were appended to the "tool_dependencies" field in this mutation.
func (m *AgentMutation) AppendedToolDependencies() ([]string, bool) {
	if len(m.appendtool_dependencies) == 0 {
		return nil, false
	}
	return m.appendtool_dependencies, true
}

// ClearToolDependencies clears the value of the "tool_dependencies" field.
func (m *AgentMutation) ClearToolDependencies() {
	m.tool_dependencies = nil
	m.appendtool_dependencies = nil
	m.clearedFields[agent.FieldToolDependencies] = struct{}{}
}

// ToolDependenciesCleared returns if the "tool_dependencies" field was cleared in this mutation.
func (m *AgentMutation) ToolDependenciesCleared() bool {
	_, ok := m.clearedFields[agent.FieldToolDependencies]
	return ok
}

// ResetToolDependencies resets all changes to the "tool_dependencies" field.
func (m *AgentMutation) ResetToolDependencies() {
	m.tool_dependencies = nil
	m.appendtool_dependencies = nil
	delete(m.clearedFields, agent.FieldToolDependencies)
}

// SetPromptDependencies sets the "prompt_dependencies" field.
func (m *AgentMutation) SetPromptDependencies(s []string) {
	m.prompt_dependencies = &s
	m.appendprompt_dependencies = nil
}

// PromptDependencies returns the value of the "prompt_dependencies" field in the mutation.
func (m *AgentMutation) PromptDependencies() (r []string, exists bool) {
	v := m.prompt_dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptDependencies returns the old "prompt_dependencies" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPromptDependencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptDependencies: %w", err)
	}
	return oldValue.PromptDependencies, nil
}

// AppendPromptDependencies adds s to the "prompt_dependencies" field.
func (m *AgentMutation) AppendPromptDependencies(s []string) {
	m.appendprompt_dependencies = append(m.appendprompt_dependencies, s...)
}

// AppendedPromptDependencies returns the list of values that were appended to the "prompt_dependencies" field in this mutation.
func (m *AgentMutation) AppendedPromptDependencies() ([]string, bool) {
	if len(m.appendprompt_dependencies) == 0 {
		return nil, false
	}
	return m.appendprompt_dependencies, true
}

// ClearPromptDependencies clears the value of the "prompt_dependencies" field.
func (m *AgentMutation) ClearPromptDependencies() {
	m.prompt_dependencies = nil
	m.appendprompt_dependencies = nil
	m.clearedFields[agent.FieldPromptDependencies] = struct{}{}
}

// PromptDependenciesCleared returns if the "prompt_dependencies" field was cleared in this mutation.
func (m *AgentMutation) PromptDependenciesCleared() bool {
	_, ok := m.clearedFields[agent.FieldPromptDependencies]
	return ok
}

// ResetPromptDependencies resets all changes to the "prompt_dependencies" field.
func (m *AgentMutation) ResetPromptDependencies() {
	m.prompt_dependencies = nil
	m.appendprompt_dependencies = nil
	delete(m.clearedFields, agent.FieldPromptDependencies)
}

// SetAgentDependencies sets the "agent_dependencies" field.
func (m *AgentMutation) SetAgentDependencies(s []string) {
	m.agent_dependencies = &s
	m.appendagent_dependencies = nil
}

// AgentDependencies returns the value of the "agent_dependencies" field in the mutation.
func (m *AgentMutation) AgentDependencies() (r []string, exists bool) {
	v := m.agent_dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentDependencies returns the old "agent_dependencies" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAgentDependencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentDependencies: %w", err)
	}
	return oldValue.AgentDependencies, nil
}

// AppendAgentDependencies adds s to the "agent_dependencies" field.
func (m *AgentMutation) AppendAgentDependencies(s []string) {
	m.appendagent_dependencies = append(m.appendagent_dependencies, s...)
}

// AppendedAgentDependencies returns the list of values that were appended to the "agent_dependencies" field in this mutation.
func (m *AgentMutation) AppendedAgentDependencies() ([]string, bool) {
	if len(m.appendagent_dependencies) == 0 {
		return nil, false
	}
	return m.appendagent_dependencies, true
}

// ClearAgentDependencies clears the value of the "agent_dependencies" field.
func (m *AgentMutation) ClearAgentDependencies() {
	m.agent_dependencies = nil
	m.appendagent_dependencies = nil
	m.clearedFields[agent.FieldAgentDependencies] = struct{}{}
}

// AgentDependenciesCleared returns if the "agent_dependencies" field was cleared in this mutation.
func (m *AgentMutation) AgentDependenciesCleared() bool {
	_, ok := m.clearedFields[agent.FieldAgentDependencies]
	return ok
}

// ResetAgentDependencies resets all changes to the "agent_dependencies" field.
func (m *AgentMutation) ResetAgentDependencies() {
	m.agent_dependencies = nil
	m.appendagent_dependencies = nil
	delete(m.clearedFields, agent.FieldAgentDependencies)
}

// SetAgentType sets the "agent_type" field.
func (m *AgentMutation) SetAgentType(at agent.AgentType) {
	m.agent_type = &at
}

// AgentType returns the value of the "agent_type" field in the mutation.
func (m *AgentMutation) AgentType() (r agent.AgentType, exists bool) {
	v := m.agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentType returns the old "agent_type" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAgentType(ctx context.Context) (v agent.AgentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentType: %w", err)
	}
	return oldValue.AgentType, nil
}

// ResetAgentType resets all changes to the "agent_type" field.
func (m *AgentMutation) ResetAgentType() {
	m.agent_type = nil
}

// SetCapabilities sets the "capabilities" field.
func (m *AgentMutation) SetCapabilities(s []string) {
	m.capabilities = &s
	m.appendcapabilities = nil
}

// Capabilities returns the value of the "capabilities" field in the mutation.
func (m *AgentMutation) Capabilities() (r []string, exists bool) {
	v := m.capabilities
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilities returns the old "capabilities" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCapabilities(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilities: %w", err)
	}
	return oldValue.Capabilities, nil
}

// AppendCapabilities adds s to the "capabilities" field.
func (m *AgentMutation) AppendCapabilities(s []string) {
	m.appendcapabilities = append(m.appendcapabilities, s...)
}

// AppendedCapabilities returns the list of values that were appended to the "capabilities" field in this mutation.
func (m *AgentMutation) AppendedCapabilities() ([]string, bool) {
	if len(m.appendcapabilities) == 0 {
		return nil, false
	}
	return m.appendcapabilities, true
}

// ClearCapabilities clears the value of the "capabilities" field.
func (m *AgentMutation) ClearCapabilities() {
	m.capabilities = nil
	m.appendcapabilities = nil
	m.clearedFields[agent.FieldCapabilities] = struct{}{}
}

// CapabilitiesCleared returns if the "capabilities" field was cleared in this mutation.
func (m *AgentMutation) CapabilitiesCleared() bool {
	_, ok := m.clearedFields[agent.FieldCapabilities]
	return ok
}

// ResetCapabilities resets all changes to the "capabilities" field.
func (m *AgentMutation) ResetCapabilities() {
	m.capabilities = nil
	m.appendcapabilities = nil
	delete(m.clearedFields, agent.FieldCapabilities)
}

// SetSupportedLanguages sets the "supported_languages" field.
func (m *AgentMutation) SetSupportedLanguages(s []string) {
	m.supported_languages = &s
	m.appendsupported_languages = nil
}

// SupportedLanguages returns the value of the "supported_languages" field in the mutation.
func (m *AgentMutation) SupportedLanguages() (r []string, exists bool) {
	v := m.supported_languages
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedLanguages returns the old "supported_languages" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSupportedLanguages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedLanguages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedLanguages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedLanguages: %w", err)
	}
	return oldValue.SupportedLanguages, nil
}

// AppendSupportedLanguages adds s to the "supported_languages" field.
func (m *AgentMutation) AppendSupportedLanguages(s []string) {
	m.appendsupported_languages = append(m.appendsupported_languages, s...)
}

// AppendedSupportedLanguages returns the list of values that were appended to the "supported_languages" field in this mutation.
func (m *AgentMutation) AppendedSupportedLanguages() ([]string, bool) {
	if len(m.appendsupported_languages) == 0 {
		return nil, false
	}
	return m.appendsupported_languages, true
}

// ClearSupportedLanguages clears the value of the "supported_languages" field.
func (m *AgentMutation) ClearSupportedLanguages() {
	m.supported_languages = nil
	m.appendsupported_languages = nil
	m.clearedFields[agent.FieldSupportedLanguages] = struct{}{}
}

// SupportedLanguagesCleared returns if the "supported_languages" field was cleared in this mutation.
func (m *AgentMutation) SupportedLanguagesCleared() bool {
	_, ok := m.clearedFields[agent.FieldSupportedLanguages]
	return ok
}

// ResetSupportedLanguages resets all changes to the "supported_languages" field.
func (m *AgentMutation) ResetSupportedLanguages() {
	m.supported_languages = nil
	m.appendsupported_languages = nil
	delete(m.clearedFields, agent.FieldSupportedLanguages)
}

// SetSupportsMemory sets the "supports_memory" field.
func (m *AgentMutation) SetSupportsMemory(b bool) {
	m.supports_memory = &b
}

// SupportsMemory returns the value of the "supports_memory" field in the mutation.
func (m *AgentMutation) SupportsMemory() (r bool, exists bool) {
	v := m.supports_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsMemory returns the old "supports_memory" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSupportsMemory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsMemory: %w", err)
	}
	return oldValue.SupportsMemory, nil
}

// ResetSupportsMemory resets all changes to the "supports_memory" field.
func (m *AgentMutation) ResetSupportsMemory() {
	m.supports_memory = nil
}

// SetSupportsTools sets the "supports_tools" field.
func (m *AgentMutation) SetSupportsTools(b bool) {
	m.supports_tools = &b
}

// SupportsTools returns the value of the "supports_tools" field in the mutation.
func (m *AgentMutation) SupportsTools() (r bool, exists bool) {
	v := m.supports_tools
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsTools returns the old "supports_tools" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSupportsTools(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsTools is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsTools requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsTools: %w", err)
	}
	return oldValue.SupportsTools, nil
}

// ResetSupportsTools resets all changes to the "supports_tools" field.
func (m *AgentMutation) ResetSupportsTools() {
	m.supports_tools = nil
}

// SetSupportsMultimodal sets the "supports_multimodal" field.
func (m *AgentMutation) SetSupportsMultimodal(b bool) {
	m.supports_multimodal = &b
}

// SupportsMultimodal returns the value of the "supports_multimodal" field in the mutation.
func (m *AgentMutation) SupportsMultimodal() (r bool, exists bool) {
	v := m.supports_multimodal
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsMultimodal returns the old "supports_multimodal" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSupportsMultimodal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsMultimodal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsMultimodal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsMultimodal: %w", err)
	}
	return oldValue.SupportsMultimodal, nil
}

// ResetSupportsMultimodal resets all changes to the "supports_multimodal" field.
func (m *AgentMutation) ResetSupportsMultimodal() {
	m.supports_multimodal = nil
}

// SetModelPreferences sets the "model_preferences" field.
func (m *AgentMutation) SetModelPreferences(s []string) {
	m.model_preferences = &s
	m.appendmodel_preferences = nil
}

// ModelPreferences returns the value of the "model_preferences" field in the mutation.
func (m *AgentMutation) ModelPreferences() (r []string, exists bool) {
	v := m.model_preferences
	if v == nil {
		return
	}
	return *v, true
}

// OldModelPreferences returns the old "model_preferences" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldModelPreferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelPreferences: %w", err)
	}
	return oldValue.ModelPreferences, nil
}

// AppendModelPreferences adds s to the "model_preferences" field.
func (m *AgentMutation) AppendModelPreferences(s []string) {
	m.appendmodel_preferences = append(m.appendmodel_preferences, s...)
}

// AppendedModelPreferences returns the list of values that were appended to the "model_preferences" field in this mutation.
func (m *AgentMutation) AppendedModelPreferences() ([]string, bool) {
	if len(m.appendmodel_preferences) == 0 {
		return nil, false
	}
	return m.appendmodel_preferences, true
}

// ClearModelPreferences clears the value of the "model_preferences" field.
func (m *AgentMutation) ClearModelPreferences() {
	m.model_preferences = nil
	m.appendmodel_preferences = nil
	m.clearedFields[agent.FieldModelPreferences] = struct{}{}
}

// ModelPreferencesCleared returns if the "model_preferences" field was cleared in this mutation.
func (m *AgentMutation) ModelPreferencesCleared() bool {
	_, ok := m.clearedFields[agent.FieldModelPreferences]
	return ok
}

// ResetModelPreferences resets all changes to the "model_preferences" field.
func (m *AgentMutation) ResetModelPreferences() {
	m.model_preferences = nil
	m.appendmodel_preferences = nil
	delete(m.clearedFields, agent.FieldModelPreferences)
}

// SetDefaultTemperature sets the "default_temperature" field.
func (m *AgentMutation) SetDefaultTemperature(f float64) {
	m.default_temperature = &f
	m.adddefault_temperature = nil
}

// DefaultTemperature returns the value of the "default_temperature" field in the mutation.
func (m *AgentMutation) DefaultTemperature() (r float64, exists bool) {
	v := m.default_temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTemperature returns the old "default_temperature" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDefaultTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTemperature: %w", err)
	}
	return oldValue.DefaultTemperature, nil
}

// AddDefaultTemperature adds f to the "default_temperature" field.
func (m *AgentMutation) AddDefaultTemperature(f float64) {
	if m.adddefault_temperature != nil {
		*m.adddefault_temperature += f
	} else {
		m.adddefault_temperature = &f
	}
}

// AddedDefaultTemperature returns the value that was added to the "default_temperature" field in this mutation.
func (m *AgentMutation) AddedDefaultTemperature() (r float64, exists bool) {
	v := m.adddefault_temperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultTemperature clears the value of the "default_temperature" field.
func (m *AgentMutation) ClearDefaultTemperature() {
	m.default_temperature = nil
	m.adddefault_temperature = nil
	m.clearedFields[agent.FieldDefaultTemperature] = struct{}{}
}

// DefaultTemperatureCleared returns if the "default_temperature" field was cleared in this mutation.
func (m *AgentMutation) DefaultTemperatureCleared() bool {
	_, ok := m.clearedFields[agent.FieldDefaultTemperature]
	return ok
}

// ResetDefaultTemperature resets all changes to the "default_temperature" field.
func (m *AgentMutation) ResetDefaultTemperature() {
	m.default_temperature = nil
	m.adddefault_temperature = nil
	delete(m.clearedFields, agent.FieldDefaultTemperature)
}

// SetDefaultMaxTokens sets the "default_max_tokens" field.
func (m *AgentMutation) SetDefaultMaxTokens(i int) {
	m.default_max_tokens = &i
	m.adddefault_max_tokens = nil
}

// DefaultMaxTokens returns the value of the "default_max_tokens" field in the mutation.
func (m *AgentMutation) DefaultMaxTokens() (r int, exists bool) {
	v := m.default_max_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultMaxTokens returns the old "default_max_tokens" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDefaultMaxTokens(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultMaxTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultMaxTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultMaxTokens: %w", err)
	}
	return oldValue.DefaultMaxTokens, nil
}

// AddDefaultMaxTokens adds i to the "default_max_tokens" field.
func (m *AgentMutation) AddDefaultMaxTokens(i int) {
	if m.adddefault_max_tokens != nil {
		*m.adddefault_max_tokens += i
	} else {
		m.adddefault_max_tokens = &i
	}
}

// AddedDefaultMaxTokens returns the value that was added to the "default_max_tokens" field in this mutation.
func (m *AgentMutation) AddedDefaultMaxTokens() (r int, exists bool) {
	v := m.adddefault_max_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultMaxTokens clears the value of the "default_max_tokens" field.
func (m *AgentMutation) ClearDefaultMaxTokens() {
	m.default_max_tokens = nil
	m.adddefault_max_tokens = nil
	m.clearedFields[agent.FieldDefaultMaxTokens] = struct{}{}
}

// DefaultMaxTokensCleared returns if the "default_max_tokens" field was cleared in this mutation.
func (m *AgentMutation) DefaultMaxTokensCleared() bool {
	_, ok := m.clearedFields[agent.FieldDefaultMaxTokens]
	return ok
}

// ResetDefaultMaxTokens resets all changes to the "default_max_tokens" field.
func (m *AgentMutation) ResetDefaultMaxTokens() {
	m.default_max_tokens = nil
	m.adddefault_max_tokens = nil
	delete(m.clearedFields, agent.FieldDefaultMaxTokens)
}

// SetSessionTimeoutMinutes sets the "session_timeout_minutes" field.
func (m *AgentMutation) SetSessionTimeoutMinutes(i int) {
	m.session_timeout_minutes = &i
	m.addsession_timeout_minutes = nil
}

// SessionTimeoutMinutes returns the value of the "session_timeout_minutes" field in the mutation.
func (m *AgentMutation) SessionTimeoutMinutes() (r int, exists bool) {
	v := m.session_timeout_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionTimeoutMinutes returns the old "session_timeout_minutes" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSessionTimeoutMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionTimeoutMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionTimeoutMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionTimeoutMinutes: %w", err)
	}
	return oldValue.SessionTimeoutMinutes, nil
}

// AddSessionTimeoutMinutes adds i to the "session_timeout_minutes" field.
func (m *AgentMutation) AddSessionTimeoutMinutes(i int) {
	if m.addsession_timeout_minutes != nil {
		*m.addsession_timeout_minutes += i
	} else {
		m.addsession_timeout_minutes = &i
	}
}

// AddedSessionTimeoutMinutes returns the value that was added to the "session_timeout_minutes" field in this mutation.
func (m *AgentMutation) AddedSessionTimeoutMinutes() (r int, exists bool) {
	v := m.addsession_timeout_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionTimeoutMinutes resets all changes to the "session_timeout_minutes" field.
func (m *AgentMutation) ResetSessionTimeoutMinutes() {
	m.session_timeout_minutes = nil
	m.addsession_timeout_minutes = nil
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *AgentMutation) SetRepositoryID(id string) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *AgentMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *AgentMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *AgentMutation) RepositoryID() (id string, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) RepositoryIDs() (ids []string) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *AgentMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// AddDependencyIDs adds the "dependencies" edge to the AgentDependency entity by ids.
func (m *AgentMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the AgentDependency entity.
func (m *AgentMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the AgentDependency entity was cleared.
func (m *AgentMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the AgentDependency entity by IDs.
func (m *AgentMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the AgentDependency entity.
func (m *AgentMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *AgentMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *AgentMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 41)
	if m.name != nil {
		fields = append(fields, agent.FieldName)
	}
	if m.namespace != nil {
		fields = append(fields, agent.FieldNamespace)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, agent.FieldDescription)
	}
	if m.author != nil {
		fields = append(fields, agent.FieldAuthor)
	}
	if m.license != nil {
		fields = append(fields, agent.FieldLicense)
	}
	if m.homepage != nil {
		fields = append(fields, agent.FieldHomepage)
	}
	if m.documentation != nil {
		fields = append(fields, agent.FieldDocumentation)
	}
	if m.tags != nil {
		fields = append(fields, agent.FieldTags)
	}
	if m.categories != nil {
		fields = append(fields, agent.FieldCategories)
	}
	if m.keywords != nil {
		fields = append(fields, agent.FieldKeywords)
	}
	if m.stability != nil {
		fields = append(fields, agent.FieldStability)
	}
	if m.maturity != nil {
		fields = append(fields, agent.FieldMaturity)
	}
	if m.forge_version != nil {
		fields = append(fields, agent.FieldForgeVersion)
	}
	if m.platforms != nil {
		fields = append(fields, agent.FieldPlatforms)
	}
	if m.spec != nil {
		fields = append(fields, agent.FieldSpec)
	}
	if m.spec_hash != nil {
		fields = append(fields, agent.FieldSpecHash)
	}
	if m.is_installed != nil {
		fields = append(fields, agent.FieldIsInstalled)
	}
	if m.install_path != nil {
		fields = append(fields, agent.FieldInstallPath)
	}
	if m.installed_at != nil {
		fields = append(fields, agent.FieldInstalledAt)
	}
	if m.commit_hash != nil {
		fields = append(fields, agent.FieldCommitHash)
	}
	if m.branch != nil {
		fields = append(fields, agent.FieldBranch)
	}
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.config_path != nil {
		fields = append(fields, agent.FieldConfigPath)
	}
	if m.agent_config != nil {
		fields = append(fields, agent.FieldAgentConfig)
	}
	if m.llm_provider != nil {
		fields = append(fields, agent.FieldLlmProvider)
	}
	if m.system_prompt_id != nil {
		fields = append(fields, agent.FieldSystemPromptID)
	}
	if m.tool_dependencies != nil {
		fields = append(fields, agent.FieldToolDependencies)
	}
	if m.prompt_dependencies != nil {
		fields = append(fields, agent.FieldPromptDependencies)
	}
	if m.agent_dependencies != nil {
		fields = append(fields, agent.FieldAgentDependencies)
	}
	if m.agent_type != nil {
		fields = append(fields, agent.FieldAgentType)
	}
	if m.capabilities != nil {
		fields = append(fields, agent.FieldCapabilities)
	}
	if m.supported_languages != nil {
		fields = append(fields, agent.FieldSupportedLanguages)
	}
	if m.supports_memory != nil {
		fields = append(fields, agent.FieldSupportsMemory)
	}
	if m.supports_tools != nil {
		fields = append(fields, agent.FieldSupportsTools)
	}
	if m.supports_multimodal != nil {
		fields = append(fields, agent.FieldSupportsMultimodal)
	}
	if m.model_preferences != nil {
		fields = append(fields, agent.FieldModelPreferences)
	}
	if m.default_temperature != nil {
		fields = append(fields, agent.FieldDefaultTemperature)
	}
	if m.default_max_tokens != nil {
		fields = append(fields, agent.FieldDefaultMaxTokens)
	}
	if m.session_timeout_minutes != nil {
		fields = append(fields, agent.FieldSessionTimeoutMinutes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldName:
		return m.Name()
	case agent.FieldNamespace:
		return m.Namespace()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldDescription:
		return m.Description()
	case agent.FieldAuthor:
		return m.Author()
	case agent.FieldLicense:
		return m.License()
	case agent.FieldHomepage:
		return m.Homepage()
	case agent.FieldDocumentation:
		return m.Documentation()
	case agent.FieldTags:
		return m.Tags()
	case agent.FieldCategories:
		return m.Categories()
	case agent.FieldKeywords:
		return m.Keywords()
	case agent.FieldStability:
		return m.Stability()
	case agent.FieldMaturity:
		return m.Maturity()
	case agent.FieldForgeVersion:
		return m.ForgeVersion()
	case agent.FieldPlatforms:
		return m.Platforms()
	case agent.FieldSpec:
		return m.Spec()
	case agent.FieldSpecHash:
		return m.SpecHash()
	case agent.FieldIsInstalled:
		return m.IsInstalled()
	case agent.FieldInstallPath:
		return m.InstallPath()
	case agent.FieldInstalledAt:
		return m.InstalledAt()
	case agent.FieldCommitHash:
		return m.CommitHash()
	case agent.FieldBranch:
		return m.Branch()
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldConfigPath:
		return m.ConfigPath()
	case agent.FieldAgentConfig:
		return m.AgentConfig()
	case agent.FieldLlmProvider:
		return m.LlmProvider()
	case agent.FieldSystemPromptID:
		return m.SystemPromptID()
	case agent.FieldToolDependencies:
		return m.ToolDependencies()
	case agent.FieldPromptDependencies:
		return m.PromptDependencies()
	case agent.FieldAgentDependencies:
		return m.AgentDependencies()
	case agent.FieldAgentType:
		return m.AgentType()
	case agent.FieldCapabilities:
		return m.Capabilities()
	case agent.FieldSupportedLanguages:
		return m.SupportedLanguages()
	case agent.FieldSupportsMemory:
		return m.SupportsMemory()
	case agent.FieldSupportsTools:
		return m.SupportsTools()
	case agent.FieldSupportsMultimodal:
		return m.SupportsMultimodal()
	case agent.FieldModelPreferences:
		return m.ModelPreferences()
	case agent.FieldDefaultTemperature:
		return m.DefaultTemperature()
	case agent.FieldDefaultMaxTokens:
		return m.DefaultMaxTokens()
	case agent.FieldSessionTimeoutMinutes:
		return m.SessionTimeoutMinutes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldName:
		return m.OldName(ctx)
	case agent.FieldNamespace:
		return m.OldNamespace(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldDescription:
		return m.OldDescription(ctx)
	case agent.FieldAuthor:
		return m.OldAuthor(ctx)
	case agent.FieldLicense:
		return m.OldLicense(ctx)
	case agent.FieldHomepage:
		return m.OldHomepage(ctx)
	case agent.FieldDocumentation:
		return m.OldDocumentation(ctx)
	case agent.FieldTags:
		return m.OldTags(ctx)
	case agent.FieldCategories:
		return m.OldCategories(ctx)
	case agent.FieldKeywords:
		return m.OldKeywords(ctx)
	case agent.FieldStability:
		return m.OldStability(ctx)
	case agent.FieldMaturity:
		return m.OldMaturity(ctx)
	case agent.FieldForgeVersion:
		return m.OldForgeVersion(ctx)
	case agent.FieldPlatforms:
		return m.OldPlatforms(ctx)
	case agent.FieldSpec:
		return m.OldSpec(ctx)
	case agent.FieldSpecHash:
		return m.OldSpecHash(ctx)
	case agent.FieldIsInstalled:
		return m.OldIsInstalled(ctx)
	case agent.FieldInstallPath:
		return m.OldInstallPath(ctx)
	case agent.FieldInstalledAt:
		return m.OldInstalledAt(ctx)
	case agent.FieldCommitHash:
		return m.OldCommitHash(ctx)
	case agent.FieldBranch:
		return m.OldBranch(ctx)
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldConfigPath:
		return m.OldConfigPath(ctx)
	case agent.FieldAgentConfig:
		return m.OldAgentConfig(ctx)
	case agent.FieldLlmProvider:
		return m.OldLlmProvider(ctx)
	case agent.FieldSystemPromptID:
		return m.OldSystemPromptID(ctx)
	case agent.FieldToolDependencies:
		return m.OldToolDependencies(ctx)
	case agent.FieldPromptDependencies:
		return m.OldPromptDependencies(ctx)
	case agent.FieldAgentDependencies:
		return m.OldAgentDependencies(ctx)
	case agent.FieldAgentType:
		return m.OldAgentType(ctx)
	case agent.FieldCapabilities:
		return m.OldCapabilities(ctx)
	case agent.FieldSupportedLanguages:
		return m.OldSupportedLanguages(ctx)
	case agent.FieldSupportsMemory:
		return m.OldSupportsMemory(ctx)
	case agent.FieldSupportsTools:
		return m.OldSupportsTools(ctx)
	case agent.FieldSupportsMultimodal:
		return m.OldSupportsMultimodal(ctx)
	case agent.FieldModelPreferences:
		return m.OldModelPreferences(ctx)
	case agent.FieldDefaultTemperature:
		return m.OldDefaultTemperature(ctx)
	case agent.FieldDefaultMaxTokens:
		return m.OldDefaultMaxTokens(ctx)
	case agent.FieldSessionTimeoutMinutes:
		return m.OldSessionTimeoutMinutes(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case agent.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case agent.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case agent.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case agent.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case agent.FieldDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentation(v)
		return nil
	case agent.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case agent.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case agent.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case agent.FieldStability:
		v, ok := value.(agent.Stability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case agent.FieldMaturity:
		v, ok := value.(agent.Maturity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturity(v)
		return nil
	case agent.FieldForgeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgeVersion(v)
		return nil
	case agent.FieldPlatforms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatforms(v)
		return nil
	case agent.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case agent.FieldSpecHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecHash(v)
		return nil
	case agent.FieldIsInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstalled(v)
		return nil
	case agent.FieldInstallPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallPath(v)
		return nil
	case agent.FieldInstalledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledAt(v)
		return nil
	case agent.FieldCommitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitHash(v)
		return nil
	case agent.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldConfigPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigPath(v)
		return nil
	case agent.FieldAgentConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentConfig(v)
		return nil
	case agent.FieldLlmProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmProvider(v)
		return nil
	case agent.FieldSystemPromptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemPromptID(v)
		return nil
	case agent.FieldToolDependencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolDependencies(v)
		return nil
	case agent.FieldPromptDependencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptDependencies(v)
		return nil
	case agent.FieldAgentDependencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentDependencies(v)
		return nil
	case agent.FieldAgentType:
		v, ok := value.(agent.AgentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentType(v)
		return nil
	case agent.FieldCapabilities:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilities(v)
		return nil
	case agent.FieldSupportedLanguages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedLanguages(v)
		return nil
	case agent.FieldSupportsMemory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsMemory(v)
		return nil
	case agent.FieldSupportsTools:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsTools(v)
		return nil
	case agent.FieldSupportsMultimodal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsMultimodal(v)
		return nil
	case agent.FieldModelPreferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelPreferences(v)
		return nil
	case agent.FieldDefaultTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTemperature(v)
		return nil
	case agent.FieldDefaultMaxTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultMaxTokens(v)
		return nil
	case agent.FieldSessionTimeoutMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionTimeoutMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	var fields []string
	if m.adddefault_temperature != nil {
		fields = append(fields, agent.FieldDefaultTemperature)
	}
	if m.adddefault_max_tokens != nil {
		fields = append(fields, agent.FieldDefaultMaxTokens)
	}
	if m.addsession_timeout_minutes != nil {
		fields = append(fields, agent.FieldSessionTimeoutMinutes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldDefaultTemperature:
		return m.AddedDefaultTemperature()
	case agent.FieldDefaultMaxTokens:
		return m.AddedDefaultMaxTokens()
	case agent.FieldSessionTimeoutMinutes:
		return m.AddedSessionTimeoutMinutes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agent.FieldDefaultTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultTemperature(v)
		return nil
	case agent.FieldDefaultMaxTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultMaxTokens(v)
		return nil
	case agent.FieldSessionTimeoutMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionTimeoutMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldHomepage) {
		fields = append(fields, agent.FieldHomepage)
	}
	if m.FieldCleared(agent.FieldDocumentation) {
		fields = append(fields, agent.FieldDocumentation)
	}
	if m.FieldCleared(agent.FieldTags) {
		fields = append(fields, agent.FieldTags)
	}
	if m.FieldCleared(agent.FieldCategories) {
		fields = append(fields, agent.FieldCategories)
	}
	if m.FieldCleared(agent.FieldKeywords) {
		fields = append(fields, agent.FieldKeywords)
	}
	if m.FieldCleared(agent.FieldPlatforms) {
		fields = append(fields, agent.FieldPlatforms)
	}
	if m.FieldCleared(agent.FieldInstallPath) {
		fields = append(fields, agent.FieldInstallPath)
	}
	if m.FieldCleared(agent.FieldInstalledAt) {
		fields = append(fields, agent.FieldInstalledAt)
	}
	if m.FieldCleared(agent.FieldConfigPath) {
		fields = append(fields, agent.FieldConfigPath)
	}
	if m.FieldCleared(agent.FieldAgentConfig) {
		fields = append(fields, agent.FieldAgentConfig)
	}
	if m.FieldCleared(agent.FieldLlmProvider) {
		fields = append(fields, agent.FieldLlmProvider)
	}
	if m.FieldCleared(agent.FieldSystemPromptID) {
		fields = append(fields, agent.FieldSystemPromptID)
	}
	if m.FieldCleared(agent.FieldToolDependencies) {
		fields = append(fields, agent.FieldToolDependencies)
	}
	if m.FieldCleared(agent.FieldPromptDependencies) {
		fields = append(fields, agent.FieldPromptDependencies)
	}
	if m.FieldCleared(agent.FieldAgentDependencies) {
		fields = append(fields, agent.FieldAgentDependencies)
	}
	if m.FieldCleared(agent.FieldCapabilities) {
		fields = append(fields, agent.FieldCapabilities)
	}
	if m.FieldCleared(agent.FieldSupportedLanguages) {
		fields = append(fields, agent.FieldSupportedLanguages)
	}
	if m.FieldCleared(agent.FieldModelPreferences) {
		fields = append(fields, agent.FieldModelPreferences)
	}
	if m.FieldCleared(agent.FieldDefaultTemperature) {
		fields = append(fields, agent.FieldDefaultTemperature)
	}
	if m.FieldCleared(agent.FieldDefaultMaxTokens) {
		fields = append(fields, agent.FieldDefaultMaxTokens)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldHomepage:
		m.ClearHomepage()
		return nil
	case agent.FieldDocumentation:
		m.ClearDocumentation()
		return nil
	case agent.FieldTags:
		m.ClearTags()
		return nil
	case agent.FieldCategories:
		m.ClearCategories()
		return nil
	case agent.FieldKeywords:
		m.ClearKeywords()
		return nil
	case agent.FieldPlatforms:
		m.ClearPlatforms()
		return nil
	case agent.FieldInstallPath:
		m.ClearInstallPath()
		return nil
	case agent.FieldInstalledAt:
		m.ClearInstalledAt()
		return nil
	case agent.FieldConfigPath:
		m.ClearConfigPath()
		return nil
	case agent.FieldAgentConfig:
		m.ClearAgentConfig()
		return nil
	case agent.FieldLlmProvider:
		m.ClearLlmProvider()
		return nil
	case agent.FieldSystemPromptID:
		m.ClearSystemPromptID()
		return nil
	case agent.FieldToolDependencies:
		m.ClearToolDependencies()
		return nil
	case agent.FieldPromptDependencies:
		m.ClearPromptDependencies()
		return nil
	case agent.FieldAgentDependencies:
		m.ClearAgentDependencies()
		return nil
	case agent.FieldCapabilities:
		m.ClearCapabilities()
		return nil
	case agent.FieldSupportedLanguages:
		m.ClearSupportedLanguages()
		return nil
	case agent.FieldModelPreferences:
		m.ClearModelPreferences()
		return nil
	case agent.FieldDefaultTemperature:
		m.ClearDefaultTemperature()
		return nil
	case agent.FieldDefaultMaxTokens:
		m.ClearDefaultMaxTokens()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldName:
		m.ResetName()
		return nil
	case agent.FieldNamespace:
		m.ResetNamespace()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldDescription:
		m.ResetDescription()
		return nil
	case agent.FieldAuthor:
		m.ResetAuthor()
		return nil
	case agent.FieldLicense:
		m.ResetLicense()
		return nil
	case agent.FieldHomepage:
		m.ResetHomepage()
		return nil
	case agent.FieldDocumentation:
		m.ResetDocumentation()
		return nil
	case agent.FieldTags:
		m.ResetTags()
		return nil
	case agent.FieldCategories:
		m.ResetCategories()
		return nil
	case agent.FieldKeywords:
		m.ResetKeywords()
		return nil
	case agent.FieldStability:
		m.ResetStability()
		return nil
	case agent.FieldMaturity:
		m.ResetMaturity()
		return nil
	case agent.FieldForgeVersion:
		m.ResetForgeVersion()
		return nil
	case agent.FieldPlatforms:
		m.ResetPlatforms()
		return nil
	case agent.FieldSpec:
		m.ResetSpec()
		return nil
	case agent.FieldSpecHash:
		m.ResetSpecHash()
		return nil
	case agent.FieldIsInstalled:
		m.ResetIsInstalled()
		return nil
	case agent.FieldInstallPath:
		m.ResetInstallPath()
		return nil
	case agent.FieldInstalledAt:
		m.ResetInstalledAt()
		return nil
	case agent.FieldCommitHash:
		m.ResetCommitHash()
		return nil
	case agent.FieldBranch:
		m.ResetBranch()
		return nil
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldConfigPath:
		m.ResetConfigPath()
		return nil
	case agent.FieldAgentConfig:
		m.ResetAgentConfig()
		return nil
	case agent.FieldLlmProvider:
		m.ResetLlmProvider()
		return nil
	case agent.FieldSystemPromptID:
		m.ResetSystemPromptID()
		return nil
	case agent.FieldToolDependencies:
		m.ResetToolDependencies()
		return nil
	case agent.FieldPromptDependencies:
		m.ResetPromptDependencies()
		return nil
	case agent.FieldAgentDependencies:
		m.ResetAgentDependencies()
		return nil
	case agent.FieldAgentType:
		m.ResetAgentType()
		return nil
	case agent.FieldCapabilities:
		m.ResetCapabilities()
		return nil
	case agent.FieldSupportedLanguages:
		m.ResetSupportedLanguages()
		return nil
	case agent.FieldSupportsMemory:
		m.ResetSupportsMemory()
		return nil
	case agent.FieldSupportsTools:
		m.ResetSupportsTools()
		return nil
	case agent.FieldSupportsMultimodal:
		m.ResetSupportsMultimodal()
		return nil
	case agent.FieldModelPreferences:
		m.ResetModelPreferences()
		return nil
	case agent.FieldDefaultTemperature:
		m.ResetDefaultTemperature()
		return nil
	case agent.FieldDefaultMaxTokens:
		m.ResetDefaultMaxTokens()
		return nil
	case agent.FieldSessionTimeoutMinutes:
		m.ResetSessionTimeoutMinutes()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repository != nil {
		edges = append(edges, agent.EdgeRepository)
	}
	if m.dependencies != nil {
		edges = append(edges, agent.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddependencies != nil {
		edges = append(edges, agent.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepository {
		edges = append(edges, agent.EdgeRepository)
	}
	if m.cleareddependencies {
		edges = append(edges, agent.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeRepository:
		return m.clearedrepository
	case agent.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeRepository:
		m.ResetRepository()
		return nil
	case agent.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AgentDependencyMutation represents an operation that mutates the AgentDependency nodes in the graph.
type AgentDependencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *agentdependency.Type
	dependency_name    *string
	dependency_version *string
	version_range      *string
	is_required        *bool
	condition          *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	agent              *string
	clearedagent       bool
	done               bool
	oldValue           func(context.Context) (*AgentDependency, error)
	predicates         []predicate.AgentDependency
}

var _ ent.Mutation = (*AgentDependencyMutation)(nil)

// agentdependencyOption allows management of the mutation configuration using functional options.
type agentdependencyOption func(*AgentDependencyMutation)

// newAgentDependencyMutation creates new mutation for the AgentDependency entity.
func newAgentDependencyMutation(c config, op Op, opts ...agentdependencyOption) *AgentDependencyMutation {
	m := &AgentDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentDependencyID sets the ID field of the mutation.
func withAgentDependencyID(id string) agentdependencyOption {
	return func(m *AgentDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentDependency
		)
		m.oldValue = func(ctx context.Context) (*AgentDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentDependency sets the old AgentDependency of the mutation.
func withAgentDependency(node *AgentDependency) agentdependencyOption {
	return func(m *AgentDependencyMutation) {
		m.oldValue = func(context.Context) (*AgentDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentDependency entities.
func (m *AgentDependencyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentDependencyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentDependencyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *AgentDependencyMutation) SetType(a agentdependency.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AgentDependencyMutation) GetType() (r agentdependency.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldType(ctx context.Context) (v agentdependency.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AgentDependencyMutation) ResetType() {
	m._type = nil
}

// SetDependencyName sets the "dependency_name" field.
func (m *AgentDependencyMutation) SetDependencyName(s string) {
	m.dependency_name = &s
}

// DependencyName returns the value of the "dependency_name" field in the mutation.
func (m *AgentDependencyMutation) DependencyName() (r string, exists bool) {
	v := m.dependency_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyName returns the old "dependency_name" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldDependencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyName: %w", err)
	}
	return oldValue.DependencyName, nil
}

// ResetDependencyName resets all changes to the "dependency_name" field.
func (m *AgentDependencyMutation) ResetDependencyName() {
	m.dependency_name = nil
}

// SetDependencyVersion sets the "dependency_version" field.
func (m *AgentDependencyMutation) SetDependencyVersion(s string) {
	m.dependency_version = &s
}

// DependencyVersion returns the value of the "dependency_version" field in the mutation.
func (m *AgentDependencyMutation) DependencyVersion() (r string, exists bool) {
	v := m.dependency_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyVersion returns the old "dependency_version" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldDependencyVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyVersion: %w", err)
	}
	return oldValue.DependencyVersion, nil
}

// ResetDependencyVersion resets all changes to the "dependency_version" field.
func (m *AgentDependencyMutation) ResetDependencyVersion() {
	m.dependency_version = nil
}

// SetVersionRange sets the "version_range" field.
func (m *AgentDependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *AgentDependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *AgentDependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetIsRequired sets the "is_required" field.
func (m *AgentDependencyMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *AgentDependencyMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *AgentDependencyMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetCondition sets the "condition" field.
func (m *AgentDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *AgentDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldCondition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of the "condition" field.
func (m *AgentDependencyMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[agentdependency.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *AgentDependencyMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[agentdependency.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *AgentDependencyMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, agentdependency.FieldCondition)
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentDependency entity.
// If the AgentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *AgentDependencyMutation) SetAgentID(id string) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *AgentDependencyMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *AgentDependencyMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *AgentDependencyMutation) AgentID() (id string, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *AgentDependencyMutation) AgentIDs() (ids []string) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *AgentDependencyMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// Where appends a list predicates to the AgentDependencyMutation builder.
func (m *AgentDependencyMutation) Where(ps ...predicate.AgentDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentDependency).
func (m *AgentDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, agentdependency.FieldType)
	}
	if m.dependency_name != nil {
		fields = append(fields, agentdependency.FieldDependencyName)
	}
	if m.dependency_version != nil {
		fields = append(fields, agentdependency.FieldDependencyVersion)
	}
	if m.version_range != nil {
		fields = append(fields, agentdependency.FieldVersionRange)
	}
	if m.is_required != nil {
		fields = append(fields, agentdependency.FieldIsRequired)
	}
	if m.condition != nil {
		fields = append(fields, agentdependency.FieldCondition)
	}
	if m.created_at != nil {
		fields = append(fields, agentdependency.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentdependency.FieldType:
		return m.GetType()
	case agentdependency.FieldDependencyName:
		return m.DependencyName()
	case agentdependency.FieldDependencyVersion:
		return m.DependencyVersion()
	case agentdependency.FieldVersionRange:
		return m.VersionRange()
	case agentdependency.FieldIsRequired:
		return m.IsRequired()
	case agentdependency.FieldCondition:
		return m.Condition()
	case agentdependency.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentdependency.FieldType:
		return m.OldType(ctx)
	case agentdependency.FieldDependencyName:
		return m.OldDependencyName(ctx)
	case agentdependency.FieldDependencyVersion:
		return m.OldDependencyVersion(ctx)
	case agentdependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case agentdependency.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case agentdependency.FieldCondition:
		return m.OldCondition(ctx)
	case agentdependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AgentDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentdependency.FieldType:
		v, ok := value.(agentdependency.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case agentdependency.FieldDependencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyName(v)
		return nil
	case agentdependency.FieldDependencyVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyVersion(v)
		return nil
	case agentdependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case agentdependency.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case agentdependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case agentdependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AgentDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AgentDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agentdependency.FieldCondition) {
		fields = append(fields, agentdependency.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentDependencyMutation) ClearField(name string) error {
	switch name {
	case agentdependency.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown AgentDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentDependencyMutation) ResetField(name string) error {
	switch name {
	case agentdependency.FieldType:
		m.ResetType()
		return nil
	case agentdependency.FieldDependencyName:
		m.ResetDependencyName()
		return nil
	case agentdependency.FieldDependencyVersion:
		m.ResetDependencyVersion()
		return nil
	case agentdependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case agentdependency.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case agentdependency.FieldCondition:
		m.ResetCondition()
		return nil
	case agentdependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agent != nil {
		edges = append(edges, agentdependency.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentdependency.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedagent {
		edges = append(edges, agentdependency.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case agentdependency.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentDependencyMutation) ClearEdge(name string) error {
	switch name {
	case agentdependency.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown AgentDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentDependencyMutation) ResetEdge(name string) error {
	switch name {
	case agentdependency.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown AgentDependency edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	namespace           *string
	version             *string
	kind                *component.Kind
	description         *string
	author              *string
	license             *string
	homepage            *string
	documentation       *string
	tags                *[]string
	appendtags          []string
	categories          *[]string
	appendcategories    []string
	keywords            *[]string
	appendkeywords      []string
	stability           *component.Stability
	maturity            *component.Maturity
	forge_version       *string
	platforms           *[]string
	appendplatforms     []string
	spec                *string
	spec_hash           *string
	is_installed        *bool
	install_path        *string
	installed_at        *time.Time
	commit_hash         *string
	branch              *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	repository          *string
	clearedrepository   bool
	dependencies        map[string]struct{}
	removeddependencies map[string]struct{}
	cleareddependencies bool
	done                bool
	oldValue            func(context.Context) (*Component, error)
	predicates          []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id string) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Component entities.
func (m *ComponentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComponentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Component.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ComponentMutation) ResetName() {
	m.name = nil
}

// SetNamespace sets the "namespace" field.
func (m *ComponentMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *ComponentMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *ComponentMutation) ResetNamespace() {
	m.namespace = nil
}

// SetVersion sets the "version" field.
func (m *ComponentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ComponentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ComponentMutation) ResetVersion() {
	m.version = nil
}

// SetKind sets the "kind" field.
func (m *ComponentMutation) SetKind(c component.Kind) {
	m.kind = &c
}

// Kind returns the value of the "kind" field in the mutation.
func (m *ComponentMutation) Kind() (r component.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldKind(ctx context.Context) (v component.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *ComponentMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *ComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ComponentMutation) ResetDescription() {
	m.description = nil
}

// SetAuthor sets the "author" field.
func (m *ComponentMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ComponentMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ComponentMutation) ResetAuthor() {
	m.author = nil
}

// SetLicense sets the "license" field.
func (m *ComponentMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *ComponentMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ResetLicense resets all changes to the "license" field.
func (m *ComponentMutation) ResetLicense() {
	m.license = nil
}

// SetHomepage sets the "homepage" field.
func (m *ComponentMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *ComponentMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldHomepage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *ComponentMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[component.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *ComponentMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[component.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *ComponentMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, component.FieldHomepage)
}

// SetDocumentation sets the "documentation" field.
func (m *ComponentMutation) SetDocumentation(s string) {
	m.documentation = &s
}

// Documentation returns the value of the "documentation" field in the mutation.
func (m *ComponentMutation) Documentation() (r string, exists bool) {
	v := m.documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentation returns the old "documentation" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDocumentation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentation: %w", err)
	}
	return oldValue.Documentation, nil
}

// ClearDocumentation clears the value of the "documentation" field.
func (m *ComponentMutation) ClearDocumentation() {
	m.documentation = nil
	m.clearedFields[component.FieldDocumentation] = struct{}{}
}

// DocumentationCleared returns if the "documentation" field was cleared in this mutation.
func (m *ComponentMutation) DocumentationCleared() bool {
	_, ok := m.clearedFields[component.FieldDocumentation]
	return ok
}

// ResetDocumentation resets all changes to the "documentation" field.
func (m *ComponentMutation) ResetDocumentation() {
	m.documentation = nil
	delete(m.clearedFields, component.FieldDocumentation)
}

// SetTags sets the "tags" field.
func (m *ComponentMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ComponentMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ComponentMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ComponentMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ComponentMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[component.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ComponentMutation) TagsCleared() bool {
	_, ok := m.clearedFields[component.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ComponentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, component.FieldTags)
}

// SetCategories sets the "categories" field.
func (m *ComponentMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *ComponentMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *ComponentMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *ComponentMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *ComponentMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[component.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *ComponentMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[component.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *ComponentMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, component.FieldCategories)
}

// SetKeywords sets the "keywords" field.
func (m *ComponentMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *ComponentMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *ComponentMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *ComponentMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *ComponentMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[component.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *ComponentMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[component.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *ComponentMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, component.FieldKeywords)
}

// SetStability sets the "stability" field.
func (m *ComponentMutation) SetStability(c component.Stability) {
	m.stability = &c
}

// Stability returns the value of the "stability" field in the mutation.
func (m *ComponentMutation) Stability() (r component.Stability, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldStability(ctx context.Context) (v component.Stability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *ComponentMutation) ResetStability() {
	m.stability = nil
}

// SetMaturity sets the "maturity" field.
func (m *ComponentMutation) SetMaturity(c component.Maturity) {
	m.maturity = &c
}

// Maturity returns the value of the "maturity" field in the mutation.
func (m *ComponentMutation) Maturity() (r component.Maturity, exists bool) {
	v := m.maturity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturity returns the old "maturity" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldMaturity(ctx context.Context) (v component.Maturity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturity: %w", err)
	}
	return oldValue.Maturity, nil
}

// ResetMaturity resets all changes to the "maturity" field.
func (m *ComponentMutation) ResetMaturity() {
	m.maturity = nil
}

// SetForgeVersion sets the "forge_version" field.
func (m *ComponentMutation) SetForgeVersion(s string) {
	m.forge_version = &s
}

// ForgeVersion returns the value of the "forge_version" field in the mutation.
func (m *ComponentMutation) ForgeVersion() (r string, exists bool) {
	v := m.forge_version
	if v == nil {
		return
	}
	return *v, true
}

// OldForgeVersion returns the old "forge_version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldForgeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgeVersion: %w", err)
	}
	return oldValue.ForgeVersion, nil
}

// ResetForgeVersion resets all changes to the "forge_version" field.
func (m *ComponentMutation) ResetForgeVersion() {
	m.forge_version = nil
}

// SetPlatforms sets the "platforms" field.
func (m *ComponentMutation) SetPlatforms(s []string) {
	m.platforms = &s
	m.appendplatforms = nil
}

// Platforms returns the value of the "platforms" field in the mutation.
func (m *ComponentMutation) Platforms() (r []string, exists bool) {
	v := m.platforms
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatforms returns the old "platforms" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldPlatforms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatforms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatforms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatforms: %w", err)
	}
	return oldValue.Platforms, nil
}

// AppendPlatforms adds s to the "platforms" field.
func (m *ComponentMutation) AppendPlatforms(s []string) {
	m.appendplatforms = append(m.appendplatforms, s...)
}

// AppendedPlatforms returns the list of values that were appended to the "platforms" field in this mutation.
func (m *ComponentMutation) AppendedPlatforms() ([]string, bool) {
	if len(m.appendplatforms) == 0 {
		return nil, false
	}
	return m.appendplatforms, true
}

// ClearPlatforms clears the value of the "platforms" field.
func (m *ComponentMutation) ClearPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	m.clearedFields[component.FieldPlatforms] = struct{}{}
}

// PlatformsCleared returns if the "platforms" field was cleared in this mutation.
func (m *ComponentMutation) PlatformsCleared() bool {
	_, ok := m.clearedFields[component.FieldPlatforms]
	return ok
}

// ResetPlatforms resets all changes to the "platforms" field.
func (m *ComponentMutation) ResetPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	delete(m.clearedFields, component.FieldPlatforms)
}

// SetSpec sets the "spec" field.
func (m *ComponentMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *ComponentMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *ComponentMutation) ResetSpec() {
	m.spec = nil
}

// SetSpecHash sets the "spec_hash" field.
func (m *ComponentMutation) SetSpecHash(s string) {
	m.spec_hash = &s
}

// SpecHash returns the value of the "spec_hash" field in the mutation.
func (m *ComponentMutation) SpecHash() (r string, exists bool) {
	v := m.spec_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecHash returns the old "spec_hash" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldSpecHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecHash: %w", err)
	}
	return oldValue.SpecHash, nil
}

// ResetSpecHash resets all changes to the "spec_hash" field.
func (m *ComponentMutation) ResetSpecHash() {
	m.spec_hash = nil
}

// SetIsInstalled sets the "is_installed" field.
func (m *ComponentMutation) SetIsInstalled(b bool) {
	m.is_installed = &b
}

// IsInstalled returns the value of the "is_installed" field in the mutation.
func (m *ComponentMutation) IsInstalled() (r bool, exists bool) {
	v := m.is_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstalled returns the old "is_installed" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldIsInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstalled: %w", err)
	}
	return oldValue.IsInstalled, nil
}

// ResetIsInstalled resets all changes to the "is_installed" field.
func (m *ComponentMutation) ResetIsInstalled() {
	m.is_installed = nil
}

// SetInstallPath sets the "install_path" field.
func (m *ComponentMutation) SetInstallPath(s string) {
	m.install_path = &s
}

// InstallPath returns the value of the "install_path" field in the mutation.
func (m *ComponentMutation) InstallPath() (r string, exists bool) {
	v := m.install_path
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallPath returns the old "install_path" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldInstallPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallPath: %w", err)
	}
	return oldValue.InstallPath, nil
}

// ClearInstallPath clears the value of the "install_path" field.
func (m *ComponentMutation) ClearInstallPath() {
	m.install_path = nil
	m.clearedFields[component.FieldInstallPath] = struct{}{}
}

// InstallPathCleared returns if the "install_path" field was cleared in this mutation.
func (m *ComponentMutation) InstallPathCleared() bool {
	_, ok := m.clearedFields[component.FieldInstallPath]
	return ok
}

// ResetInstallPath resets all changes to the "install_path" field.
func (m *ComponentMutation) ResetInstallPath() {
	m.install_path = nil
	delete(m.clearedFields, component.FieldInstallPath)
}

// SetInstalledAt sets the "installed_at" field.
func (m *ComponentMutation) SetInstalledAt(t time.Time) {
	m.installed_at = &t
}

// InstalledAt returns the value of the "installed_at" field in the mutation.
func (m *ComponentMutation) InstalledAt() (r time.Time, exists bool) {
	v := m.installed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledAt returns the old "installed_at" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldInstalledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledAt: %w", err)
	}
	return oldValue.InstalledAt, nil
}

// ClearInstalledAt clears the value of the "installed_at" field.
func (m *ComponentMutation) ClearInstalledAt() {
	m.installed_at = nil
	m.clearedFields[component.FieldInstalledAt] = struct{}{}
}

// InstalledAtCleared returns if the "installed_at" field was cleared in this mutation.
func (m *ComponentMutation) InstalledAtCleared() bool {
	_, ok := m.clearedFields[component.FieldInstalledAt]
	return ok
}

// ResetInstalledAt resets all changes to the "installed_at" field.
func (m *ComponentMutation) ResetInstalledAt() {
	m.installed_at = nil
	delete(m.clearedFields, component.FieldInstalledAt)
}

// SetCommitHash sets the "commit_hash" field.
func (m *ComponentMutation) SetCommitHash(s string) {
	m.commit_hash = &s
}

// CommitHash returns the value of the "commit_hash" field in the mutation.
func (m *ComponentMutation) CommitHash() (r string, exists bool) {
	v := m.commit_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitHash returns the old "commit_hash" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldCommitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitHash: %w", err)
	}
	return oldValue.CommitHash, nil
}

// ResetCommitHash resets all changes to the "commit_hash" field.
func (m *ComponentMutation) ResetCommitHash() {
	m.commit_hash = nil
}

// SetBranch sets the "branch" field.
func (m *ComponentMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *ComponentMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *ComponentMutation) ResetBranch() {
	m.branch = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ComponentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ComponentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *ComponentMutation) SetRepositoryID(id string) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *ComponentMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *ComponentMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *ComponentMutation) RepositoryID() (id string, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *ComponentMutation) RepositoryIDs() (ids []string) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *ComponentMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// AddDependencyIDs adds the "dependencies" edge to the ComponentDependency entity by ids.
func (m *ComponentMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ComponentDependency entity.
func (m *ComponentMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ComponentDependency entity was cleared.
func (m *ComponentMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ComponentDependency entity by IDs.
func (m *ComponentMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ComponentDependency entity.
func (m *ComponentMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ComponentMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ComponentMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ComponentMutation builder.
func (m *ComponentMutation) Where(ps ...predicate.Component) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Component, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.name != nil {
		fields = append(fields, component.FieldName)
	}
	if m.namespace != nil {
		fields = append(fields, component.FieldNamespace)
	}
	if m.version != nil {
		fields = append(fields, component.FieldVersion)
	}
	if m.kind != nil {
		fields = append(fields, component.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, component.FieldDescription)
	}
	if m.author != nil {
		fields = append(fields, component.FieldAuthor)
	}
	if m.license != nil {
		fields = append(fields, component.FieldLicense)
	}
	if m.homepage != nil {
		fields = append(fields, component.FieldHomepage)
	}
	if m.documentation != nil {
		fields = append(fields, component.FieldDocumentation)
	}
	if m.tags != nil {
		fields = append(fields, component.FieldTags)
	}
	if m.categories != nil {
		fields = append(fields, component.FieldCategories)
	}
	if m.keywords != nil {
		fields = append(fields, component.FieldKeywords)
	}
	if m.stability != nil {
		fields = append(fields, component.FieldStability)
	}
	if m.maturity != nil {
		fields = append(fields, component.FieldMaturity)
	}
	if m.forge_version != nil {
		fields = append(fields, component.FieldForgeVersion)
	}
	if m.platforms != nil {
		fields = append(fields, component.FieldPlatforms)
	}
	if m.spec != nil {
		fields = append(fields, component.FieldSpec)
	}
	if m.spec_hash != nil {
		fields = append(fields, component.FieldSpecHash)
	}
	if m.is_installed != nil {
		fields = append(fields, component.FieldIsInstalled)
	}
	if m.install_path != nil {
		fields = append(fields, component.FieldInstallPath)
	}
	if m.installed_at != nil {
		fields = append(fields, component.FieldInstalledAt)
	}
	if m.commit_hash != nil {
		fields = append(fields, component.FieldCommitHash)
	}
	if m.branch != nil {
		fields = append(fields, component.FieldBranch)
	}
	if m.created_at != nil {
		fields = append(fields, component.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, component.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldName:
		return m.Name()
	case component.FieldNamespace:
		return m.Namespace()
	case component.FieldVersion:
		return m.Version()
	case component.FieldKind:
		return m.Kind()
	case component.FieldDescription:
		return m.Description()
	case component.FieldAuthor:
		return m.Author()
	case component.FieldLicense:
		return m.License()
	case component.FieldHomepage:
		return m.Homepage()
	case component.FieldDocumentation:
		return m.Documentation()
	case component.FieldTags:
		return m.Tags()
	case component.FieldCategories:
		return m.Categories()
	case component.FieldKeywords:
		return m.Keywords()
	case component.FieldStability:
		return m.Stability()
	case component.FieldMaturity:
		return m.Maturity()
	case component.FieldForgeVersion:
		return m.ForgeVersion()
	case component.FieldPlatforms:
		return m.Platforms()
	case component.FieldSpec:
		return m.Spec()
	case component.FieldSpecHash:
		return m.SpecHash()
	case component.FieldIsInstalled:
		return m.IsInstalled()
	case component.FieldInstallPath:
		return m.InstallPath()
	case component.FieldInstalledAt:
		return m.InstalledAt()
	case component.FieldCommitHash:
		return m.CommitHash()
	case component.FieldBranch:
		return m.Branch()
	case component.FieldCreatedAt:
		return m.CreatedAt()
	case component.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldName:
		return m.OldName(ctx)
	case component.FieldNamespace:
		return m.OldNamespace(ctx)
	case component.FieldVersion:
		return m.OldVersion(ctx)
	case component.FieldKind:
		return m.OldKind(ctx)
	case component.FieldDescription:
		return m.OldDescription(ctx)
	case component.FieldAuthor:
		return m.OldAuthor(ctx)
	case component.FieldLicense:
		return m.OldLicense(ctx)
	case component.FieldHomepage:
		return m.OldHomepage(ctx)
	case component.FieldDocumentation:
		return m.OldDocumentation(ctx)
	case component.FieldTags:
		return m.OldTags(ctx)
	case component.FieldCategories:
		return m.OldCategories(ctx)
	case component.FieldKeywords:
		return m.OldKeywords(ctx)
	case component.FieldStability:
		return m.OldStability(ctx)
	case component.FieldMaturity:
		return m.OldMaturity(ctx)
	case component.FieldForgeVersion:
		return m.OldForgeVersion(ctx)
	case component.FieldPlatforms:
		return m.OldPlatforms(ctx)
	case component.FieldSpec:
		return m.OldSpec(ctx)
	case component.FieldSpecHash:
		return m.OldSpecHash(ctx)
	case component.FieldIsInstalled:
		return m.OldIsInstalled(ctx)
	case component.FieldInstallPath:
		return m.OldInstallPath(ctx)
	case component.FieldInstalledAt:
		return m.OldInstalledAt(ctx)
	case component.FieldCommitHash:
		return m.OldCommitHash(ctx)
	case component.FieldBranch:
		return m.OldBranch(ctx)
	case component.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case component.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case component.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case component.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case component.FieldKind:
		v, ok := value.(component.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case component.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case component.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case component.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case component.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case component.FieldDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentation(v)
		return nil
	case component.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case component.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case component.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case component.FieldStability:
		v, ok := value.(component.Stability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case component.FieldMaturity:
		v, ok := value.(component.Maturity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturity(v)
		return nil
	case component.FieldForgeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgeVersion(v)
		return nil
	case component.FieldPlatforms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatforms(v)
		return nil
	case component.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case component.FieldSpecHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecHash(v)
		return nil
	case component.FieldIsInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstalled(v)
		return nil
	case component.FieldInstallPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallPath(v)
		return nil
	case component.FieldInstalledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledAt(v)
		return nil
	case component.FieldCommitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitHash(v)
		return nil
	case component.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case component.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case component.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(component.FieldHomepage) {
		fields = append(fields, component.FieldHomepage)
	}
	if m.FieldCleared(component.FieldDocumentation) {
		fields = append(fields, component.FieldDocumentation)
	}
	if m.FieldCleared(component.FieldTags) {
		fields = append(fields, component.FieldTags)
	}
	if m.FieldCleared(component.FieldCategories) {
		fields = append(fields, component.FieldCategories)
	}
	if m.FieldCleared(component.FieldKeywords) {
		fields = append(fields, component.FieldKeywords)
	}
	if m.FieldCleared(component.FieldPlatforms) {
		fields = append(fields, component.FieldPlatforms)
	}
	if m.FieldCleared(component.FieldInstallPath) {
		fields = append(fields, component.FieldInstallPath)
	}
	if m.FieldCleared(component.FieldInstalledAt) {
		fields = append(fields, component.FieldInstalledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	switch name {
	case component.FieldHomepage:
		m.ClearHomepage()
		return nil
	case component.FieldDocumentation:
		m.ClearDocumentation()
		return nil
	case component.FieldTags:
		m.ClearTags()
		return nil
	case component.FieldCategories:
		m.ClearCategories()
		return nil
	case component.FieldKeywords:
		m.ClearKeywords()
		return nil
	case component.FieldPlatforms:
		m.ClearPlatforms()
		return nil
	case component.FieldInstallPath:
		m.ClearInstallPath()
		return nil
	case component.FieldInstalledAt:
		m.ClearInstalledAt()
		return nil
	}
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldName:
		m.ResetName()
		return nil
	case component.FieldNamespace:
		m.ResetNamespace()
		return nil
	case component.FieldVersion:
		m.ResetVersion()
		return nil
	case component.FieldKind:
		m.ResetKind()
		return nil
	case component.FieldDescription:
		m.ResetDescription()
		return nil
	case component.FieldAuthor:
		m.ResetAuthor()
		return nil
	case component.FieldLicense:
		m.ResetLicense()
		return nil
	case component.FieldHomepage:
		m.ResetHomepage()
		return nil
	case component.FieldDocumentation:
		m.ResetDocumentation()
		return nil
	case component.FieldTags:
		m.ResetTags()
		return nil
	case component.FieldCategories:
		m.ResetCategories()
		return nil
	case component.FieldKeywords:
		m.ResetKeywords()
		return nil
	case component.FieldStability:
		m.ResetStability()
		return nil
	case component.FieldMaturity:
		m.ResetMaturity()
		return nil
	case component.FieldForgeVersion:
		m.ResetForgeVersion()
		return nil
	case component.FieldPlatforms:
		m.ResetPlatforms()
		return nil
	case component.FieldSpec:
		m.ResetSpec()
		return nil
	case component.FieldSpecHash:
		m.ResetSpecHash()
		return nil
	case component.FieldIsInstalled:
		m.ResetIsInstalled()
		return nil
	case component.FieldInstallPath:
		m.ResetInstallPath()
		return nil
	case component.FieldInstalledAt:
		m.ResetInstalledAt()
		return nil
	case component.FieldCommitHash:
		m.ResetCommitHash()
		return nil
	case component.FieldBranch:
		m.ResetBranch()
		return nil
	case component.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case component.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repository != nil {
		edges = append(edges, component.EdgeRepository)
	}
	if m.dependencies != nil {
		edges = append(edges, component.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	case component.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddependencies != nil {
		edges = append(edges, component.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepository {
		edges = append(edges, component.EdgeRepository)
	}
	if m.cleareddependencies {
		edges = append(edges, component.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case component.EdgeRepository:
		return m.clearedrepository
	case component.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	switch name {
	case component.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	switch name {
	case component.EdgeRepository:
		m.ResetRepository()
		return nil
	case component.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Component edge %s", name)
}

// ComponentDependencyMutation represents an operation that mutates the ComponentDependency nodes in the graph.
type ComponentDependencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *componentdependency.Type
	dependency_name    *string
	dependency_version *string
	version_range      *string
	is_required        *bool
	condition          *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	component          *string
	clearedcomponent   bool
	done               bool
	oldValue           func(context.Context) (*ComponentDependency, error)
	predicates         []predicate.ComponentDependency
}

var _ ent.Mutation = (*ComponentDependencyMutation)(nil)

// componentdependencyOption allows management of the mutation configuration using functional options.
type componentdependencyOption func(*ComponentDependencyMutation)

// newComponentDependencyMutation creates new mutation for the ComponentDependency entity.
func newComponentDependencyMutation(c config, op Op, opts ...componentdependencyOption) *ComponentDependencyMutation {
	m := &ComponentDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeComponentDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentDependencyID sets the ID field of the mutation.
func withComponentDependencyID(id string) componentdependencyOption {
	return func(m *ComponentDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *ComponentDependency
		)
		m.oldValue = func(ctx context.Context) (*ComponentDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ComponentDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponentDependency sets the old ComponentDependency of the mutation.
func withComponentDependency(node *ComponentDependency) componentdependencyOption {
	return func(m *ComponentDependencyMutation) {
		m.oldValue = func(context.Context) (*ComponentDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ComponentDependency entities.
func (m *ComponentDependencyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentDependencyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComponentDependencyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ComponentDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ComponentDependencyMutation) SetType(c componentdependency.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ComponentDependencyMutation) GetType() (r componentdependency.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldType(ctx context.Context) (v componentdependency.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ComponentDependencyMutation) ResetType() {
	m._type = nil
}

// SetDependencyName sets the "dependency_name" field.
func (m *ComponentDependencyMutation) SetDependencyName(s string) {
	m.dependency_name = &s
}

// DependencyName returns the value of the "dependency_name" field in the mutation.
func (m *ComponentDependencyMutation) DependencyName() (r string, exists bool) {
	v := m.dependency_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyName returns the old "dependency_name" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldDependencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyName: %w", err)
	}
	return oldValue.DependencyName, nil
}

// ResetDependencyName resets all changes to the "dependency_name" field.
func (m *ComponentDependencyMutation) ResetDependencyName() {
	m.dependency_name = nil
}

// SetDependencyVersion sets the "dependency_version" field.
func (m *ComponentDependencyMutation) SetDependencyVersion(s string) {
	m.dependency_version = &s
}

// DependencyVersion returns the value of the "dependency_version" field in the mutation.
func (m *ComponentDependencyMutation) DependencyVersion() (r string, exists bool) {
	v := m.dependency_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyVersion returns the old "dependency_version" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldDependencyVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyVersion: %w", err)
	}
	return oldValue.DependencyVersion, nil
}

// ResetDependencyVersion resets all changes to the "dependency_version" field.
func (m *ComponentDependencyMutation) ResetDependencyVersion() {
	m.dependency_version = nil
}

// SetVersionRange sets the "version_range" field.
func (m *ComponentDependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *ComponentDependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *ComponentDependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetIsRequired sets the "is_required" field.
func (m *ComponentDependencyMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *ComponentDependencyMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *ComponentDependencyMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetCondition sets the "condition" field.
func (m *ComponentDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *ComponentDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldCondition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of the "condition" field.
func (m *ComponentDependencyMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[componentdependency.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *ComponentDependencyMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[componentdependency.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *ComponentDependencyMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, componentdependency.FieldCondition)
}

// SetCreatedAt sets the "created_at" field.
func (m *ComponentDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ComponentDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ComponentDependency entity.
// If the ComponentDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ComponentDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetComponentID sets the "component" edge to the Component entity by id.
func (m *ComponentDependencyMutation) SetComponentID(id string) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the Component entity.
func (m *ComponentDependencyMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the Component entity was cleared.
func (m *ComponentDependencyMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *ComponentDependencyMutation) ComponentID() (id string, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *ComponentDependencyMutation) ComponentIDs() (ids []string) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *ComponentDependencyMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// Where appends a list predicates to the ComponentDependencyMutation builder.
func (m *ComponentDependencyMutation) Where(ps ...predicate.ComponentDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComponentDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComponentDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ComponentDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComponentDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComponentDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ComponentDependency).
func (m *ComponentDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, componentdependency.FieldType)
	}
	if m.dependency_name != nil {
		fields = append(fields, componentdependency.FieldDependencyName)
	}
	if m.dependency_version != nil {
		fields = append(fields, componentdependency.FieldDependencyVersion)
	}
	if m.version_range != nil {
		fields = append(fields, componentdependency.FieldVersionRange)
	}
	if m.is_required != nil {
		fields = append(fields, componentdependency.FieldIsRequired)
	}
	if m.condition != nil {
		fields = append(fields, componentdependency.FieldCondition)
	}
	if m.created_at != nil {
		fields = append(fields, componentdependency.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case componentdependency.FieldType:
		return m.GetType()
	case componentdependency.FieldDependencyName:
		return m.DependencyName()
	case componentdependency.FieldDependencyVersion:
		return m.DependencyVersion()
	case componentdependency.FieldVersionRange:
		return m.VersionRange()
	case componentdependency.FieldIsRequired:
		return m.IsRequired()
	case componentdependency.FieldCondition:
		return m.Condition()
	case componentdependency.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case componentdependency.FieldType:
		return m.OldType(ctx)
	case componentdependency.FieldDependencyName:
		return m.OldDependencyName(ctx)
	case componentdependency.FieldDependencyVersion:
		return m.OldDependencyVersion(ctx)
	case componentdependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case componentdependency.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case componentdependency.FieldCondition:
		return m.OldCondition(ctx)
	case componentdependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ComponentDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case componentdependency.FieldType:
		v, ok := value.(componentdependency.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case componentdependency.FieldDependencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyName(v)
		return nil
	case componentdependency.FieldDependencyVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyVersion(v)
		return nil
	case componentdependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case componentdependency.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case componentdependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case componentdependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ComponentDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ComponentDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(componentdependency.FieldCondition) {
		fields = append(fields, componentdependency.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentDependencyMutation) ClearField(name string) error {
	switch name {
	case componentdependency.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown ComponentDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentDependencyMutation) ResetField(name string) error {
	switch name {
	case componentdependency.FieldType:
		m.ResetType()
		return nil
	case componentdependency.FieldDependencyName:
		m.ResetDependencyName()
		return nil
	case componentdependency.FieldDependencyVersion:
		m.ResetDependencyVersion()
		return nil
	case componentdependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case componentdependency.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case componentdependency.FieldCondition:
		m.ResetCondition()
		return nil
	case componentdependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ComponentDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.component != nil {
		edges = append(edges, componentdependency.EdgeComponent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case componentdependency.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomponent {
		edges = append(edges, componentdependency.EdgeComponent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case componentdependency.EdgeComponent:
		return m.clearedcomponent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentDependencyMutation) ClearEdge(name string) error {
	switch name {
	case componentdependency.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown ComponentDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentDependencyMutation) ResetEdge(name string) error {
	switch name {
	case componentdependency.EdgeComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown ComponentDependency edge %s", name)
}

// ForkMutation represents an operation that mutates the Fork nodes in the graph.
type ForkMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	fork_url             *string
	fork_owner           *string
	fork_name            *string
	is_active            *bool
	last_sync            *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	original_repo        *string
	clearedoriginal_repo bool
	done                 bool
	oldValue             func(context.Context) (*Fork, error)
	predicates           []predicate.Fork
}

var _ ent.Mutation = (*ForkMutation)(nil)

// forkOption allows management of the mutation configuration using functional options.
type forkOption func(*ForkMutation)

// newForkMutation creates new mutation for the Fork entity.
func newForkMutation(c config, op Op, opts ...forkOption) *ForkMutation {
	m := &ForkMutation{
		config:        c,
		op:            op,
		typ:           TypeFork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withForkID sets the ID field of the mutation.
func withForkID(id string) forkOption {
	return func(m *ForkMutation) {
		var (
			err   error
			once  sync.Once
			value *Fork
		)
		m.oldValue = func(ctx context.Context) (*Fork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFork sets the old Fork of the mutation.
func withFork(node *Fork) forkOption {
	return func(m *ForkMutation) {
		m.oldValue = func(context.Context) (*Fork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ForkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ForkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fork entities.
func (m *ForkMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ForkMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ForkMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetForkURL sets the "fork_url" field.
func (m *ForkMutation) SetForkURL(s string) {
	m.fork_url = &s
}

// ForkURL returns the value of the "fork_url" field in the mutation.
func (m *ForkMutation) ForkURL() (r string, exists bool) {
	v := m.fork_url
	if v == nil {
		return
	}
	return *v, true
}

// OldForkURL returns the old "fork_url" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldForkURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForkURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForkURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForkURL: %w", err)
	}
	return oldValue.ForkURL, nil
}

// ResetForkURL resets all changes to the "fork_url" field.
func (m *ForkMutation) ResetForkURL() {
	m.fork_url = nil
}

// SetForkOwner sets the "fork_owner" field.
func (m *ForkMutation) SetForkOwner(s string) {
	m.fork_owner = &s
}

// ForkOwner returns the value of the "fork_owner" field in the mutation.
func (m *ForkMutation) ForkOwner() (r string, exists bool) {
	v := m.fork_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldForkOwner returns the old "fork_owner" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldForkOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForkOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForkOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForkOwner: %w", err)
	}
	return oldValue.ForkOwner, nil
}

// ResetForkOwner resets all changes to the "fork_owner" field.
func (m *ForkMutation) ResetForkOwner() {
	m.fork_owner = nil
}

// SetForkName sets the "fork_name" field.
func (m *ForkMutation) SetForkName(s string) {
	m.fork_name = &s
}

// ForkName returns the value of the "fork_name" field in the mutation.
func (m *ForkMutation) ForkName() (r string, exists bool) {
	v := m.fork_name
	if v == nil {
		return
	}
	return *v, true
}

// OldForkName returns the old "fork_name" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldForkName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForkName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForkName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForkName: %w", err)
	}
	return oldValue.ForkName, nil
}

// ResetForkName resets all changes to the "fork_name" field.
func (m *ForkMutation) ResetForkName() {
	m.fork_name = nil
}

// SetIsActive sets the "is_active" field.
func (m *ForkMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ForkMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ForkMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastSync sets the "last_sync" field.
func (m *ForkMutation) SetLastSync(t time.Time) {
	m.last_sync = &t
}

// LastSync returns the value of the "last_sync" field in the mutation.
func (m *ForkMutation) LastSync() (r time.Time, exists bool) {
	v := m.last_sync
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSync returns the old "last_sync" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldLastSync(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSync: %w", err)
	}
	return oldValue.LastSync, nil
}

// ClearLastSync clears the value of the "last_sync" field.
func (m *ForkMutation) ClearLastSync() {
	m.last_sync = nil
	m.clearedFields[fork.FieldLastSync] = struct{}{}
}

// LastSyncCleared returns if the "last_sync" field was cleared in this mutation.
func (m *ForkMutation) LastSyncCleared() bool {
	_, ok := m.clearedFields[fork.FieldLastSync]
	return ok
}

// ResetLastSync resets all changes to the "last_sync" field.
func (m *ForkMutation) ResetLastSync() {
	m.last_sync = nil
	delete(m.clearedFields, fork.FieldLastSync)
}

// SetCreatedAt sets the "created_at" field.
func (m *ForkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ForkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ForkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ForkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ForkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Fork entity.
// If the Fork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ForkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOriginalRepoID sets the "original_repo" edge to the Repository entity by id.
func (m *ForkMutation) SetOriginalRepoID(id string) {
	m.original_repo = &id
}

// ClearOriginalRepo clears the "original_repo" edge to the Repository entity.
func (m *ForkMutation) ClearOriginalRepo() {
	m.clearedoriginal_repo = true
}

// OriginalRepoCleared reports if the "original_repo" edge to the Repository entity was cleared.
func (m *ForkMutation) OriginalRepoCleared() bool {
	return m.clearedoriginal_repo
}

// OriginalRepoID returns the "original_repo" edge ID in the mutation.
func (m *ForkMutation) OriginalRepoID() (id string, exists bool) {
	if m.original_repo != nil {
		return *m.original_repo, true
	}
	return
}

// OriginalRepoIDs returns the "original_repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginalRepoID instead. It exists only for internal usage by the builders.
func (m *ForkMutation) OriginalRepoIDs() (ids []string) {
	if id := m.original_repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginalRepo resets all changes to the "original_repo" edge.
func (m *ForkMutation) ResetOriginalRepo() {
	m.original_repo = nil
	m.clearedoriginal_repo = false
}

// Where appends a list predicates to the ForkMutation builder.
func (m *ForkMutation) Where(ps ...predicate.Fork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ForkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ForkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ForkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ForkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fork).
func (m *ForkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ForkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.fork_url != nil {
		fields = append(fields, fork.FieldForkURL)
	}
	if m.fork_owner != nil {
		fields = append(fields, fork.FieldForkOwner)
	}
	if m.fork_name != nil {
		fields = append(fields, fork.FieldForkName)
	}
	if m.is_active != nil {
		fields = append(fields, fork.FieldIsActive)
	}
	if m.last_sync != nil {
		fields = append(fields, fork.FieldLastSync)
	}
	if m.created_at != nil {
		fields = append(fields, fork.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fork.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ForkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fork.FieldForkURL:
		return m.ForkURL()
	case fork.FieldForkOwner:
		return m.ForkOwner()
	case fork.FieldForkName:
		return m.ForkName()
	case fork.FieldIsActive:
		return m.IsActive()
	case fork.FieldLastSync:
		return m.LastSync()
	case fork.FieldCreatedAt:
		return m.CreatedAt()
	case fork.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ForkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fork.FieldForkURL:
		return m.OldForkURL(ctx)
	case fork.FieldForkOwner:
		return m.OldForkOwner(ctx)
	case fork.FieldForkName:
		return m.OldForkName(ctx)
	case fork.FieldIsActive:
		return m.OldIsActive(ctx)
	case fork.FieldLastSync:
		return m.OldLastSync(ctx)
	case fork.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fork.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Fork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fork.FieldForkURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForkURL(v)
		return nil
	case fork.FieldForkOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForkOwner(v)
		return nil
	case fork.FieldForkName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForkName(v)
		return nil
	case fork.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case fork.FieldLastSync:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSync(v)
		return nil
	case fork.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fork.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Fork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ForkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ForkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ForkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fork.FieldLastSync) {
		fields = append(fields, fork.FieldLastSync)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ForkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ForkMutation) ClearField(name string) error {
	switch name {
	case fork.FieldLastSync:
		m.ClearLastSync()
		return nil
	}
	return fmt.Errorf("unknown Fork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ForkMutation) ResetField(name string) error {
	switch name {
	case fork.FieldForkURL:
		m.ResetForkURL()
		return nil
	case fork.FieldForkOwner:
		m.ResetForkOwner()
		return nil
	case fork.FieldForkName:
		m.ResetForkName()
		return nil
	case fork.FieldIsActive:
		m.ResetIsActive()
		return nil
	case fork.FieldLastSync:
		m.ResetLastSync()
		return nil
	case fork.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fork.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Fork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ForkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.original_repo != nil {
		edges = append(edges, fork.EdgeOriginalRepo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ForkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fork.EdgeOriginalRepo:
		if id := m.original_repo; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ForkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ForkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ForkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoriginal_repo {
		edges = append(edges, fork.EdgeOriginalRepo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ForkMutation) EdgeCleared(name string) bool {
	switch name {
	case fork.EdgeOriginalRepo:
		return m.clearedoriginal_repo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ForkMutation) ClearEdge(name string) error {
	switch name {
	case fork.EdgeOriginalRepo:
		m.ClearOriginalRepo()
		return nil
	}
	return fmt.Errorf("unknown Fork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ForkMutation) ResetEdge(name string) error {
	switch name {
	case fork.EdgeOriginalRepo:
		m.ResetOriginalRepo()
		return nil
	}
	return fmt.Errorf("unknown Fork edge %s", name)
}

// LocalConfigMutation represents an operation that mutates the LocalConfig nodes in the graph.
type LocalConfigMutation struct {
	config
	op            Op
	typ           string
	id            *string
	key           *string
	value         *string
	_type         *localconfig.Type
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LocalConfig, error)
	predicates    []predicate.LocalConfig
}

var _ ent.Mutation = (*LocalConfigMutation)(nil)

// localconfigOption allows management of the mutation configuration using functional options.
type localconfigOption func(*LocalConfigMutation)

// newLocalConfigMutation creates new mutation for the LocalConfig entity.
func newLocalConfigMutation(c config, op Op, opts ...localconfigOption) *LocalConfigMutation {
	m := &LocalConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeLocalConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocalConfigID sets the ID field of the mutation.
func withLocalConfigID(id string) localconfigOption {
	return func(m *LocalConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *LocalConfig
		)
		m.oldValue = func(ctx context.Context) (*LocalConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocalConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocalConfig sets the old LocalConfig of the mutation.
func withLocalConfig(node *LocalConfig) localconfigOption {
	return func(m *LocalConfigMutation) {
		m.oldValue = func(context.Context) (*LocalConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocalConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocalConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocalConfig entities.
func (m *LocalConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocalConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocalConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocalConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *LocalConfigMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *LocalConfigMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the LocalConfig entity.
// If the LocalConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalConfigMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *LocalConfigMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *LocalConfigMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *LocalConfigMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the LocalConfig entity.
// If the LocalConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalConfigMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *LocalConfigMutation) ResetValue() {
	m.value = nil
}

// SetType sets the "type" field.
func (m *LocalConfigMutation) SetType(l localconfig.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LocalConfigMutation) GetType() (r localconfig.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the LocalConfig entity.
// If the LocalConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalConfigMutation) OldType(ctx context.Context) (v localconfig.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LocalConfigMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocalConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocalConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LocalConfig entity.
// If the LocalConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocalConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocalConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocalConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LocalConfig entity.
// If the LocalConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocalConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the LocalConfigMutation builder.
func (m *LocalConfigMutation) Where(ps ...predicate.LocalConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocalConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocalConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocalConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocalConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocalConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocalConfig).
func (m *LocalConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocalConfigMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.key != nil {
		fields = append(fields, localconfig.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, localconfig.FieldValue)
	}
	if m._type != nil {
		fields = append(fields, localconfig.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, localconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, localconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocalConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case localconfig.FieldKey:
		return m.Key()
	case localconfig.FieldValue:
		return m.Value()
	case localconfig.FieldType:
		return m.GetType()
	case localconfig.FieldCreatedAt:
		return m.CreatedAt()
	case localconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocalConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case localconfig.FieldKey:
		return m.OldKey(ctx)
	case localconfig.FieldValue:
		return m.OldValue(ctx)
	case localconfig.FieldType:
		return m.OldType(ctx)
	case localconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case localconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LocalConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocalConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case localconfig.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case localconfig.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case localconfig.FieldType:
		v, ok := value.(localconfig.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case localconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case localconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LocalConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocalConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocalConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocalConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LocalConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocalConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocalConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocalConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LocalConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocalConfigMutation) ResetField(name string) error {
	switch name {
	case localconfig.FieldKey:
		m.ResetKey()
		return nil
	case localconfig.FieldValue:
		m.ResetValue()
		return nil
	case localconfig.FieldType:
		m.ResetType()
		return nil
	case localconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case localconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LocalConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocalConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocalConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocalConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocalConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocalConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocalConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocalConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LocalConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocalConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LocalConfig edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	namespace                *string
	version                  *string
	description              *string
	author                   *string
	license                  *string
	homepage                 *string
	documentation            *string
	tags                     *[]string
	appendtags               []string
	categories               *[]string
	appendcategories         []string
	keywords                 *[]string
	appendkeywords           []string
	stability                *prompt.Stability
	maturity                 *prompt.Maturity
	forge_version            *string
	platforms                *[]string
	appendplatforms          []string
	spec                     *string
	spec_hash                *string
	is_installed             *bool
	install_path             *string
	installed_at             *time.Time
	commit_hash              *string
	branch                   *string
	created_at               *time.Time
	updated_at               *time.Time
	template_path            *string
	template_content         *string
	variables_schema         *map[string]interface{}
	prompt_type              *prompt.PromptType
	context_window           *int
	addcontext_window        *int
	default_variables        *map[string]interface{}
	required_variables       *[]string
	appendrequired_variables []string
	language                 *string
	supports_streaming       *bool
	model_preferences        *[]string
	appendmodel_preferences  []string
	temperature              *float64
	addtemperature           *float64
	max_tokens               *int
	addmax_tokens            *int
	stop_sequences           *[]string
	appendstop_sequences     []string
	clearedFields            map[string]struct{}
	repository               *string
	clearedrepository        bool
	dependencies             map[string]struct{}
	removeddependencies      map[string]struct{}
	cleareddependencies      bool
	done                     bool
	oldValue                 func(context.Context) (*Prompt, error)
	predicates               []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id string) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prompt entities.
func (m *PromptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PromptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptMutation) ResetName() {
	m.name = nil
}

// SetNamespace sets the "namespace" field.
func (m *PromptMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PromptMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PromptMutation) ResetNamespace() {
	m.namespace = nil
}

// SetVersion sets the "version" field.
func (m *PromptMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PromptMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PromptMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *PromptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptMutation) ResetDescription() {
	m.description = nil
}

// SetAuthor sets the "author" field.
func (m *PromptMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PromptMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *PromptMutation) ResetAuthor() {
	m.author = nil
}

// SetLicense sets the "license" field.
func (m *PromptMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *PromptMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ResetLicense resets all changes to the "license" field.
func (m *PromptMutation) ResetLicense() {
	m.license = nil
}

// SetHomepage sets the "homepage" field.
func (m *PromptMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *PromptMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldHomepage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *PromptMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[prompt.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *PromptMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[prompt.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *PromptMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, prompt.FieldHomepage)
}

// SetDocumentation sets the "documentation" field.
func (m *PromptMutation) SetDocumentation(s string) {
	m.documentation = &s
}

// Documentation returns the value of the "documentation" field in the mutation.
func (m *PromptMutation) Documentation() (r string, exists bool) {
	v := m.documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentation returns the old "documentation" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDocumentation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentation: %w", err)
	}
	return oldValue.Documentation, nil
}

// ClearDocumentation clears the value of the "documentation" field.
func (m *PromptMutation) ClearDocumentation() {
	m.documentation = nil
	m.clearedFields[prompt.FieldDocumentation] = struct{}{}
}

// DocumentationCleared returns if the "documentation" field was cleared in this mutation.
func (m *PromptMutation) DocumentationCleared() bool {
	_, ok := m.clearedFields[prompt.FieldDocumentation]
	return ok
}

// ResetDocumentation resets all changes to the "documentation" field.
func (m *PromptMutation) ResetDocumentation() {
	m.documentation = nil
	delete(m.clearedFields, prompt.FieldDocumentation)
}

// SetTags sets the "tags" field.
func (m *PromptMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *PromptMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *PromptMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *PromptMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *PromptMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[prompt.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *PromptMutation) TagsCleared() bool {
	_, ok := m.clearedFields[prompt.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *PromptMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, prompt.FieldTags)
}

// SetCategories sets the "categories" field.
func (m *PromptMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *PromptMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *PromptMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *PromptMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *PromptMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[prompt.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *PromptMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[prompt.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *PromptMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, prompt.FieldCategories)
}

// SetKeywords sets the "keywords" field.
func (m *PromptMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *PromptMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *PromptMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *PromptMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *PromptMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[prompt.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *PromptMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[prompt.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *PromptMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, prompt.FieldKeywords)
}

// SetStability sets the "stability" field.
func (m *PromptMutation) SetStability(pr prompt.Stability) {
	m.stability = &pr
}

// Stability returns the value of the "stability" field in the mutation.
func (m *PromptMutation) Stability() (r prompt.Stability, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldStability(ctx context.Context) (v prompt.Stability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *PromptMutation) ResetStability() {
	m.stability = nil
}

// SetMaturity sets the "maturity" field.
func (m *PromptMutation) SetMaturity(pr prompt.Maturity) {
	m.maturity = &pr
}

// Maturity returns the value of the "maturity" field in the mutation.
func (m *PromptMutation) Maturity() (r prompt.Maturity, exists bool) {
	v := m.maturity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturity returns the old "maturity" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldMaturity(ctx context.Context) (v prompt.Maturity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturity: %w", err)
	}
	return oldValue.Maturity, nil
}

// ResetMaturity resets all changes to the "maturity" field.
func (m *PromptMutation) ResetMaturity() {
	m.maturity = nil
}

// SetForgeVersion sets the "forge_version" field.
func (m *PromptMutation) SetForgeVersion(s string) {
	m.forge_version = &s
}

// ForgeVersion returns the value of the "forge_version" field in the mutation.
func (m *PromptMutation) ForgeVersion() (r string, exists bool) {
	v := m.forge_version
	if v == nil {
		return
	}
	return *v, true
}

// OldForgeVersion returns the old "forge_version" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldForgeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgeVersion: %w", err)
	}
	return oldValue.ForgeVersion, nil
}

// ResetForgeVersion resets all changes to the "forge_version" field.
func (m *PromptMutation) ResetForgeVersion() {
	m.forge_version = nil
}

// SetPlatforms sets the "platforms" field.
func (m *PromptMutation) SetPlatforms(s []string) {
	m.platforms = &s
	m.appendplatforms = nil
}

// Platforms returns the value of the "platforms" field in the mutation.
func (m *PromptMutation) Platforms() (r []string, exists bool) {
	v := m.platforms
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatforms returns the old "platforms" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldPlatforms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatforms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatforms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatforms: %w", err)
	}
	return oldValue.Platforms, nil
}

// AppendPlatforms adds s to the "platforms" field.
func (m *PromptMutation) AppendPlatforms(s []string) {
	m.appendplatforms = append(m.appendplatforms, s...)
}

// AppendedPlatforms returns the list of values that were appended to the "platforms" field in this mutation.
func (m *PromptMutation) AppendedPlatforms() ([]string, bool) {
	if len(m.appendplatforms) == 0 {
		return nil, false
	}
	return m.appendplatforms, true
}

// ClearPlatforms clears the value of the "platforms" field.
func (m *PromptMutation) ClearPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	m.clearedFields[prompt.FieldPlatforms] = struct{}{}
}

// PlatformsCleared returns if the "platforms" field was cleared in this mutation.
func (m *PromptMutation) PlatformsCleared() bool {
	_, ok := m.clearedFields[prompt.FieldPlatforms]
	return ok
}

// ResetPlatforms resets all changes to the "platforms" field.
func (m *PromptMutation) ResetPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	delete(m.clearedFields, prompt.FieldPlatforms)
}

// SetSpec sets the "spec" field.
func (m *PromptMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *PromptMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *PromptMutation) ResetSpec() {
	m.spec = nil
}

// SetSpecHash sets the "spec_hash" field.
func (m *PromptMutation) SetSpecHash(s string) {
	m.spec_hash = &s
}

// SpecHash returns the value of the "spec_hash" field in the mutation.
func (m *PromptMutation) SpecHash() (r string, exists bool) {
	v := m.spec_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecHash returns the old "spec_hash" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSpecHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecHash: %w", err)
	}
	return oldValue.SpecHash, nil
}

// ResetSpecHash resets all changes to the "spec_hash" field.
func (m *PromptMutation) ResetSpecHash() {
	m.spec_hash = nil
}

// SetIsInstalled sets the "is_installed" field.
func (m *PromptMutation) SetIsInstalled(b bool) {
	m.is_installed = &b
}

// IsInstalled returns the value of the "is_installed" field in the mutation.
func (m *PromptMutation) IsInstalled() (r bool, exists bool) {
	v := m.is_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstalled returns the old "is_installed" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldIsInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstalled: %w", err)
	}
	return oldValue.IsInstalled, nil
}

// ResetIsInstalled resets all changes to the "is_installed" field.
func (m *PromptMutation) ResetIsInstalled() {
	m.is_installed = nil
}

// SetInstallPath sets the "install_path" field.
func (m *PromptMutation) SetInstallPath(s string) {
	m.install_path = &s
}

// InstallPath returns the value of the "install_path" field in the mutation.
func (m *PromptMutation) InstallPath() (r string, exists bool) {
	v := m.install_path
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallPath returns the old "install_path" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldInstallPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallPath: %w", err)
	}
	return oldValue.InstallPath, nil
}

// ClearInstallPath clears the value of the "install_path" field.
func (m *PromptMutation) ClearInstallPath() {
	m.install_path = nil
	m.clearedFields[prompt.FieldInstallPath] = struct{}{}
}

// InstallPathCleared returns if the "install_path" field was cleared in this mutation.
func (m *PromptMutation) InstallPathCleared() bool {
	_, ok := m.clearedFields[prompt.FieldInstallPath]
	return ok
}

// ResetInstallPath resets all changes to the "install_path" field.
func (m *PromptMutation) ResetInstallPath() {
	m.install_path = nil
	delete(m.clearedFields, prompt.FieldInstallPath)
}

// SetInstalledAt sets the "installed_at" field.
func (m *PromptMutation) SetInstalledAt(t time.Time) {
	m.installed_at = &t
}

// InstalledAt returns the value of the "installed_at" field in the mutation.
func (m *PromptMutation) InstalledAt() (r time.Time, exists bool) {
	v := m.installed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledAt returns the old "installed_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldInstalledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledAt: %w", err)
	}
	return oldValue.InstalledAt, nil
}

// ClearInstalledAt clears the value of the "installed_at" field.
func (m *PromptMutation) ClearInstalledAt() {
	m.installed_at = nil
	m.clearedFields[prompt.FieldInstalledAt] = struct{}{}
}

// InstalledAtCleared returns if the "installed_at" field was cleared in this mutation.
func (m *PromptMutation) InstalledAtCleared() bool {
	_, ok := m.clearedFields[prompt.FieldInstalledAt]
	return ok
}

// ResetInstalledAt resets all changes to the "installed_at" field.
func (m *PromptMutation) ResetInstalledAt() {
	m.installed_at = nil
	delete(m.clearedFields, prompt.FieldInstalledAt)
}

// SetCommitHash sets the "commit_hash" field.
func (m *PromptMutation) SetCommitHash(s string) {
	m.commit_hash = &s
}

// CommitHash returns the value of the "commit_hash" field in the mutation.
func (m *PromptMutation) CommitHash() (r string, exists bool) {
	v := m.commit_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitHash returns the old "commit_hash" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCommitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitHash: %w", err)
	}
	return oldValue.CommitHash, nil
}

// ResetCommitHash resets all changes to the "commit_hash" field.
func (m *PromptMutation) ResetCommitHash() {
	m.commit_hash = nil
}

// SetBranch sets the "branch" field.
func (m *PromptMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *PromptMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *PromptMutation) ResetBranch() {
	m.branch = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTemplatePath sets the "template_path" field.
func (m *PromptMutation) SetTemplatePath(s string) {
	m.template_path = &s
}

// TemplatePath returns the value of the "template_path" field in the mutation.
func (m *PromptMutation) TemplatePath() (r string, exists bool) {
	v := m.template_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplatePath returns the old "template_path" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldTemplatePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplatePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplatePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplatePath: %w", err)
	}
	return oldValue.TemplatePath, nil
}

// ClearTemplatePath clears the value of the "template_path" field.
func (m *PromptMutation) ClearTemplatePath() {
	m.template_path = nil
	m.clearedFields[prompt.FieldTemplatePath] = struct{}{}
}

// TemplatePathCleared returns if the "template_path" field was cleared in this mutation.
func (m *PromptMutation) TemplatePathCleared() bool {
	_, ok := m.clearedFields[prompt.FieldTemplatePath]
	return ok
}

// ResetTemplatePath resets all changes to the "template_path" field.
func (m *PromptMutation) ResetTemplatePath() {
	m.template_path = nil
	delete(m.clearedFields, prompt.FieldTemplatePath)
}

// SetTemplateContent sets the "template_content" field.
func (m *PromptMutation) SetTemplateContent(s string) {
	m.template_content = &s
}

// TemplateContent returns the value of the "template_content" field in the mutation.
func (m *PromptMutation) TemplateContent() (r string, exists bool) {
	v := m.template_content
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateContent returns the old "template_content" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldTemplateContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateContent: %w", err)
	}
	return oldValue.TemplateContent, nil
}

// ClearTemplateContent clears the value of the "template_content" field.
func (m *PromptMutation) ClearTemplateContent() {
	m.template_content = nil
	m.clearedFields[prompt.FieldTemplateContent] = struct{}{}
}

// TemplateContentCleared returns if the "template_content" field was cleared in this mutation.
func (m *PromptMutation) TemplateContentCleared() bool {
	_, ok := m.clearedFields[prompt.FieldTemplateContent]
	return ok
}

// ResetTemplateContent resets all changes to the "template_content" field.
func (m *PromptMutation) ResetTemplateContent() {
	m.template_content = nil
	delete(m.clearedFields, prompt.FieldTemplateContent)
}

// SetVariablesSchema sets the "variables_schema" field.
func (m *PromptMutation) SetVariablesSchema(value map[string]interface{}) {
	m.variables_schema = &value
}

// VariablesSchema returns the value of the "variables_schema" field in the mutation.
func (m *PromptMutation) VariablesSchema() (r map[string]interface{}, exists bool) {
	v := m.variables_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldVariablesSchema returns the old "variables_schema" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldVariablesSchema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariablesSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariablesSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariablesSchema: %w", err)
	}
	return oldValue.VariablesSchema, nil
}

// ClearVariablesSchema clears the value of the "variables_schema" field.
func (m *PromptMutation) ClearVariablesSchema() {
	m.variables_schema = nil
	m.clearedFields[prompt.FieldVariablesSchema] = struct{}{}
}

// VariablesSchemaCleared returns if the "variables_schema" field was cleared in this mutation.
func (m *PromptMutation) VariablesSchemaCleared() bool {
	_, ok := m.clearedFields[prompt.FieldVariablesSchema]
	return ok
}

// ResetVariablesSchema resets all changes to the "variables_schema" field.
func (m *PromptMutation) ResetVariablesSchema() {
	m.variables_schema = nil
	delete(m.clearedFields, prompt.FieldVariablesSchema)
}

// SetPromptType sets the "prompt_type" field.
func (m *PromptMutation) SetPromptType(pt prompt.PromptType) {
	m.prompt_type = &pt
}

// PromptType returns the value of the "prompt_type" field in the mutation.
func (m *PromptMutation) PromptType() (r prompt.PromptType, exists bool) {
	v := m.prompt_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptType returns the old "prompt_type" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldPromptType(ctx context.Context) (v prompt.PromptType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptType: %w", err)
	}
	return oldValue.PromptType, nil
}

// ResetPromptType resets all changes to the "prompt_type" field.
func (m *PromptMutation) ResetPromptType() {
	m.prompt_type = nil
}

// SetContextWindow sets the "context_window" field.
func (m *PromptMutation) SetContextWindow(i int) {
	m.context_window = &i
	m.addcontext_window = nil
}

// ContextWindow returns the value of the "context_window" field in the mutation.
func (m *PromptMutation) ContextWindow() (r int, exists bool) {
	v := m.context_window
	if v == nil {
		return
	}
	return *v, true
}

// OldContextWindow returns the old "context_window" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldContextWindow(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextWindow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextWindow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextWindow: %w", err)
	}
	return oldValue.ContextWindow, nil
}

// AddContextWindow adds i to the "context_window" field.
func (m *PromptMutation) AddContextWindow(i int) {
	if m.addcontext_window != nil {
		*m.addcontext_window += i
	} else {
		m.addcontext_window = &i
	}
}

// AddedContextWindow returns the value that was added to the "context_window" field in this mutation.
func (m *PromptMutation) AddedContextWindow() (r int, exists bool) {
	v := m.addcontext_window
	if v == nil {
		return
	}
	return *v, true
}

// ClearContextWindow clears the value of the "context_window" field.
func (m *PromptMutation) ClearContextWindow() {
	m.context_window = nil
	m.addcontext_window = nil
	m.clearedFields[prompt.FieldContextWindow] = struct{}{}
}

// ContextWindowCleared returns if the "context_window" field was cleared in this mutation.
func (m *PromptMutation) ContextWindowCleared() bool {
	_, ok := m.clearedFields[prompt.FieldContextWindow]
	return ok
}

// ResetContextWindow resets all changes to the "context_window" field.
func (m *PromptMutation) ResetContextWindow() {
	m.context_window = nil
	m.addcontext_window = nil
	delete(m.clearedFields, prompt.FieldContextWindow)
}

// SetDefaultVariables sets the "default_variables" field.
func (m *PromptMutation) SetDefaultVariables(value map[string]interface{}) {
	m.default_variables = &value
}

// DefaultVariables returns the value of the "default_variables" field in the mutation.
func (m *PromptMutation) DefaultVariables() (r map[string]interface{}, exists bool) {
	v := m.default_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVariables returns the old "default_variables" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDefaultVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVariables: %w", err)
	}
	return oldValue.DefaultVariables, nil
}

// ClearDefaultVariables clears the value of the "default_variables" field.
func (m *PromptMutation) ClearDefaultVariables() {
	m.default_variables = nil
	m.clearedFields[prompt.FieldDefaultVariables] = struct{}{}
}

// DefaultVariablesCleared returns if the "default_variables" field was cleared in this mutation.
func (m *PromptMutation) DefaultVariablesCleared() bool {
	_, ok := m.clearedFields[prompt.FieldDefaultVariables]
	return ok
}

// ResetDefaultVariables resets all changes to the "default_variables" field.
func (m *PromptMutation) ResetDefaultVariables() {
	m.default_variables = nil
	delete(m.clearedFields, prompt.FieldDefaultVariables)
}

// SetRequiredVariables sets the "required_variables" field.
func (m *PromptMutation) SetRequiredVariables(s []string) {
	m.required_variables = &s
	m.appendrequired_variables = nil
}

// RequiredVariables returns the value of the "required_variables" field in the mutation.
func (m *PromptMutation) RequiredVariables() (r []string, exists bool) {
	v := m.required_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredVariables returns the old "required_variables" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldRequiredVariables(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredVariables: %w", err)
	}
	return oldValue.RequiredVariables, nil
}

// AppendRequiredVariables adds s to the "required_variables" field.
func (m *PromptMutation) AppendRequiredVariables(s []string) {
	m.appendrequired_variables = append(m.appendrequired_variables, s...)
}

// AppendedRequiredVariables returns the list of values that were appended to the "required_variables" field in this mutation.
func (m *PromptMutation) AppendedRequiredVariables() ([]string, bool) {
	if len(m.appendrequired_variables) == 0 {
		return nil, false
	}
	return m.appendrequired_variables, true
}

// ClearRequiredVariables clears the value of the "required_variables" field.
func (m *PromptMutation) ClearRequiredVariables() {
	m.required_variables = nil
	m.appendrequired_variables = nil
	m.clearedFields[prompt.FieldRequiredVariables] = struct{}{}
}

// RequiredVariablesCleared returns if the "required_variables" field was cleared in this mutation.
func (m *PromptMutation) RequiredVariablesCleared() bool {
	_, ok := m.clearedFields[prompt.FieldRequiredVariables]
	return ok
}

// ResetRequiredVariables resets all changes to the "required_variables" field.
func (m *PromptMutation) ResetRequiredVariables() {
	m.required_variables = nil
	m.appendrequired_variables = nil
	delete(m.clearedFields, prompt.FieldRequiredVariables)
}

// SetLanguage sets the "language" field.
func (m *PromptMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *PromptMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *PromptMutation) ResetLanguage() {
	m.language = nil
}

// SetSupportsStreaming sets the "supports_streaming" field.
func (m *PromptMutation) SetSupportsStreaming(b bool) {
	m.supports_streaming = &b
}

// SupportsStreaming returns the value of the "supports_streaming" field in the mutation.
func (m *PromptMutation) SupportsStreaming() (r bool, exists bool) {
	v := m.supports_streaming
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsStreaming returns the old "supports_streaming" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSupportsStreaming(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsStreaming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsStreaming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsStreaming: %w", err)
	}
	return oldValue.SupportsStreaming, nil
}

// ResetSupportsStreaming resets all changes to the "supports_streaming" field.
func (m *PromptMutation) ResetSupportsStreaming() {
	m.supports_streaming = nil
}

// SetModelPreferences sets the "model_preferences" field.
func (m *PromptMutation) SetModelPreferences(s []string) {
	m.model_preferences = &s
	m.appendmodel_preferences = nil
}

// ModelPreferences returns the value of the "model_preferences" field in the mutation.
func (m *PromptMutation) ModelPreferences() (r []string, exists bool) {
	v := m.model_preferences
	if v == nil {
		return
	}
	return *v, true
}

// OldModelPreferences returns the old "model_preferences" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldModelPreferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelPreferences: %w", err)
	}
	return oldValue.ModelPreferences, nil
}

// AppendModelPreferences adds s to the "model_preferences" field.
func (m *PromptMutation) AppendModelPreferences(s []string) {
	m.appendmodel_preferences = append(m.appendmodel_preferences, s...)
}

// AppendedModelPreferences returns the list of values that were appended to the "model_preferences" field in this mutation.
func (m *PromptMutation) AppendedModelPreferences() ([]string, bool) {
	if len(m.appendmodel_preferences) == 0 {
		return nil, false
	}
	return m.appendmodel_preferences, true
}

// ClearModelPreferences clears the value of the "model_preferences" field.
func (m *PromptMutation) ClearModelPreferences() {
	m.model_preferences = nil
	m.appendmodel_preferences = nil
	m.clearedFields[prompt.FieldModelPreferences] = struct{}{}
}

// ModelPreferencesCleared returns if the "model_preferences" field was cleared in this mutation.
func (m *PromptMutation) ModelPreferencesCleared() bool {
	_, ok := m.clearedFields[prompt.FieldModelPreferences]
	return ok
}

// ResetModelPreferences resets all changes to the "model_preferences" field.
func (m *PromptMutation) ResetModelPreferences() {
	m.model_preferences = nil
	m.appendmodel_preferences = nil
	delete(m.clearedFields, prompt.FieldModelPreferences)
}

// SetTemperature sets the "temperature" field.
func (m *PromptMutation) SetTemperature(f float64) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *PromptMutation) Temperature() (r float64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *PromptMutation) AddTemperature(f float64) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *PromptMutation) AddedTemperature() (r float64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemperature clears the value of the "temperature" field.
func (m *PromptMutation) ClearTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	m.clearedFields[prompt.FieldTemperature] = struct{}{}
}

// TemperatureCleared returns if the "temperature" field was cleared in this mutation.
func (m *PromptMutation) TemperatureCleared() bool {
	_, ok := m.clearedFields[prompt.FieldTemperature]
	return ok
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *PromptMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	delete(m.clearedFields, prompt.FieldTemperature)
}

// SetMaxTokens sets the "max_tokens" field.
func (m *PromptMutation) SetMaxTokens(i int) {
	m.max_tokens = &i
	m.addmax_tokens = nil
}

// MaxTokens returns the value of the "max_tokens" field in the mutation.
func (m *PromptMutation) MaxTokens() (r int, exists bool) {
	v := m.max_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTokens returns the old "max_tokens" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldMaxTokens(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTokens: %w", err)
	}
	return oldValue.MaxTokens, nil
}

// AddMaxTokens adds i to the "max_tokens" field.
func (m *PromptMutation) AddMaxTokens(i int) {
	if m.addmax_tokens != nil {
		*m.addmax_tokens += i
	} else {
		m.addmax_tokens = &i
	}
}

// AddedMaxTokens returns the value that was added to the "max_tokens" field in this mutation.
func (m *PromptMutation) AddedMaxTokens() (r int, exists bool) {
	v := m.addmax_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTokens clears the value of the "max_tokens" field.
func (m *PromptMutation) ClearMaxTokens() {
	m.max_tokens = nil
	m.addmax_tokens = nil
	m.clearedFields[prompt.FieldMaxTokens] = struct{}{}
}

// MaxTokensCleared returns if the "max_tokens" field was cleared in this mutation.
func (m *PromptMutation) MaxTokensCleared() bool {
	_, ok := m.clearedFields[prompt.FieldMaxTokens]
	return ok
}

// ResetMaxTokens resets all changes to the "max_tokens" field.
func (m *PromptMutation) ResetMaxTokens() {
	m.max_tokens = nil
	m.addmax_tokens = nil
	delete(m.clearedFields, prompt.FieldMaxTokens)
}

// SetStopSequences sets the "stop_sequences" field.
func (m *PromptMutation) SetStopSequences(s []string) {
	m.stop_sequences = &s
	m.appendstop_sequences = nil
}

// StopSequences returns the value of the "stop_sequences" field in the mutation.
func (m *PromptMutation) StopSequences() (r []string, exists bool) {
	v := m.stop_sequences
	if v == nil {
		return
	}
	return *v, true
}

// OldStopSequences returns the old "stop_sequences" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldStopSequences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopSequences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopSequences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopSequences: %w", err)
	}
	return oldValue.StopSequences, nil
}

// AppendStopSequences adds s to the "stop_sequences" field.
func (m *PromptMutation) AppendStopSequences(s []string) {
	m.appendstop_sequences = append(m.appendstop_sequences, s...)
}

// AppendedStopSequences returns the list of values that were appended to the "stop_sequences" field in this mutation.
func (m *PromptMutation) AppendedStopSequences() ([]string, bool) {
	if len(m.appendstop_sequences) == 0 {
		return nil, false
	}
	return m.appendstop_sequences, true
}

// ClearStopSequences clears the value of the "stop_sequences" field.
func (m *PromptMutation) ClearStopSequences() {
	m.stop_sequences = nil
	m.appendstop_sequences = nil
	m.clearedFields[prompt.FieldStopSequences] = struct{}{}
}

// StopSequencesCleared returns if the "stop_sequences" field was cleared in this mutation.
func (m *PromptMutation) StopSequencesCleared() bool {
	_, ok := m.clearedFields[prompt.FieldStopSequences]
	return ok
}

// ResetStopSequences resets all changes to the "stop_sequences" field.
func (m *PromptMutation) ResetStopSequences() {
	m.stop_sequences = nil
	m.appendstop_sequences = nil
	delete(m.clearedFields, prompt.FieldStopSequences)
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *PromptMutation) SetRepositoryID(id string) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *PromptMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *PromptMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *PromptMutation) RepositoryID() (id string, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *PromptMutation) RepositoryIDs() (ids []string) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *PromptMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// AddDependencyIDs adds the "dependencies" edge to the PromptDependency entity by ids.
func (m *PromptMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the PromptDependency entity.
func (m *PromptMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the PromptDependency entity was cleared.
func (m *PromptMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the PromptDependency entity by IDs.
func (m *PromptMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the PromptDependency entity.
func (m *PromptMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *PromptMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *PromptMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m.name != nil {
		fields = append(fields, prompt.FieldName)
	}
	if m.namespace != nil {
		fields = append(fields, prompt.FieldNamespace)
	}
	if m.version != nil {
		fields = append(fields, prompt.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, prompt.FieldDescription)
	}
	if m.author != nil {
		fields = append(fields, prompt.FieldAuthor)
	}
	if m.license != nil {
		fields = append(fields, prompt.FieldLicense)
	}
	if m.homepage != nil {
		fields = append(fields, prompt.FieldHomepage)
	}
	if m.documentation != nil {
		fields = append(fields, prompt.FieldDocumentation)
	}
	if m.tags != nil {
		fields = append(fields, prompt.FieldTags)
	}
	if m.categories != nil {
		fields = append(fields, prompt.FieldCategories)
	}
	if m.keywords != nil {
		fields = append(fields, prompt.FieldKeywords)
	}
	if m.stability != nil {
		fields = append(fields, prompt.FieldStability)
	}
	if m.maturity != nil {
		fields = append(fields, prompt.FieldMaturity)
	}
	if m.forge_version != nil {
		fields = append(fields, prompt.FieldForgeVersion)
	}
	if m.platforms != nil {
		fields = append(fields, prompt.FieldPlatforms)
	}
	if m.spec != nil {
		fields = append(fields, prompt.FieldSpec)
	}
	if m.spec_hash != nil {
		fields = append(fields, prompt.FieldSpecHash)
	}
	if m.is_installed != nil {
		fields = append(fields, prompt.FieldIsInstalled)
	}
	if m.install_path != nil {
		fields = append(fields, prompt.FieldInstallPath)
	}
	if m.installed_at != nil {
		fields = append(fields, prompt.FieldInstalledAt)
	}
	if m.commit_hash != nil {
		fields = append(fields, prompt.FieldCommitHash)
	}
	if m.branch != nil {
		fields = append(fields, prompt.FieldBranch)
	}
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	if m.template_path != nil {
		fields = append(fields, prompt.FieldTemplatePath)
	}
	if m.template_content != nil {
		fields = append(fields, prompt.FieldTemplateContent)
	}
	if m.variables_schema != nil {
		fields = append(fields, prompt.FieldVariablesSchema)
	}
	if m.prompt_type != nil {
		fields = append(fields, prompt.FieldPromptType)
	}
	if m.context_window != nil {
		fields = append(fields, prompt.FieldContextWindow)
	}
	if m.default_variables != nil {
		fields = append(fields, prompt.FieldDefaultVariables)
	}
	if m.required_variables != nil {
		fields = append(fields, prompt.FieldRequiredVariables)
	}
	if m.language != nil {
		fields = append(fields, prompt.FieldLanguage)
	}
	if m.supports_streaming != nil {
		fields = append(fields, prompt.FieldSupportsStreaming)
	}
	if m.model_preferences != nil {
		fields = append(fields, prompt.FieldModelPreferences)
	}
	if m.temperature != nil {
		fields = append(fields, prompt.FieldTemperature)
	}
	if m.max_tokens != nil {
		fields = append(fields, prompt.FieldMaxTokens)
	}
	if m.stop_sequences != nil {
		fields = append(fields, prompt.FieldStopSequences)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldName:
		return m.Name()
	case prompt.FieldNamespace:
		return m.Namespace()
	case prompt.FieldVersion:
		return m.Version()
	case prompt.FieldDescription:
		return m.Description()
	case prompt.FieldAuthor:
		return m.Author()
	case prompt.FieldLicense:
		return m.License()
	case prompt.FieldHomepage:
		return m.Homepage()
	case prompt.FieldDocumentation:
		return m.Documentation()
	case prompt.FieldTags:
		return m.Tags()
	case prompt.FieldCategories:
		return m.Categories()
	case prompt.FieldKeywords:
		return m.Keywords()
	case prompt.FieldStability:
		return m.Stability()
	case prompt.FieldMaturity:
		return m.Maturity()
	case prompt.FieldForgeVersion:
		return m.ForgeVersion()
	case prompt.FieldPlatforms:
		return m.Platforms()
	case prompt.FieldSpec:
		return m.Spec()
	case prompt.FieldSpecHash:
		return m.SpecHash()
	case prompt.FieldIsInstalled:
		return m.IsInstalled()
	case prompt.FieldInstallPath:
		return m.InstallPath()
	case prompt.FieldInstalledAt:
		return m.InstalledAt()
	case prompt.FieldCommitHash:
		return m.CommitHash()
	case prompt.FieldBranch:
		return m.Branch()
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompt.FieldTemplatePath:
		return m.TemplatePath()
	case prompt.FieldTemplateContent:
		return m.TemplateContent()
	case prompt.FieldVariablesSchema:
		return m.VariablesSchema()
	case prompt.FieldPromptType:
		return m.PromptType()
	case prompt.FieldContextWindow:
		return m.ContextWindow()
	case prompt.FieldDefaultVariables:
		return m.DefaultVariables()
	case prompt.FieldRequiredVariables:
		return m.RequiredVariables()
	case prompt.FieldLanguage:
		return m.Language()
	case prompt.FieldSupportsStreaming:
		return m.SupportsStreaming()
	case prompt.FieldModelPreferences:
		return m.ModelPreferences()
	case prompt.FieldTemperature:
		return m.Temperature()
	case prompt.FieldMaxTokens:
		return m.MaxTokens()
	case prompt.FieldStopSequences:
		return m.StopSequences()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldName:
		return m.OldName(ctx)
	case prompt.FieldNamespace:
		return m.OldNamespace(ctx)
	case prompt.FieldVersion:
		return m.OldVersion(ctx)
	case prompt.FieldDescription:
		return m.OldDescription(ctx)
	case prompt.FieldAuthor:
		return m.OldAuthor(ctx)
	case prompt.FieldLicense:
		return m.OldLicense(ctx)
	case prompt.FieldHomepage:
		return m.OldHomepage(ctx)
	case prompt.FieldDocumentation:
		return m.OldDocumentation(ctx)
	case prompt.FieldTags:
		return m.OldTags(ctx)
	case prompt.FieldCategories:
		return m.OldCategories(ctx)
	case prompt.FieldKeywords:
		return m.OldKeywords(ctx)
	case prompt.FieldStability:
		return m.OldStability(ctx)
	case prompt.FieldMaturity:
		return m.OldMaturity(ctx)
	case prompt.FieldForgeVersion:
		return m.OldForgeVersion(ctx)
	case prompt.FieldPlatforms:
		return m.OldPlatforms(ctx)
	case prompt.FieldSpec:
		return m.OldSpec(ctx)
	case prompt.FieldSpecHash:
		return m.OldSpecHash(ctx)
	case prompt.FieldIsInstalled:
		return m.OldIsInstalled(ctx)
	case prompt.FieldInstallPath:
		return m.OldInstallPath(ctx)
	case prompt.FieldInstalledAt:
		return m.OldInstalledAt(ctx)
	case prompt.FieldCommitHash:
		return m.OldCommitHash(ctx)
	case prompt.FieldBranch:
		return m.OldBranch(ctx)
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompt.FieldTemplatePath:
		return m.OldTemplatePath(ctx)
	case prompt.FieldTemplateContent:
		return m.OldTemplateContent(ctx)
	case prompt.FieldVariablesSchema:
		return m.OldVariablesSchema(ctx)
	case prompt.FieldPromptType:
		return m.OldPromptType(ctx)
	case prompt.FieldContextWindow:
		return m.OldContextWindow(ctx)
	case prompt.FieldDefaultVariables:
		return m.OldDefaultVariables(ctx)
	case prompt.FieldRequiredVariables:
		return m.OldRequiredVariables(ctx)
	case prompt.FieldLanguage:
		return m.OldLanguage(ctx)
	case prompt.FieldSupportsStreaming:
		return m.OldSupportsStreaming(ctx)
	case prompt.FieldModelPreferences:
		return m.OldModelPreferences(ctx)
	case prompt.FieldTemperature:
		return m.OldTemperature(ctx)
	case prompt.FieldMaxTokens:
		return m.OldMaxTokens(ctx)
	case prompt.FieldStopSequences:
		return m.OldStopSequences(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompt.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case prompt.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case prompt.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompt.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case prompt.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case prompt.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case prompt.FieldDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentation(v)
		return nil
	case prompt.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case prompt.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case prompt.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case prompt.FieldStability:
		v, ok := value.(prompt.Stability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case prompt.FieldMaturity:
		v, ok := value.(prompt.Maturity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturity(v)
		return nil
	case prompt.FieldForgeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgeVersion(v)
		return nil
	case prompt.FieldPlatforms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatforms(v)
		return nil
	case prompt.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case prompt.FieldSpecHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecHash(v)
		return nil
	case prompt.FieldIsInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstalled(v)
		return nil
	case prompt.FieldInstallPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallPath(v)
		return nil
	case prompt.FieldInstalledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledAt(v)
		return nil
	case prompt.FieldCommitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitHash(v)
		return nil
	case prompt.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompt.FieldTemplatePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplatePath(v)
		return nil
	case prompt.FieldTemplateContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateContent(v)
		return nil
	case prompt.FieldVariablesSchema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariablesSchema(v)
		return nil
	case prompt.FieldPromptType:
		v, ok := value.(prompt.PromptType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptType(v)
		return nil
	case prompt.FieldContextWindow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextWindow(v)
		return nil
	case prompt.FieldDefaultVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVariables(v)
		return nil
	case prompt.FieldRequiredVariables:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredVariables(v)
		return nil
	case prompt.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case prompt.FieldSupportsStreaming:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsStreaming(v)
		return nil
	case prompt.FieldModelPreferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelPreferences(v)
		return nil
	case prompt.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case prompt.FieldMaxTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTokens(v)
		return nil
	case prompt.FieldStopSequences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopSequences(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	var fields []string
	if m.addcontext_window != nil {
		fields = append(fields, prompt.FieldContextWindow)
	}
	if m.addtemperature != nil {
		fields = append(fields, prompt.FieldTemperature)
	}
	if m.addmax_tokens != nil {
		fields = append(fields, prompt.FieldMaxTokens)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldContextWindow:
		return m.AddedContextWindow()
	case prompt.FieldTemperature:
		return m.AddedTemperature()
	case prompt.FieldMaxTokens:
		return m.AddedMaxTokens()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldContextWindow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContextWindow(v)
		return nil
	case prompt.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case prompt.FieldMaxTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTokens(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prompt.FieldHomepage) {
		fields = append(fields, prompt.FieldHomepage)
	}
	if m.FieldCleared(prompt.FieldDocumentation) {
		fields = append(fields, prompt.FieldDocumentation)
	}
	if m.FieldCleared(prompt.FieldTags) {
		fields = append(fields, prompt.FieldTags)
	}
	if m.FieldCleared(prompt.FieldCategories) {
		fields = append(fields, prompt.FieldCategories)
	}
	if m.FieldCleared(prompt.FieldKeywords) {
		fields = append(fields, prompt.FieldKeywords)
	}
	if m.FieldCleared(prompt.FieldPlatforms) {
		fields = append(fields, prompt.FieldPlatforms)
	}
	if m.FieldCleared(prompt.FieldInstallPath) {
		fields = append(fields, prompt.FieldInstallPath)
	}
	if m.FieldCleared(prompt.FieldInstalledAt) {
		fields = append(fields, prompt.FieldInstalledAt)
	}
	if m.FieldCleared(prompt.FieldTemplatePath) {
		fields = append(fields, prompt.FieldTemplatePath)
	}
	if m.FieldCleared(prompt.FieldTemplateContent) {
		fields = append(fields, prompt.FieldTemplateContent)
	}
	if m.FieldCleared(prompt.FieldVariablesSchema) {
		fields = append(fields, prompt.FieldVariablesSchema)
	}
	if m.FieldCleared(prompt.FieldContextWindow) {
		fields = append(fields, prompt.FieldContextWindow)
	}
	if m.FieldCleared(prompt.FieldDefaultVariables) {
		fields = append(fields, prompt.FieldDefaultVariables)
	}
	if m.FieldCleared(prompt.FieldRequiredVariables) {
		fields = append(fields, prompt.FieldRequiredVariables)
	}
	if m.FieldCleared(prompt.FieldModelPreferences) {
		fields = append(fields, prompt.FieldModelPreferences)
	}
	if m.FieldCleared(prompt.FieldTemperature) {
		fields = append(fields, prompt.FieldTemperature)
	}
	if m.FieldCleared(prompt.FieldMaxTokens) {
		fields = append(fields, prompt.FieldMaxTokens)
	}
	if m.FieldCleared(prompt.FieldStopSequences) {
		fields = append(fields, prompt.FieldStopSequences)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	switch name {
	case prompt.FieldHomepage:
		m.ClearHomepage()
		return nil
	case prompt.FieldDocumentation:
		m.ClearDocumentation()
		return nil
	case prompt.FieldTags:
		m.ClearTags()
		return nil
	case prompt.FieldCategories:
		m.ClearCategories()
		return nil
	case prompt.FieldKeywords:
		m.ClearKeywords()
		return nil
	case prompt.FieldPlatforms:
		m.ClearPlatforms()
		return nil
	case prompt.FieldInstallPath:
		m.ClearInstallPath()
		return nil
	case prompt.FieldInstalledAt:
		m.ClearInstalledAt()
		return nil
	case prompt.FieldTemplatePath:
		m.ClearTemplatePath()
		return nil
	case prompt.FieldTemplateContent:
		m.ClearTemplateContent()
		return nil
	case prompt.FieldVariablesSchema:
		m.ClearVariablesSchema()
		return nil
	case prompt.FieldContextWindow:
		m.ClearContextWindow()
		return nil
	case prompt.FieldDefaultVariables:
		m.ClearDefaultVariables()
		return nil
	case prompt.FieldRequiredVariables:
		m.ClearRequiredVariables()
		return nil
	case prompt.FieldModelPreferences:
		m.ClearModelPreferences()
		return nil
	case prompt.FieldTemperature:
		m.ClearTemperature()
		return nil
	case prompt.FieldMaxTokens:
		m.ClearMaxTokens()
		return nil
	case prompt.FieldStopSequences:
		m.ClearStopSequences()
		return nil
	}
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldName:
		m.ResetName()
		return nil
	case prompt.FieldNamespace:
		m.ResetNamespace()
		return nil
	case prompt.FieldVersion:
		m.ResetVersion()
		return nil
	case prompt.FieldDescription:
		m.ResetDescription()
		return nil
	case prompt.FieldAuthor:
		m.ResetAuthor()
		return nil
	case prompt.FieldLicense:
		m.ResetLicense()
		return nil
	case prompt.FieldHomepage:
		m.ResetHomepage()
		return nil
	case prompt.FieldDocumentation:
		m.ResetDocumentation()
		return nil
	case prompt.FieldTags:
		m.ResetTags()
		return nil
	case prompt.FieldCategories:
		m.ResetCategories()
		return nil
	case prompt.FieldKeywords:
		m.ResetKeywords()
		return nil
	case prompt.FieldStability:
		m.ResetStability()
		return nil
	case prompt.FieldMaturity:
		m.ResetMaturity()
		return nil
	case prompt.FieldForgeVersion:
		m.ResetForgeVersion()
		return nil
	case prompt.FieldPlatforms:
		m.ResetPlatforms()
		return nil
	case prompt.FieldSpec:
		m.ResetSpec()
		return nil
	case prompt.FieldSpecHash:
		m.ResetSpecHash()
		return nil
	case prompt.FieldIsInstalled:
		m.ResetIsInstalled()
		return nil
	case prompt.FieldInstallPath:
		m.ResetInstallPath()
		return nil
	case prompt.FieldInstalledAt:
		m.ResetInstalledAt()
		return nil
	case prompt.FieldCommitHash:
		m.ResetCommitHash()
		return nil
	case prompt.FieldBranch:
		m.ResetBranch()
		return nil
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompt.FieldTemplatePath:
		m.ResetTemplatePath()
		return nil
	case prompt.FieldTemplateContent:
		m.ResetTemplateContent()
		return nil
	case prompt.FieldVariablesSchema:
		m.ResetVariablesSchema()
		return nil
	case prompt.FieldPromptType:
		m.ResetPromptType()
		return nil
	case prompt.FieldContextWindow:
		m.ResetContextWindow()
		return nil
	case prompt.FieldDefaultVariables:
		m.ResetDefaultVariables()
		return nil
	case prompt.FieldRequiredVariables:
		m.ResetRequiredVariables()
		return nil
	case prompt.FieldLanguage:
		m.ResetLanguage()
		return nil
	case prompt.FieldSupportsStreaming:
		m.ResetSupportsStreaming()
		return nil
	case prompt.FieldModelPreferences:
		m.ResetModelPreferences()
		return nil
	case prompt.FieldTemperature:
		m.ResetTemperature()
		return nil
	case prompt.FieldMaxTokens:
		m.ResetMaxTokens()
		return nil
	case prompt.FieldStopSequences:
		m.ResetStopSequences()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repository != nil {
		edges = append(edges, prompt.EdgeRepository)
	}
	if m.dependencies != nil {
		edges = append(edges, prompt.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	case prompt.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddependencies != nil {
		edges = append(edges, prompt.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepository {
		edges = append(edges, prompt.EdgeRepository)
	}
	if m.cleareddependencies {
		edges = append(edges, prompt.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeRepository:
		return m.clearedrepository
	case prompt.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	case prompt.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeRepository:
		m.ResetRepository()
		return nil
	case prompt.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// PromptDependencyMutation represents an operation that mutates the PromptDependency nodes in the graph.
type PromptDependencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *promptdependency.Type
	dependency_name    *string
	dependency_version *string
	version_range      *string
	is_required        *bool
	condition          *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	prompt             *string
	clearedprompt      bool
	done               bool
	oldValue           func(context.Context) (*PromptDependency, error)
	predicates         []predicate.PromptDependency
}

var _ ent.Mutation = (*PromptDependencyMutation)(nil)

// promptdependencyOption allows management of the mutation configuration using functional options.
type promptdependencyOption func(*PromptDependencyMutation)

// newPromptDependencyMutation creates new mutation for the PromptDependency entity.
func newPromptDependencyMutation(c config, op Op, opts ...promptdependencyOption) *PromptDependencyMutation {
	m := &PromptDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypePromptDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptDependencyID sets the ID field of the mutation.
func withPromptDependencyID(id string) promptdependencyOption {
	return func(m *PromptDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *PromptDependency
		)
		m.oldValue = func(ctx context.Context) (*PromptDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromptDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromptDependency sets the old PromptDependency of the mutation.
func withPromptDependency(node *PromptDependency) promptdependencyOption {
	return func(m *PromptDependencyMutation) {
		m.oldValue = func(context.Context) (*PromptDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PromptDependency entities.
func (m *PromptDependencyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptDependencyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptDependencyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromptDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *PromptDependencyMutation) SetType(pr promptdependency.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromptDependencyMutation) GetType() (r promptdependency.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldType(ctx context.Context) (v promptdependency.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PromptDependencyMutation) ResetType() {
	m._type = nil
}

// SetDependencyName sets the "dependency_name" field.
func (m *PromptDependencyMutation) SetDependencyName(s string) {
	m.dependency_name = &s
}

// DependencyName returns the value of the "dependency_name" field in the mutation.
func (m *PromptDependencyMutation) DependencyName() (r string, exists bool) {
	v := m.dependency_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyName returns the old "dependency_name" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldDependencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyName: %w", err)
	}
	return oldValue.DependencyName, nil
}

// ResetDependencyName resets all changes to the "dependency_name" field.
func (m *PromptDependencyMutation) ResetDependencyName() {
	m.dependency_name = nil
}

// SetDependencyVersion sets the "dependency_version" field.
func (m *PromptDependencyMutation) SetDependencyVersion(s string) {
	m.dependency_version = &s
}

// DependencyVersion returns the value of the "dependency_version" field in the mutation.
func (m *PromptDependencyMutation) DependencyVersion() (r string, exists bool) {
	v := m.dependency_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyVersion returns the old "dependency_version" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldDependencyVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyVersion: %w", err)
	}
	return oldValue.DependencyVersion, nil
}

// ResetDependencyVersion resets all changes to the "dependency_version" field.
func (m *PromptDependencyMutation) ResetDependencyVersion() {
	m.dependency_version = nil
}

// SetVersionRange sets the "version_range" field.
func (m *PromptDependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *PromptDependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *PromptDependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetIsRequired sets the "is_required" field.
func (m *PromptDependencyMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *PromptDependencyMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *PromptDependencyMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetCondition sets the "condition" field.
func (m *PromptDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *PromptDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldCondition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of the "condition" field.
func (m *PromptDependencyMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[promptdependency.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *PromptDependencyMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[promptdependency.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *PromptDependencyMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, promptdependency.FieldCondition)
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromptDependency entity.
// If the PromptDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPromptID sets the "prompt" edge to the Prompt entity by id.
func (m *PromptDependencyMutation) SetPromptID(id string) {
	m.prompt = &id
}

// ClearPrompt clears the "prompt" edge to the Prompt entity.
func (m *PromptDependencyMutation) ClearPrompt() {
	m.clearedprompt = true
}

// PromptCleared reports if the "prompt" edge to the Prompt entity was cleared.
func (m *PromptDependencyMutation) PromptCleared() bool {
	return m.clearedprompt
}

// PromptID returns the "prompt" edge ID in the mutation.
func (m *PromptDependencyMutation) PromptID() (id string, exists bool) {
	if m.prompt != nil {
		return *m.prompt, true
	}
	return
}

// PromptIDs returns the "prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromptID instead. It exists only for internal usage by the builders.
func (m *PromptDependencyMutation) PromptIDs() (ids []string) {
	if id := m.prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrompt resets all changes to the "prompt" edge.
func (m *PromptDependencyMutation) ResetPrompt() {
	m.prompt = nil
	m.clearedprompt = false
}

// Where appends a list predicates to the PromptDependencyMutation builder.
func (m *PromptDependencyMutation) Where(ps ...predicate.PromptDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromptDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromptDependency).
func (m *PromptDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, promptdependency.FieldType)
	}
	if m.dependency_name != nil {
		fields = append(fields, promptdependency.FieldDependencyName)
	}
	if m.dependency_version != nil {
		fields = append(fields, promptdependency.FieldDependencyVersion)
	}
	if m.version_range != nil {
		fields = append(fields, promptdependency.FieldVersionRange)
	}
	if m.is_required != nil {
		fields = append(fields, promptdependency.FieldIsRequired)
	}
	if m.condition != nil {
		fields = append(fields, promptdependency.FieldCondition)
	}
	if m.created_at != nil {
		fields = append(fields, promptdependency.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promptdependency.FieldType:
		return m.GetType()
	case promptdependency.FieldDependencyName:
		return m.DependencyName()
	case promptdependency.FieldDependencyVersion:
		return m.DependencyVersion()
	case promptdependency.FieldVersionRange:
		return m.VersionRange()
	case promptdependency.FieldIsRequired:
		return m.IsRequired()
	case promptdependency.FieldCondition:
		return m.Condition()
	case promptdependency.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promptdependency.FieldType:
		return m.OldType(ctx)
	case promptdependency.FieldDependencyName:
		return m.OldDependencyName(ctx)
	case promptdependency.FieldDependencyVersion:
		return m.OldDependencyVersion(ctx)
	case promptdependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case promptdependency.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case promptdependency.FieldCondition:
		return m.OldCondition(ctx)
	case promptdependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromptDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promptdependency.FieldType:
		v, ok := value.(promptdependency.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case promptdependency.FieldDependencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyName(v)
		return nil
	case promptdependency.FieldDependencyVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyVersion(v)
		return nil
	case promptdependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case promptdependency.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case promptdependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case promptdependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromptDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromptDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promptdependency.FieldCondition) {
		fields = append(fields, promptdependency.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptDependencyMutation) ClearField(name string) error {
	switch name {
	case promptdependency.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown PromptDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptDependencyMutation) ResetField(name string) error {
	switch name {
	case promptdependency.FieldType:
		m.ResetType()
		return nil
	case promptdependency.FieldDependencyName:
		m.ResetDependencyName()
		return nil
	case promptdependency.FieldDependencyVersion:
		m.ResetDependencyVersion()
		return nil
	case promptdependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case promptdependency.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case promptdependency.FieldCondition:
		m.ResetCondition()
		return nil
	case promptdependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PromptDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prompt != nil {
		edges = append(edges, promptdependency.EdgePrompt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promptdependency.EdgePrompt:
		if id := m.prompt; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprompt {
		edges = append(edges, promptdependency.EdgePrompt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case promptdependency.EdgePrompt:
		return m.clearedprompt
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptDependencyMutation) ClearEdge(name string) error {
	switch name {
	case promptdependency.EdgePrompt:
		m.ClearPrompt()
		return nil
	}
	return fmt.Errorf("unknown PromptDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptDependencyMutation) ResetEdge(name string) error {
	switch name {
	case promptdependency.EdgePrompt:
		m.ResetPrompt()
		return nil
	}
	return fmt.Errorf("unknown PromptDependency edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	url               *string
	_type             *repository.Type
	is_active         *bool
	default_branch    *string
	last_sync         *time.Time
	sync_status       *repository.SyncStatus
	manifest          *string
	manifest_hash     *string
	has_write_access  *bool
	access_token      *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	components        map[string]struct{}
	removedcomponents map[string]struct{}
	clearedcomponents bool
	tools             map[string]struct{}
	removedtools      map[string]struct{}
	clearedtools      bool
	prompts           map[string]struct{}
	removedprompts    map[string]struct{}
	clearedprompts    bool
	agents            map[string]struct{}
	removedagents     map[string]struct{}
	clearedagents     bool
	forks             map[string]struct{}
	removedforks      map[string]struct{}
	clearedforks      bool
	done              bool
	oldValue          func(context.Context) (*Repository, error)
	predicates        []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id string) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RepositoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepositoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepositoryMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *RepositoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *RepositoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *RepositoryMutation) ResetURL() {
	m.url = nil
}

// SetType sets the "type" field.
func (m *RepositoryMutation) SetType(r repository.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RepositoryMutation) GetType() (r repository.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldType(ctx context.Context) (v repository.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RepositoryMutation) ResetType() {
	m._type = nil
}

// SetIsActive sets the "is_active" field.
func (m *RepositoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RepositoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RepositoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDefaultBranch sets the "default_branch" field.
func (m *RepositoryMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *RepositoryMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDefaultBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *RepositoryMutation) ResetDefaultBranch() {
	m.default_branch = nil
}

// SetLastSync sets the "last_sync" field.
func (m *RepositoryMutation) SetLastSync(t time.Time) {
	m.last_sync = &t
}

// LastSync returns the value of the "last_sync" field in the mutation.
func (m *RepositoryMutation) LastSync() (r time.Time, exists bool) {
	v := m.last_sync
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSync returns the old "last_sync" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldLastSync(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSync: %w", err)
	}
	return oldValue.LastSync, nil
}

// ClearLastSync clears the value of the "last_sync" field.
func (m *RepositoryMutation) ClearLastSync() {
	m.last_sync = nil
	m.clearedFields[repository.FieldLastSync] = struct{}{}
}

// LastSyncCleared returns if the "last_sync" field was cleared in this mutation.
func (m *RepositoryMutation) LastSyncCleared() bool {
	_, ok := m.clearedFields[repository.FieldLastSync]
	return ok
}

// ResetLastSync resets all changes to the "last_sync" field.
func (m *RepositoryMutation) ResetLastSync() {
	m.last_sync = nil
	delete(m.clearedFields, repository.FieldLastSync)
}

// SetSyncStatus sets the "sync_status" field.
func (m *RepositoryMutation) SetSyncStatus(rs repository.SyncStatus) {
	m.sync_status = &rs
}

// SyncStatus returns the value of the "sync_status" field in the mutation.
func (m *RepositoryMutation) SyncStatus() (r repository.SyncStatus, exists bool) {
	v := m.sync_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncStatus returns the old "sync_status" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSyncStatus(ctx context.Context) (v repository.SyncStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncStatus: %w", err)
	}
	return oldValue.SyncStatus, nil
}

// ResetSyncStatus resets all changes to the "sync_status" field.
func (m *RepositoryMutation) ResetSyncStatus() {
	m.sync_status = nil
}

// SetManifest sets the "manifest" field.
func (m *RepositoryMutation) SetManifest(s string) {
	m.manifest = &s
}

// Manifest returns the value of the "manifest" field in the mutation.
func (m *RepositoryMutation) Manifest() (r string, exists bool) {
	v := m.manifest
	if v == nil {
		return
	}
	return *v, true
}

// OldManifest returns the old "manifest" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldManifest(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifest: %w", err)
	}
	return oldValue.Manifest, nil
}

// ClearManifest clears the value of the "manifest" field.
func (m *RepositoryMutation) ClearManifest() {
	m.manifest = nil
	m.clearedFields[repository.FieldManifest] = struct{}{}
}

// ManifestCleared returns if the "manifest" field was cleared in this mutation.
func (m *RepositoryMutation) ManifestCleared() bool {
	_, ok := m.clearedFields[repository.FieldManifest]
	return ok
}

// ResetManifest resets all changes to the "manifest" field.
func (m *RepositoryMutation) ResetManifest() {
	m.manifest = nil
	delete(m.clearedFields, repository.FieldManifest)
}

// SetManifestHash sets the "manifest_hash" field.
func (m *RepositoryMutation) SetManifestHash(s string) {
	m.manifest_hash = &s
}

// ManifestHash returns the value of the "manifest_hash" field in the mutation.
func (m *RepositoryMutation) ManifestHash() (r string, exists bool) {
	v := m.manifest_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldManifestHash returns the old "manifest_hash" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldManifestHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifestHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifestHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifestHash: %w", err)
	}
	return oldValue.ManifestHash, nil
}

// ClearManifestHash clears the value of the "manifest_hash" field.
func (m *RepositoryMutation) ClearManifestHash() {
	m.manifest_hash = nil
	m.clearedFields[repository.FieldManifestHash] = struct{}{}
}

// ManifestHashCleared returns if the "manifest_hash" field was cleared in this mutation.
func (m *RepositoryMutation) ManifestHashCleared() bool {
	_, ok := m.clearedFields[repository.FieldManifestHash]
	return ok
}

// ResetManifestHash resets all changes to the "manifest_hash" field.
func (m *RepositoryMutation) ResetManifestHash() {
	m.manifest_hash = nil
	delete(m.clearedFields, repository.FieldManifestHash)
}

// SetHasWriteAccess sets the "has_write_access" field.
func (m *RepositoryMutation) SetHasWriteAccess(b bool) {
	m.has_write_access = &b
}

// HasWriteAccess returns the value of the "has_write_access" field in the mutation.
func (m *RepositoryMutation) HasWriteAccess() (r bool, exists bool) {
	v := m.has_write_access
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWriteAccess returns the old "has_write_access" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasWriteAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWriteAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWriteAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWriteAccess: %w", err)
	}
	return oldValue.HasWriteAccess, nil
}

// ResetHasWriteAccess resets all changes to the "has_write_access" field.
func (m *RepositoryMutation) ResetHasWriteAccess() {
	m.has_write_access = nil
}

// SetAccessToken sets the "access_token" field.
func (m *RepositoryMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *RepositoryMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldAccessToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *RepositoryMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[repository.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *RepositoryMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[repository.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *RepositoryMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, repository.FieldAccessToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *RepositoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RepositoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RepositoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RepositoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RepositoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RepositoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *RepositoryMutation) AddComponentIDs(ids ...string) {
	if m.components == nil {
		m.components = make(map[string]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *RepositoryMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *RepositoryMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *RepositoryMutation) RemoveComponentIDs(ids ...string) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *RepositoryMutation) RemovedComponentsIDs() (ids []string) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *RepositoryMutation) ComponentsIDs() (ids []string) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *RepositoryMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddToolIDs adds the "tools" edge to the Tool entity by ids.
func (m *RepositoryMutation) AddToolIDs(ids ...string) {
	if m.tools == nil {
		m.tools = make(map[string]struct{})
	}
	for i := range ids {
		m.tools[ids[i]] = struct{}{}
	}
}

// ClearTools clears the "tools" edge to the Tool entity.
func (m *RepositoryMutation) ClearTools() {
	m.clearedtools = true
}

// ToolsCleared reports if the "tools" edge to the Tool entity was cleared.
func (m *RepositoryMutation) ToolsCleared() bool {
	return m.clearedtools
}

// RemoveToolIDs removes the "tools" edge to the Tool entity by IDs.
func (m *RepositoryMutation) RemoveToolIDs(ids ...string) {
	if m.removedtools == nil {
		m.removedtools = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tools, ids[i])
		m.removedtools[ids[i]] = struct{}{}
	}
}

// RemovedTools returns the removed IDs of the "tools" edge to the Tool entity.
func (m *RepositoryMutation) RemovedToolsIDs() (ids []string) {
	for id := range m.removedtools {
		ids = append(ids, id)
	}
	return
}

// ToolsIDs returns the "tools" edge IDs in the mutation.
func (m *RepositoryMutation) ToolsIDs() (ids []string) {
	for id := range m.tools {
		ids = append(ids, id)
	}
	return
}

// ResetTools resets all changes to the "tools" edge.
func (m *RepositoryMutation) ResetTools() {
	m.tools = nil
	m.clearedtools = false
	m.removedtools = nil
}

// AddPromptIDs adds the "prompts" edge to the Prompt entity by ids.
func (m *RepositoryMutation) AddPromptIDs(ids ...string) {
	if m.prompts == nil {
		m.prompts = make(map[string]struct{})
	}
	for i := range ids {
		m.prompts[ids[i]] = struct{}{}
	}
}

// ClearPrompts clears the "prompts" edge to the Prompt entity.
func (m *RepositoryMutation) ClearPrompts() {
	m.clearedprompts = true
}

// PromptsCleared reports if the "prompts" edge to the Prompt entity was cleared.
func (m *RepositoryMutation) PromptsCleared() bool {
	return m.clearedprompts
}

// RemovePromptIDs removes the "prompts" edge to the Prompt entity by IDs.
func (m *RepositoryMutation) RemovePromptIDs(ids ...string) {
	if m.removedprompts == nil {
		m.removedprompts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.prompts, ids[i])
		m.removedprompts[ids[i]] = struct{}{}
	}
}

// RemovedPrompts returns the removed IDs of the "prompts" edge to the Prompt entity.
func (m *RepositoryMutation) RemovedPromptsIDs() (ids []string) {
	for id := range m.removedprompts {
		ids = append(ids, id)
	}
	return
}

// PromptsIDs returns the "prompts" edge IDs in the mutation.
func (m *RepositoryMutation) PromptsIDs() (ids []string) {
	for id := range m.prompts {
		ids = append(ids, id)
	}
	return
}

// ResetPrompts resets all changes to the "prompts" edge.
func (m *RepositoryMutation) ResetPrompts() {
	m.prompts = nil
	m.clearedprompts = false
	m.removedprompts = nil
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *RepositoryMutation) AddAgentIDs(ids ...string) {
	if m.agents == nil {
		m.agents = make(map[string]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *RepositoryMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *RepositoryMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *RepositoryMutation) RemoveAgentIDs(ids ...string) {
	if m.removedagents == nil {
		m.removedagents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *RepositoryMutation) RemovedAgentsIDs() (ids []string) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *RepositoryMutation) AgentsIDs() (ids []string) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *RepositoryMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddForkIDs adds the "forks" edge to the Fork entity by ids.
func (m *RepositoryMutation) AddForkIDs(ids ...string) {
	if m.forks == nil {
		m.forks = make(map[string]struct{})
	}
	for i := range ids {
		m.forks[ids[i]] = struct{}{}
	}
}

// ClearForks clears the "forks" edge to the Fork entity.
func (m *RepositoryMutation) ClearForks() {
	m.clearedforks = true
}

// ForksCleared reports if the "forks" edge to the Fork entity was cleared.
func (m *RepositoryMutation) ForksCleared() bool {
	return m.clearedforks
}

// RemoveForkIDs removes the "forks" edge to the Fork entity by IDs.
func (m *RepositoryMutation) RemoveForkIDs(ids ...string) {
	if m.removedforks == nil {
		m.removedforks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.forks, ids[i])
		m.removedforks[ids[i]] = struct{}{}
	}
}

// RemovedForks returns the removed IDs of the "forks" edge to the Fork entity.
func (m *RepositoryMutation) RemovedForksIDs() (ids []string) {
	for id := range m.removedforks {
		ids = append(ids, id)
	}
	return
}

// ForksIDs returns the "forks" edge IDs in the mutation.
func (m *RepositoryMutation) ForksIDs() (ids []string) {
	for id := range m.forks {
		ids = append(ids, id)
	}
	return
}

// ResetForks resets all changes to the "forks" edge.
func (m *RepositoryMutation) ResetForks() {
	m.forks = nil
	m.clearedforks = false
	m.removedforks = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, repository.FieldName)
	}
	if m.url != nil {
		fields = append(fields, repository.FieldURL)
	}
	if m._type != nil {
		fields = append(fields, repository.FieldType)
	}
	if m.is_active != nil {
		fields = append(fields, repository.FieldIsActive)
	}
	if m.default_branch != nil {
		fields = append(fields, repository.FieldDefaultBranch)
	}
	if m.last_sync != nil {
		fields = append(fields, repository.FieldLastSync)
	}
	if m.sync_status != nil {
		fields = append(fields, repository.FieldSyncStatus)
	}
	if m.manifest != nil {
		fields = append(fields, repository.FieldManifest)
	}
	if m.manifest_hash != nil {
		fields = append(fields, repository.FieldManifestHash)
	}
	if m.has_write_access != nil {
		fields = append(fields, repository.FieldHasWriteAccess)
	}
	if m.access_token != nil {
		fields = append(fields, repository.FieldAccessToken)
	}
	if m.created_at != nil {
		fields = append(fields, repository.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, repository.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldName:
		return m.Name()
	case repository.FieldURL:
		return m.URL()
	case repository.FieldType:
		return m.GetType()
	case repository.FieldIsActive:
		return m.IsActive()
	case repository.FieldDefaultBranch:
		return m.DefaultBranch()
	case repository.FieldLastSync:
		return m.LastSync()
	case repository.FieldSyncStatus:
		return m.SyncStatus()
	case repository.FieldManifest:
		return m.Manifest()
	case repository.FieldManifestHash:
		return m.ManifestHash()
	case repository.FieldHasWriteAccess:
		return m.HasWriteAccess()
	case repository.FieldAccessToken:
		return m.AccessToken()
	case repository.FieldCreatedAt:
		return m.CreatedAt()
	case repository.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldName:
		return m.OldName(ctx)
	case repository.FieldURL:
		return m.OldURL(ctx)
	case repository.FieldType:
		return m.OldType(ctx)
	case repository.FieldIsActive:
		return m.OldIsActive(ctx)
	case repository.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	case repository.FieldLastSync:
		return m.OldLastSync(ctx)
	case repository.FieldSyncStatus:
		return m.OldSyncStatus(ctx)
	case repository.FieldManifest:
		return m.OldManifest(ctx)
	case repository.FieldManifestHash:
		return m.OldManifestHash(ctx)
	case repository.FieldHasWriteAccess:
		return m.OldHasWriteAccess(ctx)
	case repository.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case repository.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case repository.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repository.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case repository.FieldType:
		v, ok := value.(repository.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case repository.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case repository.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	case repository.FieldLastSync:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSync(v)
		return nil
	case repository.FieldSyncStatus:
		v, ok := value.(repository.SyncStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncStatus(v)
		return nil
	case repository.FieldManifest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifest(v)
		return nil
	case repository.FieldManifestHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifestHash(v)
		return nil
	case repository.FieldHasWriteAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWriteAccess(v)
		return nil
	case repository.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case repository.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case repository.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldLastSync) {
		fields = append(fields, repository.FieldLastSync)
	}
	if m.FieldCleared(repository.FieldManifest) {
		fields = append(fields, repository.FieldManifest)
	}
	if m.FieldCleared(repository.FieldManifestHash) {
		fields = append(fields, repository.FieldManifestHash)
	}
	if m.FieldCleared(repository.FieldAccessToken) {
		fields = append(fields, repository.FieldAccessToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldLastSync:
		m.ClearLastSync()
		return nil
	case repository.FieldManifest:
		m.ClearManifest()
		return nil
	case repository.FieldManifestHash:
		m.ClearManifestHash()
		return nil
	case repository.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldName:
		m.ResetName()
		return nil
	case repository.FieldURL:
		m.ResetURL()
		return nil
	case repository.FieldType:
		m.ResetType()
		return nil
	case repository.FieldIsActive:
		m.ResetIsActive()
		return nil
	case repository.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	case repository.FieldLastSync:
		m.ResetLastSync()
		return nil
	case repository.FieldSyncStatus:
		m.ResetSyncStatus()
		return nil
	case repository.FieldManifest:
		m.ResetManifest()
		return nil
	case repository.FieldManifestHash:
		m.ResetManifestHash()
		return nil
	case repository.FieldHasWriteAccess:
		m.ResetHasWriteAccess()
		return nil
	case repository.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case repository.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case repository.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.components != nil {
		edges = append(edges, repository.EdgeComponents)
	}
	if m.tools != nil {
		edges = append(edges, repository.EdgeTools)
	}
	if m.prompts != nil {
		edges = append(edges, repository.EdgePrompts)
	}
	if m.agents != nil {
		edges = append(edges, repository.EdgeAgents)
	}
	if m.forks != nil {
		edges = append(edges, repository.EdgeForks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeTools:
		ids := make([]ent.Value, 0, len(m.tools))
		for id := range m.tools {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.prompts))
		for id := range m.prompts {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeForks:
		ids := make([]ent.Value, 0, len(m.forks))
		for id := range m.forks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcomponents != nil {
		edges = append(edges, repository.EdgeComponents)
	}
	if m.removedtools != nil {
		edges = append(edges, repository.EdgeTools)
	}
	if m.removedprompts != nil {
		edges = append(edges, repository.EdgePrompts)
	}
	if m.removedagents != nil {
		edges = append(edges, repository.EdgeAgents)
	}
	if m.removedforks != nil {
		edges = append(edges, repository.EdgeForks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeTools:
		ids := make([]ent.Value, 0, len(m.removedtools))
		for id := range m.removedtools {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.removedprompts))
		for id := range m.removedprompts {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeForks:
		ids := make([]ent.Value, 0, len(m.removedforks))
		for id := range m.removedforks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcomponents {
		edges = append(edges, repository.EdgeComponents)
	}
	if m.clearedtools {
		edges = append(edges, repository.EdgeTools)
	}
	if m.clearedprompts {
		edges = append(edges, repository.EdgePrompts)
	}
	if m.clearedagents {
		edges = append(edges, repository.EdgeAgents)
	}
	if m.clearedforks {
		edges = append(edges, repository.EdgeForks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeComponents:
		return m.clearedcomponents
	case repository.EdgeTools:
		return m.clearedtools
	case repository.EdgePrompts:
		return m.clearedprompts
	case repository.EdgeAgents:
		return m.clearedagents
	case repository.EdgeForks:
		return m.clearedforks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeComponents:
		m.ResetComponents()
		return nil
	case repository.EdgeTools:
		m.ResetTools()
		return nil
	case repository.EdgePrompts:
		m.ResetPrompts()
		return nil
	case repository.EdgeAgents:
		m.ResetAgents()
		return nil
	case repository.EdgeForks:
		m.ResetForks()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// SyncOperationMutation represents an operation that mutates the SyncOperation nodes in the graph.
type SyncOperationMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *syncoperation.Type
	status             *syncoperation.Status
	direction          *syncoperation.Direction
	repository_id      *string
	component_id       *string
	source_commit      *string
	target_commit      *string
	branch             *string
	started_at         *time.Time
	completed_at       *time.Time
	error_message      *string
	total_steps        *int
	addtotal_steps     *int
	completed_steps    *int
	addcompleted_steps *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*SyncOperation, error)
	predicates         []predicate.SyncOperation
}

var _ ent.Mutation = (*SyncOperationMutation)(nil)

// syncoperationOption allows management of the mutation configuration using functional options.
type syncoperationOption func(*SyncOperationMutation)

// newSyncOperationMutation creates new mutation for the SyncOperation entity.
func newSyncOperationMutation(c config, op Op, opts ...syncoperationOption) *SyncOperationMutation {
	m := &SyncOperationMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncOperation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncOperationID sets the ID field of the mutation.
func withSyncOperationID(id string) syncoperationOption {
	return func(m *SyncOperationMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncOperation
		)
		m.oldValue = func(ctx context.Context) (*SyncOperation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncOperation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncOperation sets the old SyncOperation of the mutation.
func withSyncOperation(node *SyncOperation) syncoperationOption {
	return func(m *SyncOperationMutation) {
		m.oldValue = func(context.Context) (*SyncOperation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncOperationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncOperationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncOperation entities.
func (m *SyncOperationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncOperationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncOperationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncOperation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SyncOperationMutation) SetType(s syncoperation.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SyncOperationMutation) GetType() (r syncoperation.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldType(ctx context.Context) (v syncoperation.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SyncOperationMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *SyncOperationMutation) SetStatus(s syncoperation.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SyncOperationMutation) Status() (r syncoperation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldStatus(ctx context.Context) (v syncoperation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SyncOperationMutation) ResetStatus() {
	m.status = nil
}

// SetDirection sets the "direction" field.
func (m *SyncOperationMutation) SetDirection(s syncoperation.Direction) {
	m.direction = &s
}

// Direction returns the value of the "direction" field in the mutation.
func (m *SyncOperationMutation) Direction() (r syncoperation.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldDirection(ctx context.Context) (v syncoperation.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *SyncOperationMutation) ResetDirection() {
	m.direction = nil
}

// SetRepositoryID sets the "repository_id" field.
func (m *SyncOperationMutation) SetRepositoryID(s string) {
	m.repository_id = &s
}

// RepositoryID returns the value of the "repository_id" field in the mutation.
func (m *SyncOperationMutation) RepositoryID() (r string, exists bool) {
	v := m.repository_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryID returns the old "repository_id" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldRepositoryID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryID: %w", err)
	}
	return oldValue.RepositoryID, nil
}

// ClearRepositoryID clears the value of the "repository_id" field.
func (m *SyncOperationMutation) ClearRepositoryID() {
	m.repository_id = nil
	m.clearedFields[syncoperation.FieldRepositoryID] = struct{}{}
}

// RepositoryIDCleared returns if the "repository_id" field was cleared in this mutation.
func (m *SyncOperationMutation) RepositoryIDCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldRepositoryID]
	return ok
}

// ResetRepositoryID resets all changes to the "repository_id" field.
func (m *SyncOperationMutation) ResetRepositoryID() {
	m.repository_id = nil
	delete(m.clearedFields, syncoperation.FieldRepositoryID)
}

// SetComponentID sets the "component_id" field.
func (m *SyncOperationMutation) SetComponentID(s string) {
	m.component_id = &s
}

// ComponentID returns the value of the "component_id" field in the mutation.
func (m *SyncOperationMutation) ComponentID() (r string, exists bool) {
	v := m.component_id
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentID returns the old "component_id" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldComponentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentID: %w", err)
	}
	return oldValue.ComponentID, nil
}

// ClearComponentID clears the value of the "component_id" field.
func (m *SyncOperationMutation) ClearComponentID() {
	m.component_id = nil
	m.clearedFields[syncoperation.FieldComponentID] = struct{}{}
}

// ComponentIDCleared returns if the "component_id" field was cleared in this mutation.
func (m *SyncOperationMutation) ComponentIDCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldComponentID]
	return ok
}

// ResetComponentID resets all changes to the "component_id" field.
func (m *SyncOperationMutation) ResetComponentID() {
	m.component_id = nil
	delete(m.clearedFields, syncoperation.FieldComponentID)
}

// SetSourceCommit sets the "source_commit" field.
func (m *SyncOperationMutation) SetSourceCommit(s string) {
	m.source_commit = &s
}

// SourceCommit returns the value of the "source_commit" field in the mutation.
func (m *SyncOperationMutation) SourceCommit() (r string, exists bool) {
	v := m.source_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCommit returns the old "source_commit" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldSourceCommit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCommit: %w", err)
	}
	return oldValue.SourceCommit, nil
}

// ClearSourceCommit clears the value of the "source_commit" field.
func (m *SyncOperationMutation) ClearSourceCommit() {
	m.source_commit = nil
	m.clearedFields[syncoperation.FieldSourceCommit] = struct{}{}
}

// SourceCommitCleared returns if the "source_commit" field was cleared in this mutation.
func (m *SyncOperationMutation) SourceCommitCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldSourceCommit]
	return ok
}

// ResetSourceCommit resets all changes to the "source_commit" field.
func (m *SyncOperationMutation) ResetSourceCommit() {
	m.source_commit = nil
	delete(m.clearedFields, syncoperation.FieldSourceCommit)
}

// SetTargetCommit sets the "target_commit" field.
func (m *SyncOperationMutation) SetTargetCommit(s string) {
	m.target_commit = &s
}

// TargetCommit returns the value of the "target_commit" field in the mutation.
func (m *SyncOperationMutation) TargetCommit() (r string, exists bool) {
	v := m.target_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetCommit returns the old "target_commit" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldTargetCommit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetCommit: %w", err)
	}
	return oldValue.TargetCommit, nil
}

// ClearTargetCommit clears the value of the "target_commit" field.
func (m *SyncOperationMutation) ClearTargetCommit() {
	m.target_commit = nil
	m.clearedFields[syncoperation.FieldTargetCommit] = struct{}{}
}

// TargetCommitCleared returns if the "target_commit" field was cleared in this mutation.
func (m *SyncOperationMutation) TargetCommitCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldTargetCommit]
	return ok
}

// ResetTargetCommit resets all changes to the "target_commit" field.
func (m *SyncOperationMutation) ResetTargetCommit() {
	m.target_commit = nil
	delete(m.clearedFields, syncoperation.FieldTargetCommit)
}

// SetBranch sets the "branch" field.
func (m *SyncOperationMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *SyncOperationMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldBranch(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ClearBranch clears the value of the "branch" field.
func (m *SyncOperationMutation) ClearBranch() {
	m.branch = nil
	m.clearedFields[syncoperation.FieldBranch] = struct{}{}
}

// BranchCleared returns if the "branch" field was cleared in this mutation.
func (m *SyncOperationMutation) BranchCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldBranch]
	return ok
}

// ResetBranch resets all changes to the "branch" field.
func (m *SyncOperationMutation) ResetBranch() {
	m.branch = nil
	delete(m.clearedFields, syncoperation.FieldBranch)
}

// SetStartedAt sets the "started_at" field.
func (m *SyncOperationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SyncOperationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SyncOperationMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *SyncOperationMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SyncOperationMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SyncOperationMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[syncoperation.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SyncOperationMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SyncOperationMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, syncoperation.FieldCompletedAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *SyncOperationMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SyncOperationMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SyncOperationMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[syncoperation.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SyncOperationMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[syncoperation.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SyncOperationMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, syncoperation.FieldErrorMessage)
}

// SetTotalSteps sets the "total_steps" field.
func (m *SyncOperationMutation) SetTotalSteps(i int) {
	m.total_steps = &i
	m.addtotal_steps = nil
}

// TotalSteps returns the value of the "total_steps" field in the mutation.
func (m *SyncOperationMutation) TotalSteps() (r int, exists bool) {
	v := m.total_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSteps returns the old "total_steps" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldTotalSteps(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSteps: %w", err)
	}
	return oldValue.TotalSteps, nil
}

// AddTotalSteps adds i to the "total_steps" field.
func (m *SyncOperationMutation) AddTotalSteps(i int) {
	if m.addtotal_steps != nil {
		*m.addtotal_steps += i
	} else {
		m.addtotal_steps = &i
	}
}

// AddedTotalSteps returns the value that was added to the "total_steps" field in this mutation.
func (m *SyncOperationMutation) AddedTotalSteps() (r int, exists bool) {
	v := m.addtotal_steps
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSteps resets all changes to the "total_steps" field.
func (m *SyncOperationMutation) ResetTotalSteps() {
	m.total_steps = nil
	m.addtotal_steps = nil
}

// SetCompletedSteps sets the "completed_steps" field.
func (m *SyncOperationMutation) SetCompletedSteps(i int) {
	m.completed_steps = &i
	m.addcompleted_steps = nil
}

// CompletedSteps returns the value of the "completed_steps" field in the mutation.
func (m *SyncOperationMutation) CompletedSteps() (r int, exists bool) {
	v := m.completed_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedSteps returns the old "completed_steps" field's value of the SyncOperation entity.
// If the SyncOperation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncOperationMutation) OldCompletedSteps(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedSteps: %w", err)
	}
	return oldValue.CompletedSteps, nil
}

// AddCompletedSteps adds i to the "completed_steps" field.
func (m *SyncOperationMutation) AddCompletedSteps(i int) {
	if m.addcompleted_steps != nil {
		*m.addcompleted_steps += i
	} else {
		m.addcompleted_steps = &i
	}
}

// AddedCompletedSteps returns the value that was added to the "completed_steps" field in this mutation.
func (m *SyncOperationMutation) AddedCompletedSteps() (r int, exists bool) {
	v := m.addcompleted_steps
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletedSteps resets all changes to the "completed_steps" field.
func (m *SyncOperationMutation) ResetCompletedSteps() {
	m.completed_steps = nil
	m.addcompleted_steps = nil
}

// Where appends a list predicates to the SyncOperationMutation builder.
func (m *SyncOperationMutation) Where(ps ...predicate.SyncOperation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SyncOperationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SyncOperationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SyncOperation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SyncOperationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SyncOperationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SyncOperation).
func (m *SyncOperationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncOperationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._type != nil {
		fields = append(fields, syncoperation.FieldType)
	}
	if m.status != nil {
		fields = append(fields, syncoperation.FieldStatus)
	}
	if m.direction != nil {
		fields = append(fields, syncoperation.FieldDirection)
	}
	if m.repository_id != nil {
		fields = append(fields, syncoperation.FieldRepositoryID)
	}
	if m.component_id != nil {
		fields = append(fields, syncoperation.FieldComponentID)
	}
	if m.source_commit != nil {
		fields = append(fields, syncoperation.FieldSourceCommit)
	}
	if m.target_commit != nil {
		fields = append(fields, syncoperation.FieldTargetCommit)
	}
	if m.branch != nil {
		fields = append(fields, syncoperation.FieldBranch)
	}
	if m.started_at != nil {
		fields = append(fields, syncoperation.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, syncoperation.FieldCompletedAt)
	}
	if m.error_message != nil {
		fields = append(fields, syncoperation.FieldErrorMessage)
	}
	if m.total_steps != nil {
		fields = append(fields, syncoperation.FieldTotalSteps)
	}
	if m.completed_steps != nil {
		fields = append(fields, syncoperation.FieldCompletedSteps)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncOperationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncoperation.FieldType:
		return m.GetType()
	case syncoperation.FieldStatus:
		return m.Status()
	case syncoperation.FieldDirection:
		return m.Direction()
	case syncoperation.FieldRepositoryID:
		return m.RepositoryID()
	case syncoperation.FieldComponentID:
		return m.ComponentID()
	case syncoperation.FieldSourceCommit:
		return m.SourceCommit()
	case syncoperation.FieldTargetCommit:
		return m.TargetCommit()
	case syncoperation.FieldBranch:
		return m.Branch()
	case syncoperation.FieldStartedAt:
		return m.StartedAt()
	case syncoperation.FieldCompletedAt:
		return m.CompletedAt()
	case syncoperation.FieldErrorMessage:
		return m.ErrorMessage()
	case syncoperation.FieldTotalSteps:
		return m.TotalSteps()
	case syncoperation.FieldCompletedSteps:
		return m.CompletedSteps()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncOperationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncoperation.FieldType:
		return m.OldType(ctx)
	case syncoperation.FieldStatus:
		return m.OldStatus(ctx)
	case syncoperation.FieldDirection:
		return m.OldDirection(ctx)
	case syncoperation.FieldRepositoryID:
		return m.OldRepositoryID(ctx)
	case syncoperation.FieldComponentID:
		return m.OldComponentID(ctx)
	case syncoperation.FieldSourceCommit:
		return m.OldSourceCommit(ctx)
	case syncoperation.FieldTargetCommit:
		return m.OldTargetCommit(ctx)
	case syncoperation.FieldBranch:
		return m.OldBranch(ctx)
	case syncoperation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case syncoperation.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case syncoperation.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case syncoperation.FieldTotalSteps:
		return m.OldTotalSteps(ctx)
	case syncoperation.FieldCompletedSteps:
		return m.OldCompletedSteps(ctx)
	}
	return nil, fmt.Errorf("unknown SyncOperation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncOperationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncoperation.FieldType:
		v, ok := value.(syncoperation.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case syncoperation.FieldStatus:
		v, ok := value.(syncoperation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case syncoperation.FieldDirection:
		v, ok := value.(syncoperation.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case syncoperation.FieldRepositoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryID(v)
		return nil
	case syncoperation.FieldComponentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentID(v)
		return nil
	case syncoperation.FieldSourceCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCommit(v)
		return nil
	case syncoperation.FieldTargetCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetCommit(v)
		return nil
	case syncoperation.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case syncoperation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case syncoperation.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case syncoperation.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case syncoperation.FieldTotalSteps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSteps(v)
		return nil
	case syncoperation.FieldCompletedSteps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedSteps(v)
		return nil
	}
	return fmt.Errorf("unknown SyncOperation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncOperationMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_steps != nil {
		fields = append(fields, syncoperation.FieldTotalSteps)
	}
	if m.addcompleted_steps != nil {
		fields = append(fields, syncoperation.FieldCompletedSteps)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncOperationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncoperation.FieldTotalSteps:
		return m.AddedTotalSteps()
	case syncoperation.FieldCompletedSteps:
		return m.AddedCompletedSteps()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncOperationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncoperation.FieldTotalSteps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSteps(v)
		return nil
	case syncoperation.FieldCompletedSteps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletedSteps(v)
		return nil
	}
	return fmt.Errorf("unknown SyncOperation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncOperationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(syncoperation.FieldRepositoryID) {
		fields = append(fields, syncoperation.FieldRepositoryID)
	}
	if m.FieldCleared(syncoperation.FieldComponentID) {
		fields = append(fields, syncoperation.FieldComponentID)
	}
	if m.FieldCleared(syncoperation.FieldSourceCommit) {
		fields = append(fields, syncoperation.FieldSourceCommit)
	}
	if m.FieldCleared(syncoperation.FieldTargetCommit) {
		fields = append(fields, syncoperation.FieldTargetCommit)
	}
	if m.FieldCleared(syncoperation.FieldBranch) {
		fields = append(fields, syncoperation.FieldBranch)
	}
	if m.FieldCleared(syncoperation.FieldCompletedAt) {
		fields = append(fields, syncoperation.FieldCompletedAt)
	}
	if m.FieldCleared(syncoperation.FieldErrorMessage) {
		fields = append(fields, syncoperation.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncOperationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncOperationMutation) ClearField(name string) error {
	switch name {
	case syncoperation.FieldRepositoryID:
		m.ClearRepositoryID()
		return nil
	case syncoperation.FieldComponentID:
		m.ClearComponentID()
		return nil
	case syncoperation.FieldSourceCommit:
		m.ClearSourceCommit()
		return nil
	case syncoperation.FieldTargetCommit:
		m.ClearTargetCommit()
		return nil
	case syncoperation.FieldBranch:
		m.ClearBranch()
		return nil
	case syncoperation.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case syncoperation.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown SyncOperation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncOperationMutation) ResetField(name string) error {
	switch name {
	case syncoperation.FieldType:
		m.ResetType()
		return nil
	case syncoperation.FieldStatus:
		m.ResetStatus()
		return nil
	case syncoperation.FieldDirection:
		m.ResetDirection()
		return nil
	case syncoperation.FieldRepositoryID:
		m.ResetRepositoryID()
		return nil
	case syncoperation.FieldComponentID:
		m.ResetComponentID()
		return nil
	case syncoperation.FieldSourceCommit:
		m.ResetSourceCommit()
		return nil
	case syncoperation.FieldTargetCommit:
		m.ResetTargetCommit()
		return nil
	case syncoperation.FieldBranch:
		m.ResetBranch()
		return nil
	case syncoperation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case syncoperation.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case syncoperation.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case syncoperation.FieldTotalSteps:
		m.ResetTotalSteps()
		return nil
	case syncoperation.FieldCompletedSteps:
		m.ResetCompletedSteps()
		return nil
	}
	return fmt.Errorf("unknown SyncOperation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncOperationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncOperationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncOperationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncOperationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncOperationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncOperationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncOperationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncOperation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncOperationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncOperation edge %s", name)
}

// ToolMutation represents an operation that mutates the Tool nodes in the graph.
type ToolMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	namespace                  *string
	version                    *string
	description                *string
	author                     *string
	license                    *string
	homepage                   *string
	documentation              *string
	tags                       *[]string
	appendtags                 []string
	categories                 *[]string
	appendcategories           []string
	keywords                   *[]string
	appendkeywords             []string
	stability                  *tool.Stability
	maturity                   *tool.Maturity
	forge_version              *string
	platforms                  *[]string
	appendplatforms            []string
	spec                       *string
	spec_hash                  *string
	is_installed               *bool
	install_path               *string
	installed_at               *time.Time
	commit_hash                *string
	branch                     *string
	created_at                 *time.Time
	updated_at                 *time.Time
	execution_type             *tool.ExecutionType
	schema_path                *string
	server_config              *map[string]interface{}
	capabilities               *[]string
	appendcapabilities         []string
	entry_point                *string
	environment_variables      *map[string]string
	required_permissions       *[]string
	appendrequired_permissions []string
	timeout_seconds            *int
	addtimeout_seconds         *int
	supports_streaming         *bool
	input_schema               *map[string]interface{}
	output_schema              *map[string]interface{}
	clearedFields              map[string]struct{}
	repository                 *string
	clearedrepository          bool
	dependencies               map[string]struct{}
	removeddependencies        map[string]struct{}
	cleareddependencies        bool
	done                       bool
	oldValue                   func(context.Context) (*Tool, error)
	predicates                 []predicate.Tool
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows management of the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for the Tool entity.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the ID field of the mutation.
func withToolID(id string) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tool entities.
func (m *ToolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ToolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ToolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ToolMutation) ResetName() {
	m.name = nil
}

// SetNamespace sets the "namespace" field.
func (m *ToolMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *ToolMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *ToolMutation) ResetNamespace() {
	m.namespace = nil
}

// SetVersion sets the "version" field.
func (m *ToolMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ToolMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ToolMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *ToolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ToolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ToolMutation) ResetDescription() {
	m.description = nil
}

// SetAuthor sets the "author" field.
func (m *ToolMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ToolMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ToolMutation) ResetAuthor() {
	m.author = nil
}

// SetLicense sets the "license" field.
func (m *ToolMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *ToolMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ResetLicense resets all changes to the "license" field.
func (m *ToolMutation) ResetLicense() {
	m.license = nil
}

// SetHomepage sets the "homepage" field.
func (m *ToolMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *ToolMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldHomepage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *ToolMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[tool.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *ToolMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[tool.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *ToolMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, tool.FieldHomepage)
}

// SetDocumentation sets the "documentation" field.
func (m *ToolMutation) SetDocumentation(s string) {
	m.documentation = &s
}

// Documentation returns the value of the "documentation" field in the mutation.
func (m *ToolMutation) Documentation() (r string, exists bool) {
	v := m.documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentation returns the old "documentation" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldDocumentation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentation: %w", err)
	}
	return oldValue.Documentation, nil
}

// ClearDocumentation clears the value of the "documentation" field.
func (m *ToolMutation) ClearDocumentation() {
	m.documentation = nil
	m.clearedFields[tool.FieldDocumentation] = struct{}{}
}

// DocumentationCleared returns if the "documentation" field was cleared in this mutation.
func (m *ToolMutation) DocumentationCleared() bool {
	_, ok := m.clearedFields[tool.FieldDocumentation]
	return ok
}

// ResetDocumentation resets all changes to the "documentation" field.
func (m *ToolMutation) ResetDocumentation() {
	m.documentation = nil
	delete(m.clearedFields, tool.FieldDocumentation)
}

// SetTags sets the "tags" field.
func (m *ToolMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ToolMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ToolMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ToolMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ToolMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[tool.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ToolMutation) TagsCleared() bool {
	_, ok := m.clearedFields[tool.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ToolMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, tool.FieldTags)
}

// SetCategories sets the "categories" field.
func (m *ToolMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *ToolMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *ToolMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *ToolMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *ToolMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[tool.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *ToolMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[tool.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *ToolMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, tool.FieldCategories)
}

// SetKeywords sets the "keywords" field.
func (m *ToolMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *ToolMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *ToolMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *ToolMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *ToolMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[tool.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *ToolMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[tool.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *ToolMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, tool.FieldKeywords)
}

// SetStability sets the "stability" field.
func (m *ToolMutation) SetStability(t tool.Stability) {
	m.stability = &t
}

// Stability returns the value of the "stability" field in the mutation.
func (m *ToolMutation) Stability() (r tool.Stability, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldStability(ctx context.Context) (v tool.Stability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *ToolMutation) ResetStability() {
	m.stability = nil
}

// SetMaturity sets the "maturity" field.
func (m *ToolMutation) SetMaturity(t tool.Maturity) {
	m.maturity = &t
}

// Maturity returns the value of the "maturity" field in the mutation.
func (m *ToolMutation) Maturity() (r tool.Maturity, exists bool) {
	v := m.maturity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturity returns the old "maturity" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldMaturity(ctx context.Context) (v tool.Maturity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturity: %w", err)
	}
	return oldValue.Maturity, nil
}

// ResetMaturity resets all changes to the "maturity" field.
func (m *ToolMutation) ResetMaturity() {
	m.maturity = nil
}

// SetForgeVersion sets the "forge_version" field.
func (m *ToolMutation) SetForgeVersion(s string) {
	m.forge_version = &s
}

// ForgeVersion returns the value of the "forge_version" field in the mutation.
func (m *ToolMutation) ForgeVersion() (r string, exists bool) {
	v := m.forge_version
	if v == nil {
		return
	}
	return *v, true
}

// OldForgeVersion returns the old "forge_version" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldForgeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgeVersion: %w", err)
	}
	return oldValue.ForgeVersion, nil
}

// ResetForgeVersion resets all changes to the "forge_version" field.
func (m *ToolMutation) ResetForgeVersion() {
	m.forge_version = nil
}

// SetPlatforms sets the "platforms" field.
func (m *ToolMutation) SetPlatforms(s []string) {
	m.platforms = &s
	m.appendplatforms = nil
}

// Platforms returns the value of the "platforms" field in the mutation.
func (m *ToolMutation) Platforms() (r []string, exists bool) {
	v := m.platforms
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatforms returns the old "platforms" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldPlatforms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatforms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatforms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatforms: %w", err)
	}
	return oldValue.Platforms, nil
}

// AppendPlatforms adds s to the "platforms" field.
func (m *ToolMutation) AppendPlatforms(s []string) {
	m.appendplatforms = append(m.appendplatforms, s...)
}

// AppendedPlatforms returns the list of values that were appended to the "platforms" field in this mutation.
func (m *ToolMutation) AppendedPlatforms() ([]string, bool) {
	if len(m.appendplatforms) == 0 {
		return nil, false
	}
	return m.appendplatforms, true
}

// ClearPlatforms clears the value of the "platforms" field.
func (m *ToolMutation) ClearPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	m.clearedFields[tool.FieldPlatforms] = struct{}{}
}

// PlatformsCleared returns if the "platforms" field was cleared in this mutation.
func (m *ToolMutation) PlatformsCleared() bool {
	_, ok := m.clearedFields[tool.FieldPlatforms]
	return ok
}

// ResetPlatforms resets all changes to the "platforms" field.
func (m *ToolMutation) ResetPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	delete(m.clearedFields, tool.FieldPlatforms)
}

// SetSpec sets the "spec" field.
func (m *ToolMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *ToolMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldSpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ResetSpec resets all changes to the "spec" field.
func (m *ToolMutation) ResetSpec() {
	m.spec = nil
}

// SetSpecHash sets the "spec_hash" field.
func (m *ToolMutation) SetSpecHash(s string) {
	m.spec_hash = &s
}

// SpecHash returns the value of the "spec_hash" field in the mutation.
func (m *ToolMutation) SpecHash() (r string, exists bool) {
	v := m.spec_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecHash returns the old "spec_hash" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldSpecHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecHash: %w", err)
	}
	return oldValue.SpecHash, nil
}

// ResetSpecHash resets all changes to the "spec_hash" field.
func (m *ToolMutation) ResetSpecHash() {
	m.spec_hash = nil
}

// SetIsInstalled sets the "is_installed" field.
func (m *ToolMutation) SetIsInstalled(b bool) {
	m.is_installed = &b
}

// IsInstalled returns the value of the "is_installed" field in the mutation.
func (m *ToolMutation) IsInstalled() (r bool, exists bool) {
	v := m.is_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstalled returns the old "is_installed" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldIsInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstalled: %w", err)
	}
	return oldValue.IsInstalled, nil
}

// ResetIsInstalled resets all changes to the "is_installed" field.
func (m *ToolMutation) ResetIsInstalled() {
	m.is_installed = nil
}

// SetInstallPath sets the "install_path" field.
func (m *ToolMutation) SetInstallPath(s string) {
	m.install_path = &s
}

// InstallPath returns the value of the "install_path" field in the mutation.
func (m *ToolMutation) InstallPath() (r string, exists bool) {
	v := m.install_path
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallPath returns the old "install_path" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldInstallPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallPath: %w", err)
	}
	return oldValue.InstallPath, nil
}

// ClearInstallPath clears the value of the "install_path" field.
func (m *ToolMutation) ClearInstallPath() {
	m.install_path = nil
	m.clearedFields[tool.FieldInstallPath] = struct{}{}
}

// InstallPathCleared returns if the "install_path" field was cleared in this mutation.
func (m *ToolMutation) InstallPathCleared() bool {
	_, ok := m.clearedFields[tool.FieldInstallPath]
	return ok
}

// ResetInstallPath resets all changes to the "install_path" field.
func (m *ToolMutation) ResetInstallPath() {
	m.install_path = nil
	delete(m.clearedFields, tool.FieldInstallPath)
}

// SetInstalledAt sets the "installed_at" field.
func (m *ToolMutation) SetInstalledAt(t time.Time) {
	m.installed_at = &t
}

// InstalledAt returns the value of the "installed_at" field in the mutation.
func (m *ToolMutation) InstalledAt() (r time.Time, exists bool) {
	v := m.installed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledAt returns the old "installed_at" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldInstalledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledAt: %w", err)
	}
	return oldValue.InstalledAt, nil
}

// ClearInstalledAt clears the value of the "installed_at" field.
func (m *ToolMutation) ClearInstalledAt() {
	m.installed_at = nil
	m.clearedFields[tool.FieldInstalledAt] = struct{}{}
}

// InstalledAtCleared returns if the "installed_at" field was cleared in this mutation.
func (m *ToolMutation) InstalledAtCleared() bool {
	_, ok := m.clearedFields[tool.FieldInstalledAt]
	return ok
}

// ResetInstalledAt resets all changes to the "installed_at" field.
func (m *ToolMutation) ResetInstalledAt() {
	m.installed_at = nil
	delete(m.clearedFields, tool.FieldInstalledAt)
}

// SetCommitHash sets the "commit_hash" field.
func (m *ToolMutation) SetCommitHash(s string) {
	m.commit_hash = &s
}

// CommitHash returns the value of the "commit_hash" field in the mutation.
func (m *ToolMutation) CommitHash() (r string, exists bool) {
	v := m.commit_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitHash returns the old "commit_hash" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCommitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitHash: %w", err)
	}
	return oldValue.CommitHash, nil
}

// ResetCommitHash resets all changes to the "commit_hash" field.
func (m *ToolMutation) ResetCommitHash() {
	m.commit_hash = nil
}

// SetBranch sets the "branch" field.
func (m *ToolMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *ToolMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *ToolMutation) ResetBranch() {
	m.branch = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ToolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ToolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ToolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExecutionType sets the "execution_type" field.
func (m *ToolMutation) SetExecutionType(tt tool.ExecutionType) {
	m.execution_type = &tt
}

// ExecutionType returns the value of the "execution_type" field in the mutation.
func (m *ToolMutation) ExecutionType() (r tool.ExecutionType, exists bool) {
	v := m.execution_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionType returns the old "execution_type" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldExecutionType(ctx context.Context) (v tool.ExecutionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionType: %w", err)
	}
	return oldValue.ExecutionType, nil
}

// ResetExecutionType resets all changes to the "execution_type" field.
func (m *ToolMutation) ResetExecutionType() {
	m.execution_type = nil
}

// SetSchemaPath sets the "schema_path" field.
func (m *ToolMutation) SetSchemaPath(s string) {
	m.schema_path = &s
}

// SchemaPath returns the value of the "schema_path" field in the mutation.
func (m *ToolMutation) SchemaPath() (r string, exists bool) {
	v := m.schema_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaPath returns the old "schema_path" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldSchemaPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaPath: %w", err)
	}
	return oldValue.SchemaPath, nil
}

// ClearSchemaPath clears the value of the "schema_path" field.
func (m *ToolMutation) ClearSchemaPath() {
	m.schema_path = nil
	m.clearedFields[tool.FieldSchemaPath] = struct{}{}
}

// SchemaPathCleared returns if the "schema_path" field was cleared in this mutation.
func (m *ToolMutation) SchemaPathCleared() bool {
	_, ok := m.clearedFields[tool.FieldSchemaPath]
	return ok
}

// ResetSchemaPath resets all changes to the "schema_path" field.
func (m *ToolMutation) ResetSchemaPath() {
	m.schema_path = nil
	delete(m.clearedFields, tool.FieldSchemaPath)
}

// SetServerConfig sets the "server_config" field.
func (m *ToolMutation) SetServerConfig(value map[string]interface{}) {
	m.server_config = &value
}

// ServerConfig returns the value of the "server_config" field in the mutation.
func (m *ToolMutation) ServerConfig() (r map[string]interface{}, exists bool) {
	v := m.server_config
	if v == nil {
		return
	}
	return *v, true
}

// OldServerConfig returns the old "server_config" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldServerConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerConfig: %w", err)
	}
	return oldValue.ServerConfig, nil
}

// ClearServerConfig clears the value of the "server_config" field.
func (m *ToolMutation) ClearServerConfig() {
	m.server_config = nil
	m.clearedFields[tool.FieldServerConfig] = struct{}{}
}

// ServerConfigCleared returns if the "server_config" field was cleared in this mutation.
func (m *ToolMutation) ServerConfigCleared() bool {
	_, ok := m.clearedFields[tool.FieldServerConfig]
	return ok
}

// ResetServerConfig resets all changes to the "server_config" field.
func (m *ToolMutation) ResetServerConfig() {
	m.server_config = nil
	delete(m.clearedFields, tool.FieldServerConfig)
}

// SetCapabilities sets the "capabilities" field.
func (m *ToolMutation) SetCapabilities(s []string) {
	m.capabilities = &s
	m.appendcapabilities = nil
}

// Capabilities returns the value of the "capabilities" field in the mutation.
func (m *ToolMutation) Capabilities() (r []string, exists bool) {
	v := m.capabilities
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilities returns the old "capabilities" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCapabilities(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilities: %w", err)
	}
	return oldValue.Capabilities, nil
}

// AppendCapabilities adds s to the "capabilities" field.
func (m *ToolMutation) AppendCapabilities(s []string) {
	m.appendcapabilities = append(m.appendcapabilities, s...)
}

// AppendedCapabilities returns the list of values that were appended to the "capabilities" field in this mutation.
func (m *ToolMutation) AppendedCapabilities() ([]string, bool) {
	if len(m.appendcapabilities) == 0 {
		return nil, false
	}
	return m.appendcapabilities, true
}

// ClearCapabilities clears the value of the "capabilities" field.
func (m *ToolMutation) ClearCapabilities() {
	m.capabilities = nil
	m.appendcapabilities = nil
	m.clearedFields[tool.FieldCapabilities] = struct{}{}
}

// CapabilitiesCleared returns if the "capabilities" field was cleared in this mutation.
func (m *ToolMutation) CapabilitiesCleared() bool {
	_, ok := m.clearedFields[tool.FieldCapabilities]
	return ok
}

// ResetCapabilities resets all changes to the "capabilities" field.
func (m *ToolMutation) ResetCapabilities() {
	m.capabilities = nil
	m.appendcapabilities = nil
	delete(m.clearedFields, tool.FieldCapabilities)
}

// SetEntryPoint sets the "entry_point" field.
func (m *ToolMutation) SetEntryPoint(s string) {
	m.entry_point = &s
}

// EntryPoint returns the value of the "entry_point" field in the mutation.
func (m *ToolMutation) EntryPoint() (r string, exists bool) {
	v := m.entry_point
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryPoint returns the old "entry_point" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldEntryPoint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryPoint: %w", err)
	}
	return oldValue.EntryPoint, nil
}

// ClearEntryPoint clears the value of the "entry_point" field.
func (m *ToolMutation) ClearEntryPoint() {
	m.entry_point = nil
	m.clearedFields[tool.FieldEntryPoint] = struct{}{}
}

// EntryPointCleared returns if the "entry_point" field was cleared in this mutation.
func (m *ToolMutation) EntryPointCleared() bool {
	_, ok := m.clearedFields[tool.FieldEntryPoint]
	return ok
}

// ResetEntryPoint resets all changes to the "entry_point" field.
func (m *ToolMutation) ResetEntryPoint() {
	m.entry_point = nil
	delete(m.clearedFields, tool.FieldEntryPoint)
}

// SetEnvironmentVariables sets the "environment_variables" field.
func (m *ToolMutation) SetEnvironmentVariables(value map[string]string) {
	m.environment_variables = &value
}

// EnvironmentVariables returns the value of the "environment_variables" field in the mutation.
func (m *ToolMutation) EnvironmentVariables() (r map[string]string, exists bool) {
	v := m.environment_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentVariables returns the old "environment_variables" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldEnvironmentVariables(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentVariables: %w", err)
	}
	return oldValue.EnvironmentVariables, nil
}

// ClearEnvironmentVariables clears the value of the "environment_variables" field.
func (m *ToolMutation) ClearEnvironmentVariables() {
	m.environment_variables = nil
	m.clearedFields[tool.FieldEnvironmentVariables] = struct{}{}
}

// EnvironmentVariablesCleared returns if the "environment_variables" field was cleared in this mutation.
func (m *ToolMutation) EnvironmentVariablesCleared() bool {
	_, ok := m.clearedFields[tool.FieldEnvironmentVariables]
	return ok
}

// ResetEnvironmentVariables resets all changes to the "environment_variables" field.
func (m *ToolMutation) ResetEnvironmentVariables() {
	m.environment_variables = nil
	delete(m.clearedFields, tool.FieldEnvironmentVariables)
}

// SetRequiredPermissions sets the "required_permissions" field.
func (m *ToolMutation) SetRequiredPermissions(s []string) {
	m.required_permissions = &s
	m.appendrequired_permissions = nil
}

// RequiredPermissions returns the value of the "required_permissions" field in the mutation.
func (m *ToolMutation) RequiredPermissions() (r []string, exists bool) {
	v := m.required_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredPermissions returns the old "required_permissions" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldRequiredPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredPermissions: %w", err)
	}
	return oldValue.RequiredPermissions, nil
}

// AppendRequiredPermissions adds s to the "required_permissions" field.
func (m *ToolMutation) AppendRequiredPermissions(s []string) {
	m.appendrequired_permissions = append(m.appendrequired_permissions, s...)
}

// AppendedRequiredPermissions returns the list of values that were appended to the "required_permissions" field in this mutation.
func (m *ToolMutation) AppendedRequiredPermissions() ([]string, bool) {
	if len(m.appendrequired_permissions) == 0 {
		return nil, false
	}
	return m.appendrequired_permissions, true
}

// ClearRequiredPermissions clears the value of the "required_permissions" field.
func (m *ToolMutation) ClearRequiredPermissions() {
	m.required_permissions = nil
	m.appendrequired_permissions = nil
	m.clearedFields[tool.FieldRequiredPermissions] = struct{}{}
}

// RequiredPermissionsCleared returns if the "required_permissions" field was cleared in this mutation.
func (m *ToolMutation) RequiredPermissionsCleared() bool {
	_, ok := m.clearedFields[tool.FieldRequiredPermissions]
	return ok
}

// ResetRequiredPermissions resets all changes to the "required_permissions" field.
func (m *ToolMutation) ResetRequiredPermissions() {
	m.required_permissions = nil
	m.appendrequired_permissions = nil
	delete(m.clearedFields, tool.FieldRequiredPermissions)
}

// SetTimeoutSeconds sets the "timeout_seconds" field.
func (m *ToolMutation) SetTimeoutSeconds(i int) {
	m.timeout_seconds = &i
	m.addtimeout_seconds = nil
}

// TimeoutSeconds returns the value of the "timeout_seconds" field in the mutation.
func (m *ToolMutation) TimeoutSeconds() (r int, exists bool) {
	v := m.timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutSeconds returns the old "timeout_seconds" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutSeconds: %w", err)
	}
	return oldValue.TimeoutSeconds, nil
}

// AddTimeoutSeconds adds i to the "timeout_seconds" field.
func (m *ToolMutation) AddTimeoutSeconds(i int) {
	if m.addtimeout_seconds != nil {
		*m.addtimeout_seconds += i
	} else {
		m.addtimeout_seconds = &i
	}
}

// AddedTimeoutSeconds returns the value that was added to the "timeout_seconds" field in this mutation.
func (m *ToolMutation) AddedTimeoutSeconds() (r int, exists bool) {
	v := m.addtimeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeoutSeconds resets all changes to the "timeout_seconds" field.
func (m *ToolMutation) ResetTimeoutSeconds() {
	m.timeout_seconds = nil
	m.addtimeout_seconds = nil
}

// SetSupportsStreaming sets the "supports_streaming" field.
func (m *ToolMutation) SetSupportsStreaming(b bool) {
	m.supports_streaming = &b
}

// SupportsStreaming returns the value of the "supports_streaming" field in the mutation.
func (m *ToolMutation) SupportsStreaming() (r bool, exists bool) {
	v := m.supports_streaming
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsStreaming returns the old "supports_streaming" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldSupportsStreaming(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsStreaming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsStreaming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsStreaming: %w", err)
	}
	return oldValue.SupportsStreaming, nil
}

// ResetSupportsStreaming resets all changes to the "supports_streaming" field.
func (m *ToolMutation) ResetSupportsStreaming() {
	m.supports_streaming = nil
}

// SetInputSchema sets the "input_schema" field.
func (m *ToolMutation) SetInputSchema(value map[string]interface{}) {
	m.input_schema = &value
}

// InputSchema returns the value of the "input_schema" field in the mutation.
func (m *ToolMutation) InputSchema() (r map[string]interface{}, exists bool) {
	v := m.input_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldInputSchema returns the old "input_schema" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldInputSchema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputSchema: %w", err)
	}
	return oldValue.InputSchema, nil
}

// ClearInputSchema clears the value of the "input_schema" field.
func (m *ToolMutation) ClearInputSchema() {
	m.input_schema = nil
	m.clearedFields[tool.FieldInputSchema] = struct{}{}
}

// InputSchemaCleared returns if the "input_schema" field was cleared in this mutation.
func (m *ToolMutation) InputSchemaCleared() bool {
	_, ok := m.clearedFields[tool.FieldInputSchema]
	return ok
}

// ResetInputSchema resets all changes to the "input_schema" field.
func (m *ToolMutation) ResetInputSchema() {
	m.input_schema = nil
	delete(m.clearedFields, tool.FieldInputSchema)
}

// SetOutputSchema sets the "output_schema" field.
func (m *ToolMutation) SetOutputSchema(value map[string]interface{}) {
	m.output_schema = &value
}

// OutputSchema returns the value of the "output_schema" field in the mutation.
func (m *ToolMutation) OutputSchema() (r map[string]interface{}, exists bool) {
	v := m.output_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputSchema returns the old "output_schema" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldOutputSchema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputSchema: %w", err)
	}
	return oldValue.OutputSchema, nil
}

// ClearOutputSchema clears the value of the "output_schema" field.
func (m *ToolMutation) ClearOutputSchema() {
	m.output_schema = nil
	m.clearedFields[tool.FieldOutputSchema] = struct{}{}
}

// OutputSchemaCleared returns if the "output_schema" field was cleared in this mutation.
func (m *ToolMutation) OutputSchemaCleared() bool {
	_, ok := m.clearedFields[tool.FieldOutputSchema]
	return ok
}

// ResetOutputSchema resets all changes to the "output_schema" field.
func (m *ToolMutation) ResetOutputSchema() {
	m.output_schema = nil
	delete(m.clearedFields, tool.FieldOutputSchema)
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *ToolMutation) SetRepositoryID(id string) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *ToolMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *ToolMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *ToolMutation) RepositoryID() (id string, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *ToolMutation) RepositoryIDs() (ids []string) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *ToolMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// AddDependencyIDs adds the "dependencies" edge to the ToolDependency entity by ids.
func (m *ToolMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ToolDependency entity.
func (m *ToolMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ToolDependency entity was cleared.
func (m *ToolMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ToolDependency entity by IDs.
func (m *ToolMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ToolDependency entity.
func (m *ToolMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ToolMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ToolMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ToolMutation builder.
func (m *ToolMutation) Where(ps ...predicate.Tool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m.name != nil {
		fields = append(fields, tool.FieldName)
	}
	if m.namespace != nil {
		fields = append(fields, tool.FieldNamespace)
	}
	if m.version != nil {
		fields = append(fields, tool.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, tool.FieldDescription)
	}
	if m.author != nil {
		fields = append(fields, tool.FieldAuthor)
	}
	if m.license != nil {
		fields = append(fields, tool.FieldLicense)
	}
	if m.homepage != nil {
		fields = append(fields, tool.FieldHomepage)
	}
	if m.documentation != nil {
		fields = append(fields, tool.FieldDocumentation)
	}
	if m.tags != nil {
		fields = append(fields, tool.FieldTags)
	}
	if m.categories != nil {
		fields = append(fields, tool.FieldCategories)
	}
	if m.keywords != nil {
		fields = append(fields, tool.FieldKeywords)
	}
	if m.stability != nil {
		fields = append(fields, tool.FieldStability)
	}
	if m.maturity != nil {
		fields = append(fields, tool.FieldMaturity)
	}
	if m.forge_version != nil {
		fields = append(fields, tool.FieldForgeVersion)
	}
	if m.platforms != nil {
		fields = append(fields, tool.FieldPlatforms)
	}
	if m.spec != nil {
		fields = append(fields, tool.FieldSpec)
	}
	if m.spec_hash != nil {
		fields = append(fields, tool.FieldSpecHash)
	}
	if m.is_installed != nil {
		fields = append(fields, tool.FieldIsInstalled)
	}
	if m.install_path != nil {
		fields = append(fields, tool.FieldInstallPath)
	}
	if m.installed_at != nil {
		fields = append(fields, tool.FieldInstalledAt)
	}
	if m.commit_hash != nil {
		fields = append(fields, tool.FieldCommitHash)
	}
	if m.branch != nil {
		fields = append(fields, tool.FieldBranch)
	}
	if m.created_at != nil {
		fields = append(fields, tool.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tool.FieldUpdatedAt)
	}
	if m.execution_type != nil {
		fields = append(fields, tool.FieldExecutionType)
	}
	if m.schema_path != nil {
		fields = append(fields, tool.FieldSchemaPath)
	}
	if m.server_config != nil {
		fields = append(fields, tool.FieldServerConfig)
	}
	if m.capabilities != nil {
		fields = append(fields, tool.FieldCapabilities)
	}
	if m.entry_point != nil {
		fields = append(fields, tool.FieldEntryPoint)
	}
	if m.environment_variables != nil {
		fields = append(fields, tool.FieldEnvironmentVariables)
	}
	if m.required_permissions != nil {
		fields = append(fields, tool.FieldRequiredPermissions)
	}
	if m.timeout_seconds != nil {
		fields = append(fields, tool.FieldTimeoutSeconds)
	}
	if m.supports_streaming != nil {
		fields = append(fields, tool.FieldSupportsStreaming)
	}
	if m.input_schema != nil {
		fields = append(fields, tool.FieldInputSchema)
	}
	if m.output_schema != nil {
		fields = append(fields, tool.FieldOutputSchema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldName:
		return m.Name()
	case tool.FieldNamespace:
		return m.Namespace()
	case tool.FieldVersion:
		return m.Version()
	case tool.FieldDescription:
		return m.Description()
	case tool.FieldAuthor:
		return m.Author()
	case tool.FieldLicense:
		return m.License()
	case tool.FieldHomepage:
		return m.Homepage()
	case tool.FieldDocumentation:
		return m.Documentation()
	case tool.FieldTags:
		return m.Tags()
	case tool.FieldCategories:
		return m.Categories()
	case tool.FieldKeywords:
		return m.Keywords()
	case tool.FieldStability:
		return m.Stability()
	case tool.FieldMaturity:
		return m.Maturity()
	case tool.FieldForgeVersion:
		return m.ForgeVersion()
	case tool.FieldPlatforms:
		return m.Platforms()
	case tool.FieldSpec:
		return m.Spec()
	case tool.FieldSpecHash:
		return m.SpecHash()
	case tool.FieldIsInstalled:
		return m.IsInstalled()
	case tool.FieldInstallPath:
		return m.InstallPath()
	case tool.FieldInstalledAt:
		return m.InstalledAt()
	case tool.FieldCommitHash:
		return m.CommitHash()
	case tool.FieldBranch:
		return m.Branch()
	case tool.FieldCreatedAt:
		return m.CreatedAt()
	case tool.FieldUpdatedAt:
		return m.UpdatedAt()
	case tool.FieldExecutionType:
		return m.ExecutionType()
	case tool.FieldSchemaPath:
		return m.SchemaPath()
	case tool.FieldServerConfig:
		return m.ServerConfig()
	case tool.FieldCapabilities:
		return m.Capabilities()
	case tool.FieldEntryPoint:
		return m.EntryPoint()
	case tool.FieldEnvironmentVariables:
		return m.EnvironmentVariables()
	case tool.FieldRequiredPermissions:
		return m.RequiredPermissions()
	case tool.FieldTimeoutSeconds:
		return m.TimeoutSeconds()
	case tool.FieldSupportsStreaming:
		return m.SupportsStreaming()
	case tool.FieldInputSchema:
		return m.InputSchema()
	case tool.FieldOutputSchema:
		return m.OutputSchema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldName:
		return m.OldName(ctx)
	case tool.FieldNamespace:
		return m.OldNamespace(ctx)
	case tool.FieldVersion:
		return m.OldVersion(ctx)
	case tool.FieldDescription:
		return m.OldDescription(ctx)
	case tool.FieldAuthor:
		return m.OldAuthor(ctx)
	case tool.FieldLicense:
		return m.OldLicense(ctx)
	case tool.FieldHomepage:
		return m.OldHomepage(ctx)
	case tool.FieldDocumentation:
		return m.OldDocumentation(ctx)
	case tool.FieldTags:
		return m.OldTags(ctx)
	case tool.FieldCategories:
		return m.OldCategories(ctx)
	case tool.FieldKeywords:
		return m.OldKeywords(ctx)
	case tool.FieldStability:
		return m.OldStability(ctx)
	case tool.FieldMaturity:
		return m.OldMaturity(ctx)
	case tool.FieldForgeVersion:
		return m.OldForgeVersion(ctx)
	case tool.FieldPlatforms:
		return m.OldPlatforms(ctx)
	case tool.FieldSpec:
		return m.OldSpec(ctx)
	case tool.FieldSpecHash:
		return m.OldSpecHash(ctx)
	case tool.FieldIsInstalled:
		return m.OldIsInstalled(ctx)
	case tool.FieldInstallPath:
		return m.OldInstallPath(ctx)
	case tool.FieldInstalledAt:
		return m.OldInstalledAt(ctx)
	case tool.FieldCommitHash:
		return m.OldCommitHash(ctx)
	case tool.FieldBranch:
		return m.OldBranch(ctx)
	case tool.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tool.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tool.FieldExecutionType:
		return m.OldExecutionType(ctx)
	case tool.FieldSchemaPath:
		return m.OldSchemaPath(ctx)
	case tool.FieldServerConfig:
		return m.OldServerConfig(ctx)
	case tool.FieldCapabilities:
		return m.OldCapabilities(ctx)
	case tool.FieldEntryPoint:
		return m.OldEntryPoint(ctx)
	case tool.FieldEnvironmentVariables:
		return m.OldEnvironmentVariables(ctx)
	case tool.FieldRequiredPermissions:
		return m.OldRequiredPermissions(ctx)
	case tool.FieldTimeoutSeconds:
		return m.OldTimeoutSeconds(ctx)
	case tool.FieldSupportsStreaming:
		return m.OldSupportsStreaming(ctx)
	case tool.FieldInputSchema:
		return m.OldInputSchema(ctx)
	case tool.FieldOutputSchema:
		return m.OldOutputSchema(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tool.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case tool.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tool.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tool.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case tool.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case tool.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case tool.FieldDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentation(v)
		return nil
	case tool.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case tool.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case tool.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case tool.FieldStability:
		v, ok := value.(tool.Stability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case tool.FieldMaturity:
		v, ok := value.(tool.Maturity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturity(v)
		return nil
	case tool.FieldForgeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgeVersion(v)
		return nil
	case tool.FieldPlatforms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatforms(v)
		return nil
	case tool.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case tool.FieldSpecHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecHash(v)
		return nil
	case tool.FieldIsInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstalled(v)
		return nil
	case tool.FieldInstallPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallPath(v)
		return nil
	case tool.FieldInstalledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledAt(v)
		return nil
	case tool.FieldCommitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitHash(v)
		return nil
	case tool.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case tool.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tool.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tool.FieldExecutionType:
		v, ok := value.(tool.ExecutionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionType(v)
		return nil
	case tool.FieldSchemaPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaPath(v)
		return nil
	case tool.FieldServerConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerConfig(v)
		return nil
	case tool.FieldCapabilities:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilities(v)
		return nil
	case tool.FieldEntryPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryPoint(v)
		return nil
	case tool.FieldEnvironmentVariables:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentVariables(v)
		return nil
	case tool.FieldRequiredPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredPermissions(v)
		return nil
	case tool.FieldTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutSeconds(v)
		return nil
	case tool.FieldSupportsStreaming:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsStreaming(v)
		return nil
	case tool.FieldInputSchema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputSchema(v)
		return nil
	case tool.FieldOutputSchema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputSchema(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout_seconds != nil {
		fields = append(fields, tool.FieldTimeoutSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldTimeoutSeconds:
		return m.AddedTimeoutSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tool.FieldTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tool.FieldHomepage) {
		fields = append(fields, tool.FieldHomepage)
	}
	if m.FieldCleared(tool.FieldDocumentation) {
		fields = append(fields, tool.FieldDocumentation)
	}
	if m.FieldCleared(tool.FieldTags) {
		fields = append(fields, tool.FieldTags)
	}
	if m.FieldCleared(tool.FieldCategories) {
		fields = append(fields, tool.FieldCategories)
	}
	if m.FieldCleared(tool.FieldKeywords) {
		fields = append(fields, tool.FieldKeywords)
	}
	if m.FieldCleared(tool.FieldPlatforms) {
		fields = append(fields, tool.FieldPlatforms)
	}
	if m.FieldCleared(tool.FieldInstallPath) {
		fields = append(fields, tool.FieldInstallPath)
	}
	if m.FieldCleared(tool.FieldInstalledAt) {
		fields = append(fields, tool.FieldInstalledAt)
	}
	if m.FieldCleared(tool.FieldSchemaPath) {
		fields = append(fields, tool.FieldSchemaPath)
	}
	if m.FieldCleared(tool.FieldServerConfig) {
		fields = append(fields, tool.FieldServerConfig)
	}
	if m.FieldCleared(tool.FieldCapabilities) {
		fields = append(fields, tool.FieldCapabilities)
	}
	if m.FieldCleared(tool.FieldEntryPoint) {
		fields = append(fields, tool.FieldEntryPoint)
	}
	if m.FieldCleared(tool.FieldEnvironmentVariables) {
		fields = append(fields, tool.FieldEnvironmentVariables)
	}
	if m.FieldCleared(tool.FieldRequiredPermissions) {
		fields = append(fields, tool.FieldRequiredPermissions)
	}
	if m.FieldCleared(tool.FieldInputSchema) {
		fields = append(fields, tool.FieldInputSchema)
	}
	if m.FieldCleared(tool.FieldOutputSchema) {
		fields = append(fields, tool.FieldOutputSchema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	switch name {
	case tool.FieldHomepage:
		m.ClearHomepage()
		return nil
	case tool.FieldDocumentation:
		m.ClearDocumentation()
		return nil
	case tool.FieldTags:
		m.ClearTags()
		return nil
	case tool.FieldCategories:
		m.ClearCategories()
		return nil
	case tool.FieldKeywords:
		m.ClearKeywords()
		return nil
	case tool.FieldPlatforms:
		m.ClearPlatforms()
		return nil
	case tool.FieldInstallPath:
		m.ClearInstallPath()
		return nil
	case tool.FieldInstalledAt:
		m.ClearInstalledAt()
		return nil
	case tool.FieldSchemaPath:
		m.ClearSchemaPath()
		return nil
	case tool.FieldServerConfig:
		m.ClearServerConfig()
		return nil
	case tool.FieldCapabilities:
		m.ClearCapabilities()
		return nil
	case tool.FieldEntryPoint:
		m.ClearEntryPoint()
		return nil
	case tool.FieldEnvironmentVariables:
		m.ClearEnvironmentVariables()
		return nil
	case tool.FieldRequiredPermissions:
		m.ClearRequiredPermissions()
		return nil
	case tool.FieldInputSchema:
		m.ClearInputSchema()
		return nil
	case tool.FieldOutputSchema:
		m.ClearOutputSchema()
		return nil
	}
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldName:
		m.ResetName()
		return nil
	case tool.FieldNamespace:
		m.ResetNamespace()
		return nil
	case tool.FieldVersion:
		m.ResetVersion()
		return nil
	case tool.FieldDescription:
		m.ResetDescription()
		return nil
	case tool.FieldAuthor:
		m.ResetAuthor()
		return nil
	case tool.FieldLicense:
		m.ResetLicense()
		return nil
	case tool.FieldHomepage:
		m.ResetHomepage()
		return nil
	case tool.FieldDocumentation:
		m.ResetDocumentation()
		return nil
	case tool.FieldTags:
		m.ResetTags()
		return nil
	case tool.FieldCategories:
		m.ResetCategories()
		return nil
	case tool.FieldKeywords:
		m.ResetKeywords()
		return nil
	case tool.FieldStability:
		m.ResetStability()
		return nil
	case tool.FieldMaturity:
		m.ResetMaturity()
		return nil
	case tool.FieldForgeVersion:
		m.ResetForgeVersion()
		return nil
	case tool.FieldPlatforms:
		m.ResetPlatforms()
		return nil
	case tool.FieldSpec:
		m.ResetSpec()
		return nil
	case tool.FieldSpecHash:
		m.ResetSpecHash()
		return nil
	case tool.FieldIsInstalled:
		m.ResetIsInstalled()
		return nil
	case tool.FieldInstallPath:
		m.ResetInstallPath()
		return nil
	case tool.FieldInstalledAt:
		m.ResetInstalledAt()
		return nil
	case tool.FieldCommitHash:
		m.ResetCommitHash()
		return nil
	case tool.FieldBranch:
		m.ResetBranch()
		return nil
	case tool.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tool.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tool.FieldExecutionType:
		m.ResetExecutionType()
		return nil
	case tool.FieldSchemaPath:
		m.ResetSchemaPath()
		return nil
	case tool.FieldServerConfig:
		m.ResetServerConfig()
		return nil
	case tool.FieldCapabilities:
		m.ResetCapabilities()
		return nil
	case tool.FieldEntryPoint:
		m.ResetEntryPoint()
		return nil
	case tool.FieldEnvironmentVariables:
		m.ResetEnvironmentVariables()
		return nil
	case tool.FieldRequiredPermissions:
		m.ResetRequiredPermissions()
		return nil
	case tool.FieldTimeoutSeconds:
		m.ResetTimeoutSeconds()
		return nil
	case tool.FieldSupportsStreaming:
		m.ResetSupportsStreaming()
		return nil
	case tool.FieldInputSchema:
		m.ResetInputSchema()
		return nil
	case tool.FieldOutputSchema:
		m.ResetOutputSchema()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repository != nil {
		edges = append(edges, tool.EdgeRepository)
	}
	if m.dependencies != nil {
		edges = append(edges, tool.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	case tool.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddependencies != nil {
		edges = append(edges, tool.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepository {
		edges = append(edges, tool.EdgeRepository)
	}
	if m.cleareddependencies {
		edges = append(edges, tool.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	switch name {
	case tool.EdgeRepository:
		return m.clearedrepository
	case tool.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	switch name {
	case tool.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	switch name {
	case tool.EdgeRepository:
		m.ResetRepository()
		return nil
	case tool.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Tool edge %s", name)
}

// ToolDependencyMutation represents an operation that mutates the ToolDependency nodes in the graph.
type ToolDependencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *tooldependency.Type
	dependency_name    *string
	dependency_version *string
	version_range      *string
	is_required        *bool
	condition          *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	tool               *string
	clearedtool        bool
	done               bool
	oldValue           func(context.Context) (*ToolDependency, error)
	predicates         []predicate.ToolDependency
}

var _ ent.Mutation = (*ToolDependencyMutation)(nil)

// tooldependencyOption allows management of the mutation configuration using functional options.
type tooldependencyOption func(*ToolDependencyMutation)

// newToolDependencyMutation creates new mutation for the ToolDependency entity.
func newToolDependencyMutation(c config, op Op, opts ...tooldependencyOption) *ToolDependencyMutation {
	m := &ToolDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeToolDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolDependencyID sets the ID field of the mutation.
func withToolDependencyID(id string) tooldependencyOption {
	return func(m *ToolDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolDependency
		)
		m.oldValue = func(ctx context.Context) (*ToolDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolDependency sets the old ToolDependency of the mutation.
func withToolDependency(node *ToolDependency) tooldependencyOption {
	return func(m *ToolDependencyMutation) {
		m.oldValue = func(context.Context) (*ToolDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolDependency entities.
func (m *ToolDependencyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolDependencyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolDependencyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ToolDependencyMutation) SetType(t tooldependency.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *ToolDependencyMutation) GetType() (r tooldependency.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldType(ctx context.Context) (v tooldependency.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ToolDependencyMutation) ResetType() {
	m._type = nil
}

// SetDependencyName sets the "dependency_name" field.
func (m *ToolDependencyMutation) SetDependencyName(s string) {
	m.dependency_name = &s
}

// DependencyName returns the value of the "dependency_name" field in the mutation.
func (m *ToolDependencyMutation) DependencyName() (r string, exists bool) {
	v := m.dependency_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyName returns the old "dependency_name" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldDependencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyName: %w", err)
	}
	return oldValue.DependencyName, nil
}

// ResetDependencyName resets all changes to the "dependency_name" field.
func (m *ToolDependencyMutation) ResetDependencyName() {
	m.dependency_name = nil
}

// SetDependencyVersion sets the "dependency_version" field.
func (m *ToolDependencyMutation) SetDependencyVersion(s string) {
	m.dependency_version = &s
}

// DependencyVersion returns the value of the "dependency_version" field in the mutation.
func (m *ToolDependencyMutation) DependencyVersion() (r string, exists bool) {
	v := m.dependency_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyVersion returns the old "dependency_version" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldDependencyVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyVersion: %w", err)
	}
	return oldValue.DependencyVersion, nil
}

// ResetDependencyVersion resets all changes to the "dependency_version" field.
func (m *ToolDependencyMutation) ResetDependencyVersion() {
	m.dependency_version = nil
}

// SetVersionRange sets the "version_range" field.
func (m *ToolDependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *ToolDependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *ToolDependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetIsRequired sets the "is_required" field.
func (m *ToolDependencyMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *ToolDependencyMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *ToolDependencyMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetCondition sets the "condition" field.
func (m *ToolDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *ToolDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldCondition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of the "condition" field.
func (m *ToolDependencyMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[tooldependency.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *ToolDependencyMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[tooldependency.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *ToolDependencyMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, tooldependency.FieldCondition)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolDependency entity.
// If the ToolDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetToolID sets the "tool" edge to the Tool entity by id.
func (m *ToolDependencyMutation) SetToolID(id string) {
	m.tool = &id
}

// ClearTool clears the "tool" edge to the Tool entity.
func (m *ToolDependencyMutation) ClearTool() {
	m.clearedtool = true
}

// ToolCleared reports if the "tool" edge to the Tool entity was cleared.
func (m *ToolDependencyMutation) ToolCleared() bool {
	return m.clearedtool
}

// ToolID returns the "tool" edge ID in the mutation.
func (m *ToolDependencyMutation) ToolID() (id string, exists bool) {
	if m.tool != nil {
		return *m.tool, true
	}
	return
}

// ToolIDs returns the "tool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToolID instead. It exists only for internal usage by the builders.
func (m *ToolDependencyMutation) ToolIDs() (ids []string) {
	if id := m.tool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTool resets all changes to the "tool" edge.
func (m *ToolDependencyMutation) ResetTool() {
	m.tool = nil
	m.clearedtool = false
}

// Where appends a list predicates to the ToolDependencyMutation builder.
func (m *ToolDependencyMutation) Where(ps ...predicate.ToolDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolDependency).
func (m *ToolDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, tooldependency.FieldType)
	}
	if m.dependency_name != nil {
		fields = append(fields, tooldependency.FieldDependencyName)
	}
	if m.dependency_version != nil {
		fields = append(fields, tooldependency.FieldDependencyVersion)
	}
	if m.version_range != nil {
		fields = append(fields, tooldependency.FieldVersionRange)
	}
	if m.is_required != nil {
		fields = append(fields, tooldependency.FieldIsRequired)
	}
	if m.condition != nil {
		fields = append(fields, tooldependency.FieldCondition)
	}
	if m.created_at != nil {
		fields = append(fields, tooldependency.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tooldependency.FieldType:
		return m.GetType()
	case tooldependency.FieldDependencyName:
		return m.DependencyName()
	case tooldependency.FieldDependencyVersion:
		return m.DependencyVersion()
	case tooldependency.FieldVersionRange:
		return m.VersionRange()
	case tooldependency.FieldIsRequired:
		return m.IsRequired()
	case tooldependency.FieldCondition:
		return m.Condition()
	case tooldependency.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tooldependency.FieldType:
		return m.OldType(ctx)
	case tooldependency.FieldDependencyName:
		return m.OldDependencyName(ctx)
	case tooldependency.FieldDependencyVersion:
		return m.OldDependencyVersion(ctx)
	case tooldependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case tooldependency.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case tooldependency.FieldCondition:
		return m.OldCondition(ctx)
	case tooldependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tooldependency.FieldType:
		v, ok := value.(tooldependency.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tooldependency.FieldDependencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyName(v)
		return nil
	case tooldependency.FieldDependencyVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyVersion(v)
		return nil
	case tooldependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case tooldependency.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case tooldependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case tooldependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tooldependency.FieldCondition) {
		fields = append(fields, tooldependency.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolDependencyMutation) ClearField(name string) error {
	switch name {
	case tooldependency.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown ToolDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolDependencyMutation) ResetField(name string) error {
	switch name {
	case tooldependency.FieldType:
		m.ResetType()
		return nil
	case tooldependency.FieldDependencyName:
		m.ResetDependencyName()
		return nil
	case tooldependency.FieldDependencyVersion:
		m.ResetDependencyVersion()
		return nil
	case tooldependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case tooldependency.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case tooldependency.FieldCondition:
		m.ResetCondition()
		return nil
	case tooldependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tool != nil {
		edges = append(edges, tooldependency.EdgeTool)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tooldependency.EdgeTool:
		if id := m.tool; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtool {
		edges = append(edges, tooldependency.EdgeTool)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case tooldependency.EdgeTool:
		return m.clearedtool
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolDependencyMutation) ClearEdge(name string) error {
	switch name {
	case tooldependency.EdgeTool:
		m.ClearTool()
		return nil
	}
	return fmt.Errorf("unknown ToolDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolDependencyMutation) ResetEdge(name string) error {
	switch name {
	case tooldependency.EdgeTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown ToolDependency edge %s", name)
}
