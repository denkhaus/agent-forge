// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/denkhaus/agentforge/internal/database/ent/component"
	"github.com/denkhaus/agentforge/internal/database/ent/repository"
)

// Component is the model entity for the Component schema.
type Component struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Namespace holds the value of the "namespace" field.
	Namespace string `json:"namespace,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Kind holds the value of the "kind" field.
	Kind component.Kind `json:"kind,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Author holds the value of the "author" field.
	Author string `json:"author,omitempty"`
	// License holds the value of the "license" field.
	License string `json:"license,omitempty"`
	// Homepage holds the value of the "homepage" field.
	Homepage *string `json:"homepage,omitempty"`
	// Documentation holds the value of the "documentation" field.
	Documentation *string `json:"documentation,omitempty"`
	// Tags holds the value of the "tags" field.
	Tags []string `json:"tags,omitempty"`
	// Categories holds the value of the "categories" field.
	Categories []string `json:"categories,omitempty"`
	// Keywords holds the value of the "keywords" field.
	Keywords []string `json:"keywords,omitempty"`
	// Stability holds the value of the "stability" field.
	Stability component.Stability `json:"stability,omitempty"`
	// Maturity holds the value of the "maturity" field.
	Maturity component.Maturity `json:"maturity,omitempty"`
	// ForgeVersion holds the value of the "forge_version" field.
	ForgeVersion string `json:"forge_version,omitempty"`
	// Platforms holds the value of the "platforms" field.
	Platforms []string `json:"platforms,omitempty"`
	// Spec holds the value of the "spec" field.
	Spec string `json:"spec,omitempty"`
	// SpecHash holds the value of the "spec_hash" field.
	SpecHash string `json:"spec_hash,omitempty"`
	// IsInstalled holds the value of the "is_installed" field.
	IsInstalled bool `json:"is_installed,omitempty"`
	// InstallPath holds the value of the "install_path" field.
	InstallPath *string `json:"install_path,omitempty"`
	// InstalledAt holds the value of the "installed_at" field.
	InstalledAt *time.Time `json:"installed_at,omitempty"`
	// CommitHash holds the value of the "commit_hash" field.
	CommitHash string `json:"commit_hash,omitempty"`
	// Branch holds the value of the "branch" field.
	Branch string `json:"branch,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ComponentQuery when eager-loading is set.
	Edges                 ComponentEdges `json:"edges"`
	repository_components *string
	selectValues          sql.SelectValues
}

// ComponentEdges holds the relations/edges for other nodes in the graph.
type ComponentEdges struct {
	// Repository holds the value of the repository edge.
	Repository *Repository `json:"repository,omitempty"`
	// Dependencies holds the value of the dependencies edge.
	Dependencies []*ComponentDependency `json:"dependencies,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// RepositoryOrErr returns the Repository value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ComponentEdges) RepositoryOrErr() (*Repository, error) {
	if e.Repository != nil {
		return e.Repository, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: repository.Label}
	}
	return nil, &NotLoadedError{edge: "repository"}
}

// DependenciesOrErr returns the Dependencies value or an error if the edge
// was not loaded in eager-loading.
func (e ComponentEdges) DependenciesOrErr() ([]*ComponentDependency, error) {
	if e.loadedTypes[1] {
		return e.Dependencies, nil
	}
	return nil, &NotLoadedError{edge: "dependencies"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Component) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case component.FieldTags, component.FieldCategories, component.FieldKeywords, component.FieldPlatforms:
			values[i] = new([]byte)
		case component.FieldIsInstalled:
			values[i] = new(sql.NullBool)
		case component.FieldID, component.FieldName, component.FieldNamespace, component.FieldVersion, component.FieldKind, component.FieldDescription, component.FieldAuthor, component.FieldLicense, component.FieldHomepage, component.FieldDocumentation, component.FieldStability, component.FieldMaturity, component.FieldForgeVersion, component.FieldSpec, component.FieldSpecHash, component.FieldInstallPath, component.FieldCommitHash, component.FieldBranch:
			values[i] = new(sql.NullString)
		case component.FieldInstalledAt, component.FieldCreatedAt, component.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case component.ForeignKeys[0]: // repository_components
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Component fields.
func (c *Component) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case component.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				c.ID = value.String
			}
		case component.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				c.Name = value.String
			}
		case component.FieldNamespace:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field namespace", values[i])
			} else if value.Valid {
				c.Namespace = value.String
			}
		case component.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				c.Version = value.String
			}
		case component.FieldKind:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field kind", values[i])
			} else if value.Valid {
				c.Kind = component.Kind(value.String)
			}
		case component.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				c.Description = value.String
			}
		case component.FieldAuthor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field author", values[i])
			} else if value.Valid {
				c.Author = value.String
			}
		case component.FieldLicense:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field license", values[i])
			} else if value.Valid {
				c.License = value.String
			}
		case component.FieldHomepage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field homepage", values[i])
			} else if value.Valid {
				c.Homepage = new(string)
				*c.Homepage = value.String
			}
		case component.FieldDocumentation:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field documentation", values[i])
			} else if value.Valid {
				c.Documentation = new(string)
				*c.Documentation = value.String
			}
		case component.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case component.FieldCategories:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field categories", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Categories); err != nil {
					return fmt.Errorf("unmarshal field categories: %w", err)
				}
			}
		case component.FieldKeywords:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field keywords", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Keywords); err != nil {
					return fmt.Errorf("unmarshal field keywords: %w", err)
				}
			}
		case component.FieldStability:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field stability", values[i])
			} else if value.Valid {
				c.Stability = component.Stability(value.String)
			}
		case component.FieldMaturity:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field maturity", values[i])
			} else if value.Valid {
				c.Maturity = component.Maturity(value.String)
			}
		case component.FieldForgeVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field forge_version", values[i])
			} else if value.Valid {
				c.ForgeVersion = value.String
			}
		case component.FieldPlatforms:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field platforms", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Platforms); err != nil {
					return fmt.Errorf("unmarshal field platforms: %w", err)
				}
			}
		case component.FieldSpec:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec", values[i])
			} else if value.Valid {
				c.Spec = value.String
			}
		case component.FieldSpecHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field spec_hash", values[i])
			} else if value.Valid {
				c.SpecHash = value.String
			}
		case component.FieldIsInstalled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_installed", values[i])
			} else if value.Valid {
				c.IsInstalled = value.Bool
			}
		case component.FieldInstallPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field install_path", values[i])
			} else if value.Valid {
				c.InstallPath = new(string)
				*c.InstallPath = value.String
			}
		case component.FieldInstalledAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field installed_at", values[i])
			} else if value.Valid {
				c.InstalledAt = new(time.Time)
				*c.InstalledAt = value.Time
			}
		case component.FieldCommitHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field commit_hash", values[i])
			} else if value.Valid {
				c.CommitHash = value.String
			}
		case component.FieldBranch:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field branch", values[i])
			} else if value.Valid {
				c.Branch = value.String
			}
		case component.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				c.CreatedAt = value.Time
			}
		case component.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				c.UpdatedAt = value.Time
			}
		case component.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field repository_components", values[i])
			} else if value.Valid {
				c.repository_components = new(string)
				*c.repository_components = value.String
			}
		default:
			c.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Component.
// This includes values selected through modifiers, order, etc.
func (c *Component) Value(name string) (ent.Value, error) {
	return c.selectValues.Get(name)
}

// QueryRepository queries the "repository" edge of the Component entity.
func (c *Component) QueryRepository() *RepositoryQuery {
	return NewComponentClient(c.config).QueryRepository(c)
}

// QueryDependencies queries the "dependencies" edge of the Component entity.
func (c *Component) QueryDependencies() *ComponentDependencyQuery {
	return NewComponentClient(c.config).QueryDependencies(c)
}

// Update returns a builder for updating this Component.
// Note that you need to call Component.Unwrap() before calling this method if this Component
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Component) Update() *ComponentUpdateOne {
	return NewComponentClient(c.config).UpdateOne(c)
}

// Unwrap unwraps the Component entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (c *Component) Unwrap() *Component {
	_tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Component is not a transactional entity")
	}
	c.config.driver = _tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Component) String() string {
	var builder strings.Builder
	builder.WriteString("Component(")
	builder.WriteString(fmt.Sprintf("id=%v, ", c.ID))
	builder.WriteString("name=")
	builder.WriteString(c.Name)
	builder.WriteString(", ")
	builder.WriteString("namespace=")
	builder.WriteString(c.Namespace)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(c.Version)
	builder.WriteString(", ")
	builder.WriteString("kind=")
	builder.WriteString(fmt.Sprintf("%v", c.Kind))
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(c.Description)
	builder.WriteString(", ")
	builder.WriteString("author=")
	builder.WriteString(c.Author)
	builder.WriteString(", ")
	builder.WriteString("license=")
	builder.WriteString(c.License)
	builder.WriteString(", ")
	if v := c.Homepage; v != nil {
		builder.WriteString("homepage=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := c.Documentation; v != nil {
		builder.WriteString("documentation=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", c.Tags))
	builder.WriteString(", ")
	builder.WriteString("categories=")
	builder.WriteString(fmt.Sprintf("%v", c.Categories))
	builder.WriteString(", ")
	builder.WriteString("keywords=")
	builder.WriteString(fmt.Sprintf("%v", c.Keywords))
	builder.WriteString(", ")
	builder.WriteString("stability=")
	builder.WriteString(fmt.Sprintf("%v", c.Stability))
	builder.WriteString(", ")
	builder.WriteString("maturity=")
	builder.WriteString(fmt.Sprintf("%v", c.Maturity))
	builder.WriteString(", ")
	builder.WriteString("forge_version=")
	builder.WriteString(c.ForgeVersion)
	builder.WriteString(", ")
	builder.WriteString("platforms=")
	builder.WriteString(fmt.Sprintf("%v", c.Platforms))
	builder.WriteString(", ")
	builder.WriteString("spec=")
	builder.WriteString(c.Spec)
	builder.WriteString(", ")
	builder.WriteString("spec_hash=")
	builder.WriteString(c.SpecHash)
	builder.WriteString(", ")
	builder.WriteString("is_installed=")
	builder.WriteString(fmt.Sprintf("%v", c.IsInstalled))
	builder.WriteString(", ")
	if v := c.InstallPath; v != nil {
		builder.WriteString("install_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := c.InstalledAt; v != nil {
		builder.WriteString("installed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("commit_hash=")
	builder.WriteString(c.CommitHash)
	builder.WriteString(", ")
	builder.WriteString("branch=")
	builder.WriteString(c.Branch)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(c.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(c.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Components is a parsable slice of Component.
type Components []*Component
